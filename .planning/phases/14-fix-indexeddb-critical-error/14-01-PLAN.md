---
phase: 14-fix-indexeddb-critical-error
plan: 01
type: execute
---

<objective>
Risolvere completamente l'errore `IDBObjectStore 'put'` che appare su tutte le pagine della PWA.

Purpose: Garantire stabilità completa delle operazioni IndexedDB eliminando errori DataError causati da campi undefined, migliorando logging per tracciabilità errori.
Output: Tutte le operazioni IndexedDB robuste contro campi undefined, logging strutturato per debug efficace, zero errori `IDBObjectStore 'put'` in produzione.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@archibald-web-app/frontend/src/db/schema.ts
@archibald-web-app/frontend/src/services/cache-population.ts
@archibald-web-app/frontend/src/services/draft-service.ts
@archibald-web-app/frontend/src/services/pending-orders-service.ts
@archibald-web-app/frontend/src/services/cache-service.ts

**Recent fixes context (from STATE.md):**
- Commit 60377c1: Added schema v3 migration to clear corrupted draft orders, filtered undefined in cache-population.ts
- Commit 73b11fc: Fixed draft orders undefined id by conditionally including id field only when it exists

**Problem patterns identified:**
- Auto-increment tables (++id) require omitting id field for new records
- bulkPut() fails with DataError when fields contain undefined values
- 101 console.log instances mask real IndexedDB errors in production

**Current mitigation (partial):**
- cache-population.ts filters undefined fields: `if (c[key] !== undefined) { cleaned[key] = c[key]; }`
- draft-service.ts conditionally includes id: `...(existing?.id ? { id: existing.id } : {})`
- Schema v3 migration clears corrupted draft orders on upgrade

**Vulnerability scope:**
Services using IndexedDB: cache-population, cache-service, draft-service, pending-orders-service, database.ts
Operations at risk: bulkPut, put, add (all write operations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Audit all IndexedDB write operations for undefined field handling</name>
  <files>
    archibald-web-app/frontend/src/services/cache-service.ts,
    archibald-web-app/frontend/src/services/pending-orders-service.ts,
    archibald-web-app/frontend/src/services/draft-service.ts,
    archibald-web-app/frontend/src/db/database.ts
  </files>
  <action>
    Search for all IndexedDB write operations (bulkPut, put, add) across IndexedDB services.
    For each operation, verify if data is sanitized to remove undefined fields BEFORE write.

    Pattern to find: db.{tableName}.bulkPut(), db.{tableName}.put(), db.{tableName}.add()

    Check if operation:
    1. Filters undefined fields like cache-population.ts (cleanedCustomers pattern)
    2. Conditionally includes auto-increment id like draft-service.ts (spread operator pattern)
    3. Has NO sanitization (VULNERABLE - needs fix in Task 2)

    Document findings in audit comments for Task 2 implementation.

    Why: Comprehensive audit prevents missing vulnerable operations. Same undefined bug can occur in any service writing to IndexedDB.
  </action>
  <verify>
    grep -r "bulkPut\|\.put(\|\.add(" archibald-web-app/frontend/src/services/ archibald-web-app/frontend/src/db/

    All write operations identified and categorized as:
    - ✅ Protected (has undefined filtering)
    - ⚠️ Vulnerable (no sanitization)
  </verify>
  <done>
    Complete list of IndexedDB write operations documented.
    Each operation categorized as protected or vulnerable.
    Vulnerable operations identified for Task 2 fixes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix undefined field handling in vulnerable IndexedDB operations</name>
  <files>
    archibald-web-app/frontend/src/services/cache-service.ts,
    archibald-web-app/frontend/src/services/pending-orders-service.ts,
    archibald-web-app/frontend/src/services/draft-service.ts,
    archibald-web-app/frontend/src/db/database.ts
  </files>
  <action>
    For each vulnerable operation identified in Task 1, apply appropriate sanitization pattern:

    **Pattern A - For data from external sources (arrays of objects):**
    ```typescript
    const cleaned = dataArray.map((item: any) => {
      const sanitized: any = {};
      for (const key in item) {
        if (item[key] !== undefined) {
          sanitized[key] = item[key];
        }
      }
      return sanitized;
    });
    await db.tableName.bulkPut(cleaned);
    ```

    **Pattern B - For auto-increment tables with conditional id:**
    ```typescript
    const record = {
      ...(existingRecord?.id ? { id: existingRecord.id } : {}),
      field1: value1,
      field2: value2
    };
    await db.tableName.put(record);
    ```

    Apply Pattern A when writing bulk data (customers, products, prices).
    Apply Pattern B when writing single records with auto-increment id (drafts, pending orders).

    Why Pattern A: External data may have undefined fields from API responses or scraping.
    Why Pattern B: Auto-increment requires omitting id for new records, including id for updates.
  </action>
  <verify>
    npm run typecheck (should pass with no TypeScript errors)

    Manual test checklist:
    1. Clear IndexedDB via clear-indexeddb.html utility
    2. Login and trigger cache population (should succeed without errors)
    3. Create draft order (should succeed without undefined id error)
    4. Add pending order offline (should succeed without field errors)
    5. Check browser console for DataError or IDBObjectStore errors (should be zero)
  </verify>
  <done>
    All vulnerable IndexedDB operations now sanitize undefined fields.
    TypeScript compilation passes.
    Manual testing confirms no DataError in browser console.
    Zero `IDBObjectStore 'put'` errors across all IndexedDB operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: Replace console.log with structured logging in IndexedDB services</name>
  <files>
    archibald-web-app/frontend/src/services/cache-population.ts,
    archibald-web-app/frontend/src/services/cache-service.ts,
    archibald-web-app/frontend/src/services/pending-orders-service.ts,
    archibald-web-app/frontend/src/services/draft-service.ts,
    archibald-web-app/frontend/src/db/schema.ts,
    archibald-web-app/frontend/src/db/database.ts
  </files>
  <action>
    Replace all console.log/console.error in IndexedDB-related files with structured logging pattern.

    **Pattern - Structured logging:**
    ```typescript
    // Replace: console.log('[CachePopulation] Saving customers...')
    // With:
    console.log('[IndexedDB:CachePopulation]', {
      operation: 'bulkPut',
      table: 'customers',
      recordCount: customers.length,
      timestamp: new Date().toISOString()
    });

    // Replace: console.error('[CachePopulation] Failed:', error)
    // With:
    console.error('[IndexedDB:CachePopulation]', {
      operation: 'bulkPut',
      table: 'customers',
      error: error instanceof Error ? error.message : String(error),
      stack: error instanceof Error ? error.stack : undefined,
      timestamp: new Date().toISOString()
    });
    ```

    Benefits:
    - Consistent prefix `[IndexedDB:ServiceName]` for easy filtering in production logs
    - Structured data enables log aggregation and analysis
    - Stack traces captured for debugging
    - Timestamp for chronological analysis

    Scope: Only IndexedDB service files (6 files total). Leave other console.log untouched (out of Phase 14 scope).

    Why: Production errors currently lost in noise of 101 console.log statements. Structured logging enables filtering, searching, and error tracking.
  </action>
  <verify>
    grep "console\.(log|error)" archibald-web-app/frontend/src/services/cache-*.ts archibald-web-app/frontend/src/services/*-service.ts archibald-web-app/frontend/src/db/*.ts

    All matches should follow structured logging pattern with:
    - Prefix: [IndexedDB:ServiceName]
    - Object parameter with operation, table, timestamp
    - Error logging includes stack trace
  </verify>
  <done>
    All console.log/error in IndexedDB services use structured logging pattern.
    Logs filterable by [IndexedDB:*] prefix in production.
    Error logs include stack traces for debugging.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm run typecheck` passes in frontend directory
- [ ] No TypeScript errors introduced
- [ ] Manual browser test: Clear IndexedDB → login → cache population → create draft → no console errors
- [ ] All IndexedDB write operations sanitize undefined fields
- [ ] All IndexedDB service logs use structured format with [IndexedDB:*] prefix
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Zero `IDBObjectStore 'put'` errors in browser console after full user flow test
- All IndexedDB write operations protected against undefined fields
- Structured logging enables production error tracking
- No regressions in existing IndexedDB functionality
  </success_criteria>

<output>
After completion, create `.planning/phases/14-fix-indexeddb-critical-error/14-01-SUMMARY.md`:

# Phase 14 Plan 01: IndexedDB Error Audit & Fix Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `path/to/file.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 14 complete. Ready for Phase 15 (Dashboard Homepage UI).
</output>
