---
phase: 15-individual-sync-testing
plan: 01
subsystem: sync
tags: [concurrency-testing, critical-issues, product-price-concurrent-writes, order-same-user-concurrent]
---

# Phase 15 Plan 01: Critical Concurrency Testing

**Test CRITICAL concurrent scenarios (Product+Price, Order same-user) to validate SQLite behavior and identify actual failure modes**

## Objective

Execute the 2 CRITICAL concurrency tests identified in Phase 14 to empirically validate actual behavior:

1. **C-1 (CRITICAL)**: Product sync + Price sync concurrent writes to same table
2. **C-3 (HIGH)**: Order sync same-user double-click (no serialization)

**Goal**: Gather empirical evidence of actual behavior (success, timeout, corruption, resource waste) to inform fix design in Phase 16.

**Non-goal**: Fixing issues (deferred to Phase 16 - fixes require architectural decisions based on test results).

## Execution Context

**Testing approach**:
- Manual user simulation (no automated test harness required)
- Real production code paths (no mocks)
- Observe actual SQLite behavior (WAL mode, locks, timeouts)
- Capture evidence (logs, timings, database state)

**Environment**:
- Development environment with full Archibald backend running
- Real SQLite databases (products.db, orders-{userId}.db)
- Real Puppeteer browser sessions
- PriorityManager coordination enabled

**Success criteria**:
- Empirical evidence gathered for both CRITICAL tests
- Behavior documented (success, failure, timeout, corruption)
- Performance characteristics measured (duration, lock contention)
- Fix recommendations informed by actual behavior

## Context

**From Phase 14 findings**:

### Issue 1 (CRITICAL): Product + Price Concurrent Writes

**Evidence from code**:
- Both services write to `products` table in `products.db`
- Product sync: `UPDATE products SET name=?, category=?, ... WHERE id=?`
- Price sync: `UPDATE products SET listPrice=?, priceA=?, ... WHERE id=?`
- No coordination mechanism between services
- Both use same serialization flag (`syncInProgress`) but separately
- SQLite uses WAL mode (allows concurrent readers, exclusive writer)

**Unknown behavior**:
- Does SQLite handle this gracefully? (WAL should allow)
- Do writes timeout? If so, how long?
- Is data consistency preserved? (partial writes, lost updates)
- Performance impact? (blocking, contention)

**Testing scenario**:
1. Trigger product sync (scheduler or manual)
2. Immediately trigger price sync (manual API call)
3. Observe: completion, errors, duration, logs
4. Verify: database consistency, no lost writes

### Issue 2 (HIGH): Order Sync No Serialization

**Evidence from code**:
- Order sync writes to per-user database `orders-{userId}.db`
- No serialization flag (unlike customer, product, price syncs)
- User can click "Refresh Orders" button multiple times
- Each click spawns new sync session with Puppeteer browser
- Both sessions scrape same data, write to same database

**Expected behavior**:
- Both syncs complete successfully (per-user database isolation)
- Resource waste: 2x CPU, 2x memory, 2x Puppeteer browsers
- No data corruption (SQLite handles concurrent writes to per-user DB)

**Testing scenario**:
1. Click "Refresh Orders" button
2. Immediately click "Refresh Orders" again (before first completes)
3. Observe: concurrent execution, resource usage, completion
4. Verify: database consistency, no crashes

### Key Files

**Product Sync Service**:
- `archibald-web-app/backend/src/services/product-sync-service.ts`
  - Lines 75-100: Serialization flag check (`syncInProgress`)
  - Lines 250-350: Page scraping loop
  - Lines 400-450: Database upsert with transaction

**Price Sync Service**:
- `archibald-web-app/backend/src/services/price-sync-service.ts`
  - Lines 60-85: Serialization flag check (`syncInProgress`)
  - Lines 200-300: Price scraping + multi-level matching
  - Lines 350-400: Batch transaction update

**Order History Service**:
- `archibald-web-app/backend/src/services/order-history-service.ts`
  - Lines 100-150: No serialization flag (gap)
  - Lines 200-300: Order list scraping
  - Lines 400-500: Unified enrichment (details + DDT)

**Database Helpers**:
- `archibald-web-app/backend/src/db/product-db.ts`
  - Product and price update methods
- `archibald-web-app/backend/src/db/order-db.ts`
  - Per-user order upsert methods

**API Endpoints**:
- `archibald-web-app/backend/src/routes/sync-control.ts`
  - Manual sync trigger endpoints

## Tasks

### Task 1: Test C-1 (Product + Price Concurrent Writes) ðŸ”´ CRITICAL

**What**: Spawn product sync and price sync simultaneously, observe SQLite behavior.

**Steps**:
1. Read product-sync-service.ts and price-sync-service.ts to understand current implementation
2. Identify trigger points for manual sync (API endpoints or scheduler)
3. Design test procedure:
   - Start product sync via manual API call
   - Immediately (within 1 second) start price sync via manual API call
   - Monitor logs for errors, warnings, timeouts
   - Measure duration for both syncs
   - Verify database state after completion
4. Execute test 3 times to verify consistency
5. Document findings:
   - Did both syncs complete successfully?
   - Any errors or warnings in logs?
   - Duration comparison (concurrent vs sequential baseline)
   - Database consistency check (no lost updates, no partial writes)
   - SQLite lock behavior (from logs or DB journal inspection)

**Evidence to capture**:
- Console logs from both syncs (timestamps, errors, warnings)
- Sync duration metrics
- Database row count before/after
- Any timeout or lock contention errors

**Verification**:
- [ ] Test executed 3 times with consistent results
- [ ] Findings documented in test log
- [ ] Behavior classified (success, timeout, corruption, or mixed)
- [ ] Fix recommendations drafted based on empirical evidence

**Commit**: `test(15-01): execute C-1 product+price concurrent write test`

---

### Task 2: Test C-3 (Order Sync Same-User Concurrent) ðŸ”´ HIGH

**What**: Click "Refresh Orders" twice to spawn concurrent same-user syncs, observe resource usage.

**Steps**:
1. Read order-history-service.ts to confirm no serialization flag
2. Identify UI button and API endpoint for manual order refresh
3. Design test procedure:
   - Login as test user
   - Click "Refresh Orders" button
   - Immediately click "Refresh Orders" again (double-click simulation)
   - Monitor logs for concurrent execution
   - Check process list for multiple Puppeteer browsers
   - Measure resource usage (CPU, memory)
   - Verify both syncs complete successfully
4. Execute test 3 times to verify consistency
5. Document findings:
   - Do both syncs run concurrently? (no serialization)
   - Resource waste quantified (2x Puppeteer, 2x CPU)
   - Any errors or race conditions?
   - Database consistency preserved? (per-user isolation)
   - Performance impact (both take longer due to contention?)

**Evidence to capture**:
- Console logs showing concurrent execution (timestamps)
- Process list showing multiple Puppeteer browsers
- CPU and memory usage during concurrent syncs
- Database state consistency (no duplicate or missing orders)

**Verification**:
- [ ] Test executed 3 times with consistent results
- [ ] Concurrent execution confirmed (no serialization)
- [ ] Resource waste quantified
- [ ] Fix recommendations drafted (per-user serialization map)

**Commit**: `test(15-01): execute C-3 order same-user concurrent test`

---

### Task 3: Document Findings and Fix Recommendations

**What**: Create comprehensive test report with empirical evidence and fix recommendations.

**Steps**:
1. Synthesize findings from Task 1 and Task 2
2. Create `15-01-TEST-REPORT.md` with structure:
   - Executive summary (CRITICAL findings)
   - Test C-1 detailed results (evidence, behavior classification)
   - Test C-2 detailed results (evidence, behavior classification)
   - Concurrency risk matrix (actual vs predicted behavior)
   - Fix recommendations with priority (informed by empirical data)
   - Testing artifacts (logs, screenshots, metrics)
3. Update issue tracker with actual severity based on test results
4. Define Phase 16 scope based on test findings

**Verification**:
- [ ] Test report created with all evidence
- [ ] Behavior classified for both tests
- [ ] Fix recommendations prioritized
- [ ] Phase 16 scope defined

**Commit**: `docs(15-01): create critical concurrency test report`

---

## Verification

After all tasks complete:

1. **C-1 (Product + Price Concurrent)**: Empirical behavior documented
   - Success: Both complete, no errors â†’ Low priority fix (WAL handles it)
   - Timeout: One or both timeout â†’ High priority fix (global lock or coordination)
   - Corruption: Data loss or partial writes â†’ Critical priority fix (immediate)

2. **C-3 (Order Same-User Concurrent)**: Resource waste quantified
   - Concurrent execution confirmed (no serialization)
   - Resource waste measured (2x Puppeteer, 2x CPU)
   - Fix recommendation: Per-user serialization map

3. **Test Report**: Comprehensive documentation
   - Evidence-based analysis
   - Fix recommendations prioritized
   - Phase 16 scope defined

## Success Criteria

- [ ] C-1 test executed 3 times with consistent, documented results
- [ ] C-3 test executed 3 times with consistent, documented results
- [ ] Test report created with empirical evidence
- [ ] Fix recommendations prioritized based on actual behavior
- [ ] Phase 16 scope defined (concurrency fixes)
- [ ] No code changes made (testing only, fixes deferred to Phase 16)

## Output

**Artifacts**:
- `.planning/phases/15-individual-sync-testing/15-01-TEST-REPORT.md` - Comprehensive test report with evidence
- Test logs captured in report (console output, timestamps, errors)
- Behavior classification for both CRITICAL tests
- Fix recommendations prioritized by empirical severity

**Knowledge gained**:
- Actual SQLite concurrent write behavior (WAL mode in practice)
- Resource waste quantification for order same-user concurrent
- Concurrency risk matrix updated with empirical data
- Phase 16 scope defined based on test findings
