# Phase 19.1 Plan 01: Backend Variant Grouping API

<objective>
Create backend API endpoint and database methods to retrieve product variants grouped by base ID, enabling frontend to display unified product cards with variant selection.
</objective>

<execution_context>
@archibald-web-app/backend/src/product-db.ts
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/types.ts
@archibald-web-app/frontend/src/api/products.ts
@.planning/phases/19.1-product-ui-variant-management/19.1-CONTEXT.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/STRUCTURE.md
</execution_context>

<context>
**Current State:**
- Products synced from PDF with 26+ fields (Phase 19-01 complete)
- Each packageContent variant has unique `id` (e.g., "016869K2" for 5-piece, "016869K3" for 1-piece)
- ProductCard.tsx displays ~12 fields currently
- No variant grouping - each variant appears as separate card in ArticoliList

**From Phase 19.1 Context:**
- Variants share same base article name but have different `id` and `packageContent`
- Example: "354TL.12.000.050" article has multiple variants with IDs like "016869K2", "016869K3"
- Each variant has different minQty, multipleQty, maxQty based on packageContent
- Prices come from database (populated by Phase 4.1-02)

**Phase 3 Pattern (from 03-01-SUMMARY.md):**
- Phase 3 implemented package selection logic for OrderForm
- Database method: `getProductVariants(articleName)` - returns all variants for article
- Selection logic: choose variant based on quantity ordered

**Tech Stack:**
- Backend: Express + TypeScript + better-sqlite3
- Frontend: React 19 + TypeScript
- API: JWT-protected REST endpoints
- Naming: kebab-case for backend files, camelCase for functions
- Singleton pattern: ProductDatabase.getInstance()

**Goal:**
Enable frontend to:
1. Query all variants for a product
2. Group variants by base article
3. Display unified product cards with variant selector
</context>

<tasks>

## Task 1: Add getProductVariants method to ProductDatabase

**File:** `archibald-web-app/backend/src/product-db.ts`

Add database method to retrieve all variants for a given article name:

```typescript
/**
 * Get all package variants for a product by article name
 * Variants share the same name but have different IDs and packageContent
 */
getProductVariants(articleName: string): Product[] {
  const stmt = this.db.prepare(`
    SELECT * FROM products
    WHERE name = ?
    ORDER BY
      CAST(SUBSTR(packageContent, 1, INSTR(packageContent || ' ', ' ') - 1) AS INTEGER) DESC,
      packageContent DESC
  `);
  return stmt.all(articleName) as Product[];
}

/**
 * Get base product (lowest packageContent variant) for article name
 * Used as representative product in grouped views
 */
getBaseProduct(articleName: string): Product | undefined {
  const variants = this.getProductVariants(articleName);
  // Return variant with lowest packageContent (e.g., "1 collo" before "5 colli")
  return variants.length > 0 ? variants[variants.length - 1] : undefined;
}

/**
 * Get all unique product names (deduplicated by article name)
 * Used for ArticoliList to show one card per product
 */
getAllProductNames(searchTerm?: string, limit: number = 100): string[] {
  let query = `
    SELECT DISTINCT name
    FROM products
  `;
  const params: any[] = [];

  if (searchTerm) {
    query += ` WHERE name LIKE ? OR id LIKE ? OR searchName LIKE ?`;
    const searchPattern = `%${searchTerm}%`;
    params.push(searchPattern, searchPattern, searchPattern);
  }

  query += ` ORDER BY name ASC LIMIT ?`;
  params.push(limit);

  const stmt = this.db.prepare(query);
  const results = stmt.all(...params) as { name: string }[];
  return results.map(r => r.name);
}
```

**Rationale:**
- Sort variants by numeric value extracted from packageContent (5 colli before 1 collo)
- `getBaseProduct` returns lowest packageContent as representative for grouped view
- `getAllProductNames` enables deduplication in ArticoliList
- Follows existing singleton pattern and kebab-case naming

## Task 2: Add GET /api/products/:name/variants endpoint

**File:** `archibald-web-app/backend/src/index.ts`

Add new REST endpoint to retrieve variants for a product:

```typescript
// GET /api/products/:name/variants - Get all variants for a product name
app.get(
  "/api/products/:name/variants",
  jwtMiddleware,
  (req: Request, res: Response) => {
    try {
      const { name } = req.params;
      const decodedName = decodeURIComponent(name);

      const db = ProductDatabase.getInstance();
      const variants = db.getProductVariants(decodedName);

      if (variants.length === 0) {
        res.status(404).json({
          success: false,
          error: "Product not found",
        });
        return;
      }

      logger.info(`Retrieved ${variants.length} variants for product: ${decodedName}`);

      res.json({
        success: true,
        data: {
          productName: decodedName,
          variantCount: variants.length,
          variants: variants,
        },
      });
    } catch (error: any) {
      logger.error("Error fetching product variants", {
        error: error.message,
        stack: error.stack,
      });

      res.status(500).json({
        success: false,
        error: "Failed to fetch product variants",
      });
    }
  }
);
```

**Rationale:**
- JWT-protected (consistent with existing endpoints)
- URL-decode product name (handles spaces, special chars)
- Returns structured response with variant count
- Follows existing error handling pattern (logger + HTTP status)

## Task 3: Update GET /api/products endpoint to support grouped mode

**File:** `archibald-web-app/backend/src/index.ts`

Modify existing `/api/products` endpoint to support optional `?grouped=true` query parameter:

```typescript
// Update existing GET /api/products endpoint
app.get("/api/products", jwtMiddleware, (req: Request, res: Response) => {
  try {
    const search = (req.query.search as string) || "";
    const limit = Math.min(
      parseInt(req.query.limit as string) || 100,
      1000
    );
    const grouped = req.query.grouped === "true"; // NEW: grouped mode flag

    const db = ProductDatabase.getInstance();

    if (grouped) {
      // NEW: Grouped mode - return one product per article name
      const productNames = db.getAllProductNames(search, limit);
      const products = productNames.map(name => db.getBaseProduct(name)!).filter(Boolean);

      const totalCount = productNames.length;
      const returnedCount = products.length;

      logger.info(`Retrieved ${returnedCount} grouped products (search: "${search}")`);

      res.json({
        success: true,
        data: {
          products: products,
          totalCount: totalCount,
          returnedCount: returnedCount,
          limited: returnedCount >= limit,
          grouped: true, // Indicate grouped mode in response
        },
      });
    } else {
      // EXISTING: Normal mode - return all variants
      const allProducts = db.getAllProducts();

      let filteredProducts = allProducts;
      if (search) {
        const searchLower = search.toLowerCase();
        filteredProducts = allProducts.filter(
          (p) =>
            p.name.toLowerCase().includes(searchLower) ||
            p.id.toLowerCase().includes(searchLower) ||
            (p.description && p.description.toLowerCase().includes(searchLower))
        );
      }

      const totalCount = filteredProducts.length;
      const returnedCount = Math.min(limit, filteredProducts.length);
      const products = filteredProducts.slice(0, limit);

      logger.info(
        `Retrieved ${returnedCount}/${totalCount} products (search: "${search}")`
      );

      res.json({
        success: true,
        data: {
          products: products,
          totalCount: totalCount,
          returnedCount: returnedCount,
          limited: returnedCount < totalCount,
          grouped: false,
        },
      });
    }
  } catch (error: any) {
    logger.error("Error fetching products", {
      error: error.message,
      stack: error.stack,
    });

    res.status(500).json({
      success: false,
      error: "Failed to fetch products",
    });
  }
});
```

**Rationale:**
- Backwards compatible - existing calls work unchanged
- `?grouped=true` returns one product per article (using base variant as representative)
- `grouped` flag in response helps frontend distinguish mode
- Minimal changes to existing endpoint structure

## Task 4: Add frontend API client methods

**File:** `archibald-web-app/frontend/src/api/products.ts`

Add TypeScript API client methods for variant retrieval:

```typescript
export interface ProductVariantsResponse {
  success: boolean;
  data: {
    productName: string;
    variantCount: number;
    variants: Product[];
  };
  error?: string;
}

/**
 * Get all package variants for a product by article name
 */
export async function getProductVariants(
  token: string,
  productName: string
): Promise<ProductVariantsResponse> {
  const encodedName = encodeURIComponent(productName);
  const response = await fetch(`/api/products/${encodedName}/variants`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
  });

  if (!response.ok) {
    if (response.status === 401) {
      throw new Error("401");
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || "Failed to fetch product variants");
  }

  return response.json();
}

/**
 * Get products with optional grouping by article name
 */
export async function getProducts(
  token: string,
  searchTerm: string = "",
  limit: number = 100,
  grouped: boolean = false // NEW: optional grouping parameter
): Promise<ProductsResponse> {
  const params = new URLSearchParams({
    search: searchTerm,
    limit: limit.toString(),
  });

  if (grouped) {
    params.append("grouped", "true");
  }

  const response = await fetch(`/api/products?${params.toString()}`, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
      "Content-Type": "application/json",
    },
  });

  if (!response.ok) {
    if (response.status === 401) {
      throw new Error("401");
    }
    const errorData = await response.json().catch(() => ({}));
    throw new Error(errorData.error || "Failed to fetch products");
  }

  return response.json();
}
```

**Rationale:**
- Type-safe API client methods
- URL encoding handles spaces/special chars in product names
- `grouped` parameter added to existing `getProducts` (backwards compatible)
- Follows existing error handling pattern (401 detection)

</tasks>

<verification>

## Manual Testing Checklist

### 1. Backend API Testing

**Test getProductVariants method:**
```bash
# Create test script: archibald-web-app/backend/src/test-variants.ts
npm run dev

# In Node.js REPL or test script:
const { ProductDatabase } = require('./product-db');
const db = ProductDatabase.getInstance();

// Test variant retrieval
const variants = db.getProductVariants('GUARNIZIONE CANALETTA');
console.log(`Found ${variants.length} variants`);
console.log(variants.map(v => `${v.id} - ${v.packageContent}`));

// Test base product
const base = db.getBaseProduct('GUARNIZIONE CANALETTA');
console.log(`Base variant: ${base?.id} - ${base?.packageContent}`);

// Test product names
const names = db.getAllProductNames('', 10);
console.log(`First 10 product names:`, names);
```

**Expected Results:**
- ✓ Returns multiple variants with same name but different IDs
- ✓ Variants sorted by packageContent (descending numeric)
- ✓ Base product is variant with lowest packageContent
- ✓ Product names are deduplicated

**Test GET /api/products/:name/variants endpoint:**
```bash
# Get JWT token first
TOKEN="your-jwt-token-here"

# Test variant retrieval (use actual product name from DB)
curl -X GET "http://localhost:3001/api/products/GUARNIZIONE%20CANALETTA/variants" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json"
```

**Expected Response:**
```json
{
  "success": true,
  "data": {
    "productName": "GUARNIZIONE CANALETTA",
    "variantCount": 2,
    "variants": [
      {
        "id": "016869K2",
        "name": "GUARNIZIONE CANALETTA",
        "packageContent": "5 colli",
        "minQty": 5,
        "multipleQty": 5,
        ...
      },
      {
        "id": "016869K3",
        "name": "GUARNIZIONE CANALETTA",
        "packageContent": "1 collo",
        "minQty": 1,
        "multipleQty": 1,
        ...
      }
    ]
  }
}
```

**Test GET /api/products?grouped=true endpoint:**
```bash
# Test grouped mode
curl -X GET "http://localhost:3001/api/products?grouped=true&limit=10" \
  -H "Authorization: Bearer $TOKEN"

# Test normal mode (backwards compatibility)
curl -X GET "http://localhost:3001/api/products?limit=10" \
  -H "Authorization: Bearer $TOKEN"
```

**Expected Results:**
- ✓ Grouped mode returns one product per article name
- ✓ Normal mode returns all variants (unchanged behavior)
- ✓ Both modes return `grouped` flag in response
- ✓ Total counts reflect grouping mode

### 2. Frontend API Client Testing

**Test in browser console:**
```javascript
// Get token from localStorage
const token = localStorage.getItem('archibald_jwt');

// Test getProductVariants
const { getProductVariants } = await import('/src/api/products.ts');
const result = await getProductVariants(token, 'GUARNIZIONE CANALETTA');
console.log('Variants:', result.data.variants);

// Test grouped getProducts
const { getProducts } = await import('/src/api/products.ts');
const grouped = await getProducts(token, '', 100, true);
console.log('Grouped products:', grouped.data.products.length);

const normal = await getProducts(token, '', 100, false);
console.log('Normal products:', normal.data.products.length);
```

**Expected Results:**
- ✓ API client methods work without errors
- ✓ Grouped mode returns fewer products than normal mode
- ✓ TypeScript types work correctly

### 3. Edge Cases

**Test with products that have no variants:**
```bash
# Product with single variant
curl -X GET "http://localhost:3001/api/products/SINGLE_VARIANT_PRODUCT/variants" \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:**
- ✓ Returns single variant in array
- ✓ variantCount = 1

**Test with non-existent product:**
```bash
curl -X GET "http://localhost:3001/api/products/NONEXISTENT/variants" \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:**
- ✓ Returns 404 status
- ✓ Error message: "Product not found"

**Test with special characters in product name:**
```bash
# Product name with spaces, accents, special chars
curl -X GET "http://localhost:3001/api/products/GUARNIZIONE%20%C3%88%20SPECIALE/variants" \
  -H "Authorization: Bearer $TOKEN"
```

**Expected:**
- ✓ URL encoding/decoding works correctly
- ✓ Returns variants if product exists

### 4. Performance

**Test with large dataset:**
```bash
# Grouped mode should be faster than returning all variants
time curl -X GET "http://localhost:3001/api/products?grouped=true&limit=1000" \
  -H "Authorization: Bearer $TOKEN" > /dev/null

time curl -X GET "http://localhost:3001/api/products?limit=1000" \
  -H "Authorization: Bearer $TOKEN" > /dev/null
```

**Expected:**
- ✓ Grouped mode faster (fewer results)
- ✓ Both complete within 2 seconds

</verification>

<success_criteria>
- [ ] ProductDatabase methods added: getProductVariants, getBaseProduct, getAllProductNames
- [ ] GET /api/products/:name/variants endpoint created and JWT-protected
- [ ] GET /api/products endpoint supports ?grouped=true parameter
- [ ] Frontend API client methods added: getProductVariants, updated getProducts
- [ ] All API responses include proper error handling
- [ ] Manual testing checklist completed successfully
- [ ] No TypeScript compilation errors
- [ ] Backend compiles and starts without errors
- [ ] Existing OrderForm functionality unaffected (backwards compatible)
</success_criteria>

<output>
**Deliverables:**
1. Updated `archibald-web-app/backend/src/product-db.ts` with 3 new methods
2. Updated `archibald-web-app/backend/src/index.ts` with 1 new endpoint + 1 modified endpoint
3. Updated `archibald-web-app/frontend/src/api/products.ts` with 1 new function + 1 modified function
4. Manual testing completed and documented

**Next Steps:**
- Execute Plan 19.1-02: Refactor ProductCard.tsx to display all 26+ fields
- Execute Plan 19.1-03: Create VariantSelector component and update ArticoliList
</output>
