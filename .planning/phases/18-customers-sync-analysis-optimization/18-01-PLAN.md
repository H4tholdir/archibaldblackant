# Phase 18 Plan 01: PDF Parser Enhancement & Node.js Integration

<objective>
Estendere il parser Python per supportare 8-page cycles (100% field coverage), creare Node.js wrapper per integrazione backend, e validare parsing completo dei 27 campi business da PDF export.
</objective>

<execution_context>
@scripts/parse-clienti-pdf.py
@archibald-web-app/backend/src/customer-db.ts
@.planning/phases/18.1-pdf-export-discovery-validation/PARSER-UPDATE-REQUIRED.md
@.planning/phases/18.1-pdf-export-discovery-validation/FIELD-MAPPING.md
</execution_context>

<context>
## Current State
- ✅ Parser working for pages 0-3 (16 fields - basic info)
- ❌ Missing pages 4-7 (11 fields - analytics & accounts)
- ✅ Database cleaned (removed legacy `internalId`)
- ✅ Discovery validated 100% field coverage (26/26 business fields)

## Required Enhancement
Parser must extract ALL 27 business fields from 8-page PDF cycles:

**Pages 0-3 (Existing - 15 fields):**
- Page 0: customerProfile, name, vatNumber
- Page 1: pec, sdi, fiscalCode, deliveryTerms
- Page 2: street, logisticsAddress, postalCode, city
- Page 3: phone, mobile, url, attentionTo, lastOrderDate

**Pages 4-7 (NEW - 11 fields):**
- Page 4: actualOrderCount, customerType, previousOrderCount1
- Page 5: previousSales1, previousOrderCount2, previousSales2
- Page 6: description, type, externalAccountNumber
- Page 7: ourAccountNumber

## Integration Strategy
Node.js wrapper via child_process for immediate integration, can optimize later if needed.
</context>

<tasks>
<task type="auto">
## 1. Update ParsedCustomer dataclass with pages 4-7 fields

**File:** `scripts/parse-clienti-pdf.py`

Add 11 new fields to ParsedCustomer dataclass (after `last_order_date`):

```python
# Page 4: Order Analytics
actual_order_count: Optional[int] = None  # CONTEGGI DEGLI ORDINI EFFETTIVI
customer_type: Optional[str] = None  # TIPO DI CLIENTE
previous_order_count_1: Optional[int] = None  # CONTEGGIO DEGLI ORDINI PRECEDENTE

# Page 5: Sales Analytics
previous_sales_1: Optional[float] = None  # VENDITE PRECEDENTE
previous_order_count_2: Optional[int] = None  # CONTEGGIO DEGLI ORDINI PRECEDENTE 2
previous_sales_2: Optional[float] = None  # VENDITE PRECEDENTE

# Page 6: Business Info & Accounts
description: Optional[str] = None  # DESCRIZIONE
type: Optional[str] = None  # TYPE
external_account_number: Optional[str] = None  # NUMERO DI CONTO ESTERNO

# Page 7: Internal Account
our_account_number: Optional[str] = None  # IL NOSTRO NUMERO DI CONTO
```

Match field names exactly to FIELD-MAPPING.md for consistency.
</task>

<task type="auto">
## 2. Implement 4 new page parser methods

**File:** `scripts/parse-clienti-pdf.py`

Add methods after `_parse_contact_page()`:

### Method 1: _parse_order_analytics_page (Page 4)
```python
def _parse_order_analytics_page(self, lines: List[str]) -> List[Dict]:
    """Parse page 4: CONTEGGI DEGLI ORDINI EFFETTIVI, TIPO DI CLIENTE, CONTEGGIO DEGLI ORDINI PRECEDENTE"""
    rows = []
    data_lines = lines[1:] if lines else []

    for line in data_lines:
        parts = line.split()

        actual_order_count = None
        customer_type = None
        previous_order_count_1 = None

        # Pattern: "4 1.792,97 € 97"
        # First column: integer (actualOrderCount)
        # Second+Third: currency amount (skip for MVP - not in schema)
        # Last column: integer (previousOrderCount1)

        if len(parts) >= 1 and parts[0].isdigit():
            actual_order_count = int(parts[0])

        # Last numeric value is previousOrderCount1
        for part in reversed(parts):
            if part.isdigit():
                previous_order_count_1 = int(part)
                break

        # Customer type might be in middle (text field)
        # For MVP, skip if not easily identifiable

        rows.append({
            'actual_order_count': actual_order_count,
            'customer_type': customer_type,
            'previous_order_count_1': previous_order_count_1
        })

    return rows
```

### Method 2: _parse_sales_analytics_page (Page 5)
```python
def _parse_sales_analytics_page(self, lines: List[str]) -> List[Dict]:
    """Parse page 5: VENDITE PRECEDENTE, CONTEGGIO DEGLI ORDINI PRECEDENTE 2, VENDITE PRECEDENTE"""
    rows = []
    data_lines = lines[1:] if lines else []

    for line in data_lines:
        # Pattern: "124.497,43 € 112 185.408,57 €"
        # Extract currency amounts and integer

        # Remove € symbols and split
        clean_line = line.replace('€', '').strip()
        parts = clean_line.split()

        previous_sales_1 = None
        previous_order_count_2 = None
        previous_sales_2 = None

        # Find integers and currency amounts
        integers = []
        currencies = []

        for part in parts:
            # Check if currency (contains comma and digits)
            if ',' in part and any(c.isdigit() for c in part):
                # Convert Italian format to float: 124.497,43 → 124497.43
                value = part.replace('.', '').replace(',', '.')
                try:
                    currencies.append(float(value))
                except ValueError:
                    pass
            elif part.isdigit():
                integers.append(int(part))

        # Assign based on position
        if len(currencies) >= 1:
            previous_sales_1 = currencies[0]
        if len(integers) >= 1:
            previous_order_count_2 = integers[0]
        if len(currencies) >= 2:
            previous_sales_2 = currencies[1]

        rows.append({
            'previous_sales_1': previous_sales_1,
            'previous_order_count_2': previous_order_count_2,
            'previous_sales_2': previous_sales_2
        })

    return rows
```

### Method 3: _parse_business_info_page (Page 6)
```python
def _parse_business_info_page(self, lines: List[str]) -> List[Dict]:
    """Parse page 6: DESCRIZIONE, TYPE, NUMERO DI CONTO ESTERNO"""
    rows = []
    data_lines = lines[1:] if lines else []

    for line in data_lines:
        # Pattern: "Debitor Debitor 50"
        # Pattern: "Customer from Concessionario CustFromConcess 223"

        parts = line.split()

        description = None
        type_field = None
        external_account_number = None

        # External account number is last numeric value
        if parts and parts[-1].isdigit():
            external_account_number = parts[-1]
            parts = parts[:-1]

        # Type is known codes (Debitor, CustFromConcess, PotFromCon, etc.)
        known_types = ['Debitor', 'CustFromConcess', 'PotFromCon']
        for part in parts:
            if part in known_types:
                type_field = part

        # Description is remaining text
        description_parts = [p for p in parts if p != type_field]
        if description_parts:
            description = ' '.join(description_parts)

        rows.append({
            'description': description,
            'type': type_field,
            'external_account_number': external_account_number
        })

    return rows
```

### Method 4: _parse_internal_account_page (Page 7)
```python
def _parse_internal_account_page(self, lines: List[str]) -> List[Dict]:
    """Parse page 7: IL NOSTRO NUMERO DI CONTO"""
    rows = []
    data_lines = lines[1:] if lines else []

    for line in data_lines:
        # Single column: our account number
        our_account_number = line.strip() if line.strip() else None

        rows.append({
            'our_account_number': our_account_number
        })

    return rows
```
</task>

<task type="auto">
## 3. Update _parse_cyclic_pages to 8-page cycles

**File:** `scripts/parse-clienti-pdf.py`

In `_parse_cyclic_pages()` method:

**Change line 85:**
```python
cycles = num_pages // 8  # Was: // 4
```

**Update cycle parsing loop (lines 87-131):**
```python
for cycle in range(cycles):
    base_idx = cycle * 8

    # Pages 0-3: Basic info (existing)
    ids_data = self._parse_ids_page(all_pages_lines[base_idx])
    fiscal_data = self._parse_fiscal_page(all_pages_lines[base_idx + 1])
    address_data = self._parse_address_page(all_pages_lines[base_idx + 2])
    contact_data = self._parse_contact_page(all_pages_lines[base_idx + 3])

    # Pages 4-7: Analytics & accounts (NEW)
    order_analytics = self._parse_order_analytics_page(all_pages_lines[base_idx + 4])
    sales_analytics = self._parse_sales_analytics_page(all_pages_lines[base_idx + 5])
    business_info = self._parse_business_info_page(all_pages_lines[base_idx + 6])
    internal_account = self._parse_internal_account_page(all_pages_lines[base_idx + 7])

    # Combine data by row index
    max_rows = max(
        len(ids_data), len(fiscal_data), len(address_data), len(contact_data),
        len(order_analytics), len(sales_analytics), len(business_info), len(internal_account)
    )

    for row_idx in range(max_rows):
        ids = ids_data[row_idx] if row_idx < len(ids_data) else {}
        fiscal = fiscal_data[row_idx] if row_idx < len(fiscal_data) else {}
        address = address_data[row_idx] if row_idx < len(address_data) else {}
        contact = contact_data[row_idx] if row_idx < len(contact_data) else {}
        order_ana = order_analytics[row_idx] if row_idx < len(order_analytics) else {}
        sales_ana = sales_analytics[row_idx] if row_idx < len(sales_analytics) else {}
        biz_info = business_info[row_idx] if row_idx < len(business_info) else {}
        int_acct = internal_account[row_idx] if row_idx < len(internal_account) else {}

        # Merge all 8 pages of data
        customer = ParsedCustomer(
            # Pages 0-3 (existing)
            customer_profile=ids.get('customer_profile', ''),
            name=ids.get('name', ''),
            vat_number=ids.get('vat_number'),
            pec=fiscal.get('pec'),
            sdi=fiscal.get('sdi'),
            fiscal_code=fiscal.get('fiscal_code'),
            delivery_terms=fiscal.get('delivery_terms'),
            street=address.get('street'),
            logistics_address=address.get('logistics_address'),
            postal_code=address.get('postal_code'),
            city=address.get('city'),
            phone=contact.get('phone'),
            mobile=contact.get('mobile'),
            url=contact.get('url'),
            attention_to=contact.get('attention_to'),
            last_order_date=contact.get('last_order_date'),
            # Pages 4-7 (NEW)
            actual_order_count=order_ana.get('actual_order_count'),
            customer_type=order_ana.get('customer_type'),
            previous_order_count_1=order_ana.get('previous_order_count_1'),
            previous_sales_1=sales_ana.get('previous_sales_1'),
            previous_order_count_2=sales_ana.get('previous_order_count_2'),
            previous_sales_2=sales_ana.get('previous_sales_2'),
            description=biz_info.get('description'),
            type=biz_info.get('type'),
            external_account_number=biz_info.get('external_account_number'),
            our_account_number=int_acct.get('our_account_number')
        )

        # Filter garbage: ID="0" and valid customer_profile required
        if customer.customer_profile and customer.customer_profile != "0":
            customers.append(customer)
```

**Critical:** Add garbage filter (`customer_profile != "0"`) to exclude 1,424 invalid records.
</task>

<task type="auto">
## 4. Update CSV output to include new fields

**File:** `scripts/parse-clienti-pdf.py`

In `main()` function, update CSV header (line 323):
```python
print('customer_profile,name,vat_number,pec,sdi,fiscal_code,delivery_terms,street,logistics_address,postal_code,city,phone,mobile,url,attention_to,last_order_date,actual_order_count,customer_type,previous_order_count_1,previous_sales_1,previous_order_count_2,previous_sales_2,description,type,external_account_number,our_account_number')
```

Update CSV row output (lines 327-347) to include new fields:
```python
row = [
    c.customer_profile,
    c.name,
    c.vat_number or '',
    c.pec or '',
    c.sdi or '',
    c.fiscal_code or '',
    c.delivery_terms or '',
    c.street or '',
    c.logistics_address or '',
    c.postal_code or '',
    c.city or '',
    c.phone or '',
    c.mobile or '',
    c.url or '',
    c.attention_to or '',
    c.last_order_date or '',
    # NEW FIELDS
    str(c.actual_order_count) if c.actual_order_count is not None else '',
    c.customer_type or '',
    str(c.previous_order_count_1) if c.previous_order_count_1 is not None else '',
    str(c.previous_sales_1) if c.previous_sales_1 is not None else '',
    str(c.previous_order_count_2) if c.previous_order_count_2 is not None else '',
    str(c.previous_sales_2) if c.previous_sales_2 is not None else '',
    c.description or '',
    c.type or '',
    c.external_account_number or '',
    c.our_account_number or ''
]
```
</task>

<task type="checkpoint:human-verify">
## 5. Test parser with real Clienti.pdf

**Validation:** Run parser with real PDF to verify 8-page cycle extraction works correctly.

```bash
cd /Users/hatholdir/Downloads/Archibald
python3 scripts/parse-clienti-pdf.py Clienti.pdf --output json > test-output.json
```

**Expected Results:**
- Total customers: ~1,515 (garbage filtered)
- Each customer has 27 fields populated (where data exists)
- No customers with `customer_profile = "0"`
- JSON structure matches updated ParsedCustomer

**Manual Verification:**
1. Check `test-output.json`: `jq '.total_customers' test-output.json` → should be ~1,515
2. Spot check fields from pages 4-7: `jq '.customers[0]' test-output.json | grep -E "actual_order_count|customer_type|previous_sales"`
3. Confirm garbage filtered: `jq '.customers[] | select(.customer_profile == "0")' test-output.json` → should be empty

If parser fails, debug page extraction logic and retry. If successful, proceed to Node.js wrapper.
</task>

<task type="auto">
## 6. Create Node.js wrapper for PDF parser

**New File:** `archibald-web-app/backend/src/pdf-parser-service.ts`

```typescript
import { exec } from 'child_process';
import { promisify } from 'util';
import { promises as fs } from 'fs';
import path from 'path';
import logger from './logger';

const execAsync = promisify(exec);

/**
 * Parsed customer from PDF (matches Python parser output)
 */
export interface ParsedCustomer {
  // Primary identification
  customer_profile: string;
  name: string;

  // Italian fiscal data
  vat_number?: string | null;
  fiscal_code?: string | null;
  sdi?: string | null;
  pec?: string | null;

  // Contact info
  phone?: string | null;
  mobile?: string | null;
  url?: string | null;
  attention_to?: string | null;

  // Address
  street?: string | null;
  logistics_address?: string | null;
  postal_code?: string | null;
  city?: string | null;

  // Business
  customer_type?: string | null;
  type?: string | null;
  delivery_terms?: string | null;
  description?: string | null;

  // Order history & analytics
  last_order_date?: string | null;
  actual_order_count?: number | null;
  previous_order_count_1?: number | null;
  previous_sales_1?: number | null;
  previous_order_count_2?: number | null;
  previous_sales_2?: number | null;

  // Account references
  external_account_number?: string | null;
  our_account_number?: string | null;
}

export interface PDFParseResult {
  total_customers: number;
  customers: ParsedCustomer[];
}

/**
 * Service for parsing customer PDF exports via Python script
 */
export class PDFParserService {
  private readonly parserPath: string;

  constructor() {
    // Path to parse-clienti-pdf.py from backend root
    this.parserPath = path.resolve(__dirname, '../../../scripts/parse-clienti-pdf.py');
  }

  /**
   * Parse customer PDF and return structured data
   * @param pdfPath Absolute path to PDF file
   * @returns Parsed customer data
   * @throws Error if Python not found, parser fails, or invalid output
   */
  async parsePDF(pdfPath: string): Promise<PDFParseResult> {
    const startTime = Date.now();

    try {
      // Verify PDF exists
      await fs.access(pdfPath);

      logger.info(`[PDFParser] Starting parse: ${pdfPath}`);

      // Execute Python parser
      const { stdout, stderr } = await execAsync(
        `python3 "${this.parserPath}" "${pdfPath}" --output json`,
        {
          maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large PDFs
          timeout: 30000 // 30s timeout
        }
      );

      // Log any warnings from stderr
      if (stderr) {
        logger.warn(`[PDFParser] Python stderr: ${stderr}`);
      }

      // Parse JSON output
      const result: PDFParseResult = JSON.parse(stdout);

      const duration = Date.now() - startTime;
      logger.info(`[PDFParser] Parsed ${result.total_customers} customers in ${duration}ms`);

      return result;

    } catch (error: any) {
      const duration = Date.now() - startTime;
      logger.error(`[PDFParser] Failed after ${duration}ms:`, error);

      // Enhance error messages
      if (error.code === 'ENOENT') {
        if (error.path?.includes('python')) {
          throw new Error('Python3 not found. Install Python 3.x and ensure it is in PATH.');
        } else {
          throw new Error(`PDF file not found: ${pdfPath}`);
        }
      }

      if (error.killed) {
        throw new Error('PDF parsing timeout (30s exceeded)');
      }

      throw new Error(`PDF parsing failed: ${error.message}`);
    }
  }

  /**
   * Health check: verify Python and PyPDF2 are available
   * @returns true if ready, false otherwise
   */
  async healthCheck(): Promise<boolean> {
    try {
      // Check Python3
      const { stdout: pythonVersion } = await execAsync('python3 --version');
      logger.info(`[PDFParser] Python version: ${pythonVersion.trim()}`);

      // Check PyPDF2
      const { stdout: pipList } = await execAsync('pip3 list | grep PyPDF2');
      if (!pipList.includes('PyPDF2')) {
        logger.error('[PDFParser] PyPDF2 not installed. Run: pip3 install PyPDF2');
        return false;
      }

      logger.info('[PDFParser] Health check passed');
      return true;

    } catch (error: any) {
      logger.error('[PDFParser] Health check failed:', error.message);
      return false;
    }
  }
}

// Singleton instance
export const pdfParserService = new PDFParserService();
```

**Key Features:**
- Type-safe interface matching Python parser output (27 fields)
- 10MB buffer for large PDFs
- 30s timeout protection
- Detailed error handling (Python not found, PyPDF2 missing, timeout, invalid JSON)
- Health check for deployment verification
- Structured logging with duration tracking
</task>

<task type="auto">
## 7. Add health check endpoint for parser validation

**File:** `archibald-web-app/backend/src/index.ts`

Add endpoint after existing routes:

```typescript
import { pdfParserService } from './pdf-parser-service';

// PDF Parser health check
app.get('/api/health/pdf-parser', async (req, res) => {
  try {
    const isHealthy = await pdfParserService.healthCheck();

    if (isHealthy) {
      res.json({
        status: 'ok',
        message: 'PDF parser ready (Python3 + PyPDF2 available)'
      });
    } else {
      res.status(503).json({
        status: 'error',
        message: 'PDF parser not ready. Check logs for details.'
      });
    }
  } catch (error: any) {
    res.status(500).json({
      status: 'error',
      message: error.message
    });
  }
});
```

This endpoint allows deployment verification and monitoring.
</task>

<task type="checkpoint:human-verify">
## 8. Integration test: Parse Clienti.pdf via Node.js

**Validation:** Test Node.js wrapper with real PDF to ensure integration works.

```bash
cd archibald-web-app/backend
npm run build
node -e "
const { pdfParserService } = require('./dist/pdf-parser-service');
pdfParserService.parsePDF('/Users/hatholdir/Downloads/Archibald/Clienti.pdf')
  .then(result => {
    console.log('Total customers:', result.total_customers);
    console.log('First customer:', JSON.stringify(result.customers[0], null, 2));
    console.log('Sample page 4-7 fields:', {
      actualOrderCount: result.customers[0].actual_order_count,
      customerType: result.customers[0].customer_type,
      previousSales1: result.customers[0].previous_sales_1,
      externalAccountNumber: result.customers[0].external_account_number
    });
  })
  .catch(err => console.error('Error:', err.message));
"
```

**Expected Output:**
- Total customers: ~1,515
- First customer has all 27 fields
- Pages 4-7 fields populated with valid data

**Also test health check:**
```bash
curl http://localhost:3000/api/health/pdf-parser
```

Should return `{ "status": "ok", "message": "..." }`.

If tests pass, Plan 18-01 is complete.
</task>
</tasks>

<verification>
## Success Criteria
- ✅ Parser extracts all 27 business fields from 8-page PDF cycles
- ✅ Garbage records filtered (ID="0" excluded)
- ✅ Real Clienti.pdf parsed successfully: ~1,515 valid customers
- ✅ Node.js wrapper functional with type-safe interface
- ✅ Health check endpoint confirms Python + PyPDF2 availability
- ✅ Integration test confirms end-to-end parsing works
- ✅ All TypeScript compiles without errors
- ✅ CSV output includes new fields for debugging

## Test Commands
```bash
# Python parser test
python3 scripts/parse-clienti-pdf.py Clienti.pdf --output json | jq '.total_customers'

# Node.js wrapper test
cd archibald-web-app/backend && npm run build
node -e "require('./dist/pdf-parser-service').pdfParserService.parsePDF('/path/to/Clienti.pdf').then(r => console.log('Customers:', r.total_customers))"

# Health check test
curl http://localhost:3000/api/health/pdf-parser
```

## Performance Target
- Parse 2,939 records in < 10s (Python execution)
- Node.js wrapper overhead < 1s
- Total: ~11s maximum for 8-page parsing
</verification>

<success_criteria>
Plan complete when:
1. Python parser handles 8-page cycles correctly
2. All 27 business fields extracted from PDF
3. Garbage filtering works (ID="0" excluded, ~1,515 valid customers)
4. Node.js wrapper integrates successfully
5. Health check endpoint deployed
6. Integration tests pass with real Clienti.pdf
7. Ready for Phase 18-02 (PDF bot download flow)
</success_criteria>

<output>
**Deliverables:**
1. Enhanced `scripts/parse-clienti-pdf.py` with 8-page cycle support
2. New `archibald-web-app/backend/src/pdf-parser-service.ts` wrapper
3. Health check endpoint `/api/health/pdf-parser`
4. Integration test validation with real PDF
5. Complete 27-field type definitions in TypeScript

**Files Modified:**
- `scripts/parse-clienti-pdf.py` (+150 lines - 4 new parser methods + 8-page cycle logic)

**Files Created:**
- `archibald-web-app/backend/src/pdf-parser-service.ts` (~180 lines)

**Next:** Plan 18-02 will implement bot flow for PDF download from Archibald.
</output>
