# Phase 18 Plan 04: Background Sync Scheduler & Monitoring

<objective>
Implementare il sistema di sync automatico ogni 30 minuti, con notifiche proattive all'utente (banner), monitoring dei tempi di esecuzione, e gestione errori con retry logic.
</objective>

<execution_context>
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/backend/src/index.ts
@.planning/phases/18.1-pdf-export-discovery-validation/DISCOVERY.md (¬ß7: Background Sync Strategy)
</execution_context>

<context>
## Current State
- ‚úÖ Plan 18-03 complete: Manual sync working with UI button
- ‚úÖ CustomerSyncService with progress callbacks
- ‚ùå No automatic background sync yet
- ‚ùå No sync monitoring/metrics

## Background Sync Requirements (from 18-CONTEXT.md)

### Frequency
**Initial: 30 minutes** (to be tuned based on production metrics)

Rationale:
- Customer data changes frequently (new customers, address updates)
- PDF sync is fast (15-20s) ‚Üí minimal resource impact
- Delta detection is efficient ‚Üí mostly no-ops on subsequent syncs

### User Experience
**Proactive Notification:**
- Banner appears: "‚è≥ Aggiornamento automatico clienti in corso..."
- Shows count: "1,234 / 1,515 clienti"
- Auto-hides on completion (no user action needed)
- Silent if no changes (delta = 0 updates)

**Silent Operation:**
- No interruption to user workflow
- Runs in background
- Only shows banner during active sync

### Monitoring
Track sync metrics for tuning:
- Sync duration (target: 15-20s)
- Error rate (target: < 5%)
- Delta stats (new/updated/unchanged per sync)
- Last successful sync timestamp

## Technical Approach
- **Scheduler**: setInterval with 30min (1,800,000ms) interval
- **Startup**: Initial sync after 5s delay (let server stabilize)
- **Retry Logic**: 3 retries with exponential backoff (5s, 10s, 20s)
- **Error Handling**: Log errors, alert if 3 consecutive failures
- **Monitoring**: Store sync metrics in memory (simple MVP, DB logging deferred)
</context>

<tasks>
<task type="auto">
## 1. Add background sync scheduler to CustomerSyncService

**File:** `archibald-web-app/backend/src/customer-sync-service.ts`

Add scheduler methods and metrics tracking:

```typescript
export interface SyncMetrics {
  lastSyncTime: Date | null;
  lastSyncResult: SyncResult | null;
  totalSyncs: number;
  consecutiveFailures: number;
  averageDuration: number;
}

export class CustomerSyncService {
  private syncInProgress = false;
  private lastSyncTime: Date | null = null;
  private syncInterval: NodeJS.Timeout | null = null;

  // Metrics tracking
  private metrics: SyncMetrics = {
    lastSyncTime: null,
    lastSyncResult: null,
    totalSyncs: 0,
    consecutiveFailures: 0,
    averageDuration: 0
  };

  // ... existing syncCustomers() method ...

  /**
   * Start automatic background sync
   * @param intervalMinutes Sync frequency in minutes (default: 30)
   */
  startAutoSync(intervalMinutes: number = 30): void {
    if (this.syncInterval) {
      logger.warn('[CustomerSync] Auto-sync already running');
      return;
    }

    const intervalMs = intervalMinutes * 60 * 1000;
    logger.info(`[CustomerSync] Starting auto-sync every ${intervalMinutes} minutes`);

    // Initial sync after 5s (let server stabilize)
    setTimeout(() => {
      this.runBackgroundSync();
    }, 5000);

    // Recurring sync
    this.syncInterval = setInterval(() => {
      this.runBackgroundSync();
    }, intervalMs);

    logger.info('[CustomerSync] Auto-sync scheduler started');
  }

  /**
   * Stop automatic background sync
   */
  stopAutoSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
      logger.info('[CustomerSync] Auto-sync scheduler stopped');
    }
  }

  /**
   * Run background sync with retry logic
   * @private
   */
  private async runBackgroundSync(): Promise<void> {
    const maxRetries = 3;
    let attempt = 0;

    while (attempt < maxRetries) {
      try {
        logger.info(`[CustomerSync] Background sync attempt ${attempt + 1}/${maxRetries}`);

        const result = await this.syncCustomers();

        // Update metrics
        this.updateMetrics(result);

        if (result.success) {
          logger.info('[CustomerSync] Background sync successful:', {
            new: result.newCustomers,
            updated: result.updatedCustomers,
            duration: result.duration
          });

          // Reset failure counter on success
          this.metrics.consecutiveFailures = 0;
          return;
        } else {
          throw new Error(result.error || 'Sync failed');
        }

      } catch (error: any) {
        attempt++;
        logger.error(`[CustomerSync] Background sync failed (attempt ${attempt}):`, error);

        if (attempt < maxRetries) {
          // Exponential backoff: 5s, 10s, 20s
          const delayMs = 5000 * Math.pow(2, attempt - 1);
          logger.info(`[CustomerSync] Retrying in ${delayMs / 1000}s...`);
          await new Promise(resolve => setTimeout(resolve, delayMs));
        } else {
          // All retries exhausted
          logger.error('[CustomerSync] All retries exhausted, giving up');
          this.metrics.consecutiveFailures++;

          // Alert if 3 consecutive background syncs failed
          if (this.metrics.consecutiveFailures >= 3) {
            logger.error('üö® [CustomerSync] ALERT: 3 consecutive sync failures detected!');
            // TODO: Send alert (email, Slack, etc.) - deferred to Phase 25
          }
        }
      }
    }
  }

  /**
   * Update sync metrics
   * @private
   */
  private updateMetrics(result: SyncResult): void {
    this.metrics.lastSyncTime = new Date();
    this.metrics.lastSyncResult = result;
    this.metrics.totalSyncs++;

    // Update average duration (rolling average)
    if (this.metrics.averageDuration === 0) {
      this.metrics.averageDuration = result.duration;
    } else {
      this.metrics.averageDuration =
        (this.metrics.averageDuration * (this.metrics.totalSyncs - 1) + result.duration) /
        this.metrics.totalSyncs;
    }
  }

  /**
   * Get sync metrics (for monitoring endpoint)
   */
  getMetrics(): SyncMetrics {
    return { ...this.metrics };
  }

  // ... existing methods (getLastSyncTime, isSyncInProgress) ...
}
```

**Key Features:**
- 30-minute interval (configurable)
- Initial sync after 5s delay
- 3 retries with exponential backoff (5s, 10s, 20s)
- Consecutive failure tracking ‚Üí alert after 3 failures
- Metrics tracking (total syncs, average duration)
</task>

<task type="auto">
## 2. Auto-start background sync on server startup

**File:** `archibald-web-app/backend/src/index.ts`

Add auto-start after server initialization:

```typescript
import { customerSyncService } from './customer-sync-service';

// After Fastify server setup, before listen():

// Start background customer sync (30 min interval)
customerSyncService.startAutoSync(30);
logger.info('Background customer sync scheduler started');

// Graceful shutdown
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, stopping background sync...');
  customerSyncService.stopAutoSync();
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, stopping background sync...');
  customerSyncService.stopAutoSync();
  process.exit(0);
});

// Start server
app.listen({ port: 3000, host: '0.0.0.0' }, (err, address) => {
  if (err) {
    logger.error(err);
    process.exit(1);
  }
  logger.info(`Server listening at ${address}`);
});
```

**Features:**
- Auto-starts on server boot
- Graceful shutdown on SIGTERM/SIGINT
- Logs startup confirmation
</task>

<task type="auto">
## 3. Add monitoring endpoint for sync metrics

**File:** `archibald-web-app/backend/src/index.ts`

Add endpoint after existing sync endpoints:

```typescript
/**
 * Get sync metrics (monitoring)
 * GET /api/customers/sync/metrics
 * Returns: sync statistics for monitoring
 */
app.get('/api/customers/sync/metrics', (req, res) => {
  const metrics = customerSyncService.getMetrics();

  res.json({
    lastSyncTime: metrics.lastSyncTime?.toISOString() || null,
    lastResult: metrics.lastSyncResult ? {
      success: metrics.lastSyncResult.success,
      customersProcessed: metrics.lastSyncResult.customersProcessed,
      newCustomers: metrics.lastSyncResult.newCustomers,
      updatedCustomers: metrics.lastSyncResult.updatedCustomers,
      duration: metrics.lastSyncResult.duration,
      error: metrics.lastSyncResult.error
    } : null,
    totalSyncs: metrics.totalSyncs,
    consecutiveFailures: metrics.consecutiveFailures,
    averageDuration: Math.round(metrics.averageDuration),
    health: metrics.consecutiveFailures < 3 ? 'healthy' : 'degraded'
  });
});
```

**Metrics Provided:**
- Last sync time & result
- Total syncs count
- Consecutive failures (alert indicator)
- Average duration (performance tracking)
- Health status (healthy/degraded)
</task>

<task type="auto">
## 4. Add background sync notifications to frontend

**File:** `archibald-web-app/frontend/src/App.tsx` (or global layout component)

Add polling to detect background sync and show banner:

```typescript
import React, { useState, useEffect } from 'react';
import { SyncBanner, SyncStatus } from './components/SyncBanner';
import { getCustomerSyncStatus, SyncStatus as SyncStatusAPI } from './api/customers';

// Inside App component:
const [backgroundSyncActive, setBackgroundSyncActive] = useState(false);
const [lastSyncCheck, setLastSyncCheck] = useState<Date | null>(null);

// Poll sync status every 5 seconds
useEffect(() => {
  const pollInterval = setInterval(async () => {
    try {
      const status: SyncStatusAPI = await getCustomerSyncStatus();

      // Detect sync start
      if (status.inProgress && !backgroundSyncActive) {
        setBackgroundSyncActive(true);
      }

      // Detect sync completion
      if (!status.inProgress && backgroundSyncActive) {
        setBackgroundSyncActive(false);
        // Could show success banner briefly, but keeping it silent for background
      }

      setLastSyncCheck(new Date());

    } catch (error) {
      console.error('Failed to check sync status:', error);
    }
  }, 5000); // 5s polling

  return () => clearInterval(pollInterval);
}, [backgroundSyncActive]);

// In JSX (global layout):
return (
  <div>
    {/* Background Sync Banner (non-intrusive) */}
    {backgroundSyncActive && (
      <SyncBanner
        status="syncing"
        message="Aggiornamento automatico clienti in corso..."
      />
    )}

    {/* App content */}
    {children}
  </div>
);
```

**Alternative: Silent Background (No Banner)**
If banner is too intrusive, can make background syncs completely silent:
- No banner during sync
- Only log in browser console
- User sees updated data on next page refresh

**Decision:** Start with banner (transparent), can disable later based on feedback.
</task>

<task type="checkpoint:human-verify">
## 5. Test background sync scheduler

**Validation:** Verify background sync runs automatically on schedule.

**Test Steps:**

1. **Start server and observe initial sync:**
```bash
cd archibald-web-app/backend
npm start
# Watch logs for:
# "[CustomerSync] Starting auto-sync every 30 minutes"
# ... wait 5s ...
# "[CustomerSync] Background sync attempt 1/3"
# "[CustomerSync] Background sync successful: { new: X, updated: Y, duration: 15000 }"
```

2. **Check metrics endpoint:**
```bash
curl http://localhost:3000/api/customers/sync/metrics | jq
# Expected:
# {
#   "lastSyncTime": "2026-01-19T...",
#   "lastResult": { "success": true, "customersProcessed": 1515, ... },
#   "totalSyncs": 1,
#   "consecutiveFailures": 0,
#   "averageDuration": 16000,
#   "health": "healthy"
# }
```

3. **Wait for next sync (30 minutes):**
- Set interval to 1 minute for testing: `startAutoSync(1)`
- Watch logs for recurring sync every 60s
- Verify metrics increment: `totalSyncs: 2, 3, 4...`

4. **Test retry logic (simulate failure):**
- Temporarily break bot credentials
- Watch logs for 3 retry attempts with exponential backoff
- Verify alert after 3 consecutive failures

5. **Test graceful shutdown:**
```bash
# Send SIGTERM
kill -TERM <pid>
# Watch logs for:
# "SIGTERM received, stopping background sync..."
# "[CustomerSync] Auto-sync scheduler stopped"
```

If all tests pass, scheduler is working correctly.
</task>

<task type="auto">
## 6. Add admin endpoint to control sync frequency

**File:** `archibald-web-app/backend/src/index.ts`

Add endpoint for dynamic frequency adjustment (future-proof):

```typescript
/**
 * Update sync frequency (admin)
 * POST /api/admin/sync/frequency
 * Body: { intervalMinutes: number }
 */
app.post('/api/admin/sync/frequency', (req, res) => {
  // TODO: Add authentication in Phase 26 (admin routes)

  const { intervalMinutes } = req.body;

  if (!intervalMinutes || intervalMinutes < 5 || intervalMinutes > 1440) {
    return res.status(400).json({
      error: 'Invalid interval',
      message: 'Interval must be between 5 and 1440 minutes (1 day)'
    });
  }

  // Restart scheduler with new interval
  customerSyncService.stopAutoSync();
  customerSyncService.startAutoSync(intervalMinutes);

  logger.info(`[CustomerSync] Frequency updated to ${intervalMinutes} minutes`);

  res.json({
    success: true,
    intervalMinutes,
    message: `Sync frequency updated to ${intervalMinutes} minutes`
  });
});
```

**Future Use:**
- Admin panel to adjust frequency (Phase 25)
- A/B testing different intervals
- Performance tuning based on production load
</task>

<task type="auto">
## 7. Document sync behavior in README

**File:** `archibald-web-app/README.md`

Add section on background sync:

```markdown
## Background Customer Sync

The system automatically syncs customer data from Archibald every **30 minutes** in the background.

### Sync Behavior
- **Initial sync**: 5 seconds after server start
- **Recurring sync**: Every 30 minutes
- **Duration**: ~15-20 seconds per sync
- **Retry logic**: 3 attempts with exponential backoff (5s, 10s, 20s)
- **Alert threshold**: 3 consecutive failures

### Manual Sync
Users can trigger manual sync anytime via "üîÑ Aggiorna Clienti" button in the Clienti page.

### Monitoring
- **Metrics endpoint**: `GET /api/customers/sync/metrics`
- **Status endpoint**: `GET /api/customers/sync/status`
- **Health indicator**: `"healthy"` if < 3 consecutive failures, `"degraded"` otherwise

### Configuration
Default interval: 30 minutes (configurable via `startAutoSync(intervalMinutes)`)

To adjust frequency (admin):
```bash
curl -X POST http://localhost:3000/api/admin/sync/frequency \
  -H "Content-Type: application/json" \
  -d '{"intervalMinutes": 15}'
```

### Performance Targets
- Sync duration: < 20s (target: 15-20s)
- Error rate: < 5%
- Delta efficiency: > 95% unchanged records skipped

### Troubleshooting
If sync fails repeatedly:
1. Check bot credentials: `curl http://localhost:3000/api/health/pdf-parser`
2. Check Python/PyPDF2 installation: `python3 --version && pip3 list | grep PyPDF2`
3. Check disk space for /tmp PDFs: `df -h /tmp`
4. Review logs: `tail -f logs/backend.log | grep CustomerSync`
```
</task>
</tasks>

<verification>
## Success Criteria
- ‚úÖ Background sync scheduler starts automatically on server boot
- ‚úÖ Initial sync runs 5s after startup
- ‚úÖ Recurring sync every 30 minutes
- ‚úÖ Retry logic works (3 attempts with exponential backoff)
- ‚úÖ Alert logged after 3 consecutive failures
- ‚úÖ Graceful shutdown stops scheduler
- ‚úÖ Metrics endpoint returns sync statistics
- ‚úÖ Frontend polling detects background sync (optional banner)
- ‚úÖ Admin endpoint adjusts frequency dynamically
- ‚úÖ Documentation complete

## Test Commands
```bash
# Check metrics after server start
curl http://localhost:3000/api/customers/sync/metrics | jq

# Monitor sync in logs
tail -f logs/backend.log | grep CustomerSync

# Test frequency adjustment
curl -X POST http://localhost:3000/api/admin/sync/frequency \
  -H "Content-Type: application/json" \
  -d '{"intervalMinutes": 1}'  # 1min for testing

# Graceful shutdown test
kill -TERM <pid>
```

## Performance Validation
- Initial sync: 15-20s ‚úÖ
- Recurring syncs: 15-20s (delta optimized) ‚úÖ
- Retry delays: 5s, 10s, 20s ‚úÖ
- Memory stable: No leaks after 100+ syncs
- CPU usage: < 5% during sync
</verification>

<success_criteria>
Plan complete when:
1. Background scheduler working automatically
2. Initial sync + recurring syncs functional
3. Retry logic handles failures gracefully
4. Metrics tracking all sync operations
5. Monitoring endpoint provides health status
6. Frontend can detect background sync (optional banner)
7. Admin endpoint allows frequency tuning
8. Documentation complete
9. Ready for Phase 18-05 (final validation & testing)
</success_criteria>

<output>
**Deliverables:**
1. Background sync scheduler with 30min interval
2. Retry logic with exponential backoff (3 attempts)
3. Metrics tracking (duration, failures, averages)
4. Monitoring endpoint for health checks
5. Frontend polling for background sync detection
6. Admin endpoint for frequency adjustment
7. Complete documentation

**Files Modified:**
- `archibald-web-app/backend/src/customer-sync-service.ts` (+120 lines - scheduler + metrics)
- `archibald-web-app/backend/src/index.ts` (+60 lines - auto-start + endpoints + shutdown)
- `archibald-web-app/frontend/src/App.tsx` (+30 lines - background sync detection)
- `archibald-web-app/README.md` (+40 lines - sync documentation)

**Metrics Tracked:**
- Last sync time & result
- Total syncs count
- Consecutive failures (alert at 3)
- Average duration (performance trend)
- Health status (healthy/degraded)

**Monitoring:**
- GET /api/customers/sync/metrics ‚Üí full statistics
- GET /api/customers/sync/status ‚Üí in-progress check
- Logs: `[CustomerSync]` prefix for filtering

**Next:** Plan 18-05 will perform comprehensive testing and validation.
</output>
