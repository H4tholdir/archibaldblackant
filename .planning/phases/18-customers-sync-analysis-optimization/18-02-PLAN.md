# Phase 18 Plan 02: PDF Download Bot Flow

<objective>
Implementare il flusso bot per scaricare il PDF export dei clienti da Archibald: login ‚Üí navigazione sezione Clienti ‚Üí download PDF ‚Üí salvataggio temporaneo ‚Üí cleanup.
</objective>

<execution_context>
@archibald-web-app/backend/src/archibald-bot.ts
@archibald-web-app/backend/src/customer-sync-service.ts
@.planning/phases/18.1-pdf-export-discovery-validation/DISCOVERY.md (¬ß6: Sync Flow Design)
</execution_context>

<context>
## Current State
- ‚úÖ Plan 18-01 complete: Parser handles 8-page cycles, Node.js wrapper ready
- ‚úÖ Existing bot infrastructure: ArchibaldBot with login, navigation, download capabilities
- ‚ùå No PDF download implementation for Clienti section yet

## Bot Flow Design
```
1. Bot Login (3-5s) - reuse existing context acquisition
2. Navigate to Clienti page (1-2s) - click menu, wait for load
3. Download PDF export (2-3s) - trigger download, save to /tmp
4. Return file path
5. Cleanup handled by caller (after parsing)
```

## Technical Approach
- **Download Method**: Puppeteer CDP (Chrome DevTools Protocol) for download interception
- **Temp Storage**: `/tmp/clienti-{timestamp}-{userId}.pdf` for isolation
- **Timeout**: 30s max for entire flow (login + download)
- **Error Handling**: Retry 3x on failures, detailed logging

## Integration Pattern
CustomerSyncService will orchestrate: bot download ‚Üí parser ‚Üí DB update.
</context>

<tasks>
<task type="auto">
## 1. Add downloadCustomersPDF method to ArchibaldBot

**File:** `archibald-web-app/backend/src/archibald-bot.ts`

Add new method after existing methods:

```typescript
/**
 * Download Clienti PDF export from Archibald
 * @param context Existing browser context (must be logged in)
 * @returns Absolute path to downloaded PDF file
 * @throws Error if navigation fails, download times out, or file not found
 */
async downloadCustomersPDF(context: BrowserContext): Promise<string> {
  const page = context.pages()[0];
  const startTime = Date.now();

  try {
    logger.info('[ArchibaldBot] Starting Clienti PDF download');

    // 1. Navigate to Clienti page via menu
    await page.click('a[href*="Clienti"]', { timeout: 5000 });
    await page.waitForLoadState('networkidle', { timeout: 10000 });
    logger.info('[ArchibaldBot] Navigated to Clienti page');

    // 2. Setup download handling
    const timestamp = Date.now();
    const userId = this.credentials?.username || 'unknown';
    const downloadPath = `/tmp/clienti-${timestamp}-${userId}.pdf`;

    // Wait for download event
    const downloadPromise = page.waitForEvent('download', { timeout: 15000 });

    // 3. Trigger PDF export
    // Look for export button (text-based selector for stability)
    const exportButton = await page.locator('text=/Esporta.*PDF/i').first();

    if (!await exportButton.isVisible({ timeout: 5000 })) {
      throw new Error('PDF export button not found on Clienti page');
    }

    await exportButton.click();
    logger.info('[ArchibaldBot] Clicked PDF export button');

    // 4. Wait for download to complete
    const download = await downloadPromise;
    await download.saveAs(downloadPath);

    const duration = Date.now() - startTime;
    logger.info(`[ArchibaldBot] PDF downloaded to ${downloadPath} in ${duration}ms`);

    // 5. Verify file exists and has content
    const fs = require('fs');
    const stats = fs.statSync(downloadPath);

    if (stats.size === 0) {
      throw new Error('Downloaded PDF is empty (0 bytes)');
    }

    logger.info(`[ArchibaldBot] PDF file size: ${(stats.size / 1024).toFixed(2)} KB`);

    return downloadPath;

  } catch (error: any) {
    const duration = Date.now() - startTime;
    logger.error(`[ArchibaldBot] PDF download failed after ${duration}ms:`, error);

    // Enhance error messages
    if (error.message?.includes('timeout')) {
      throw new Error('PDF download timeout (15s exceeded). Archibald may be slow or button selector changed.');
    }

    throw new Error(`PDF download failed: ${error.message}`);
  }
}
```

**Key Design Decisions:**
- Uses `text=/Esporta.*PDF/i` selector (stable, text-based)
- Downloads to `/tmp` with timestamp + userId for uniqueness
- Validates file size (prevents empty downloads)
- 15s timeout for download (generous for large PDFs)
- Comprehensive logging with duration tracking
</task>

<task type="auto">
## 2. Create CustomerSyncService with PDF-based sync

**File:** `archibald-web-app/backend/src/customer-sync-service.ts`

**Action:** Replace existing HTML scraping implementation with PDF-based approach.

**IMPORTANT:** Backup old implementation first:
```bash
cp archibald-web-app/backend/src/customer-sync-service.ts archibald-web-app/backend/src/customer-sync-service.OLD_HTML_SCRAPING.ts.backup
```

**New Implementation:**

```typescript
import { ArchibaldBot } from './archibald-bot';
import { customerDb, Customer } from './customer-db';
import { pdfParserService, ParsedCustomer } from './pdf-parser-service';
import { queueManager } from './queue-manager';
import logger from './logger';
import * as fs from 'fs';
import * as crypto from 'crypto';

export interface SyncProgress {
  stage: string;
  current: number;
  total: number;
  message: string;
}

export type ProgressCallback = (progress: SyncProgress) => void;

export interface SyncResult {
  success: boolean;
  customersProcessed: number;
  newCustomers: number;
  updatedCustomers: number;
  deletedCustomers: number;
  duration: number;
  error?: string;
}

/**
 * Service for syncing customers from Archibald PDF export
 * Replaces old HTML scraping approach with faster, more stable PDF parsing
 */
export class CustomerSyncService {
  private syncInProgress = false;
  private lastSyncTime: Date | null = null;

  /**
   * Sync customers from Archibald PDF export
   * @param progressCallback Optional callback for progress updates
   * @returns Sync result summary
   */
  async syncCustomers(progressCallback?: ProgressCallback): Promise<SyncResult> {
    // Prevent concurrent syncs
    if (this.syncInProgress) {
      logger.warn('[CustomerSync] Sync already in progress, skipping');
      throw new Error('Customer sync already in progress');
    }

    this.syncInProgress = true;
    const startTime = Date.now();
    let pdfPath: string | null = null;

    try {
      logger.info('[CustomerSync] Starting PDF-based customer sync');

      // Stage 1: Acquire bot context
      progressCallback?.({
        stage: 'login',
        current: 0,
        total: 5,
        message: 'Connessione ad Archibald...'
      });

      const bot = queueManager['bot']; // Access bot from queue manager
      const context = await bot.acquireContext();

      // Stage 2: Download PDF
      progressCallback?.({
        stage: 'download',
        current: 1,
        total: 5,
        message: 'Scaricamento PDF clienti...'
      });

      pdfPath = await bot.downloadCustomersPDF(context);
      logger.info(`[CustomerSync] PDF downloaded: ${pdfPath}`);

      // Stage 3: Parse PDF
      progressCallback?.({
        stage: 'parse',
        current: 2,
        total: 5,
        message: 'Analisi PDF in corso...'
      });

      const parseResult = await pdfParserService.parsePDF(pdfPath);
      logger.info(`[CustomerSync] Parsed ${parseResult.total_customers} customers from PDF`);

      // Stage 4: Delta detection & DB update
      progressCallback?.({
        stage: 'update',
        current: 3,
        total: 5,
        message: `Aggiornamento ${parseResult.total_customers} clienti...`
      });

      const deltaResult = await this.applyDelta(parseResult.customers);

      // Stage 5: Cleanup
      progressCallback?.({
        stage: 'cleanup',
        current: 4,
        total: 5,
        message: 'Finalizzazione...'
      });

      if (pdfPath) {
        fs.unlinkSync(pdfPath);
        logger.info(`[CustomerSync] Cleaned up temp PDF: ${pdfPath}`);
      }

      this.lastSyncTime = new Date();

      const duration = Date.now() - startTime;
      const result: SyncResult = {
        success: true,
        customersProcessed: parseResult.total_customers,
        newCustomers: deltaResult.inserted,
        updatedCustomers: deltaResult.updated,
        deletedCustomers: 0, // MVP: no deletions yet
        duration
      };

      logger.info(`[CustomerSync] Completed in ${duration}ms:`, result);

      progressCallback?.({
        stage: 'complete',
        current: 5,
        total: 5,
        message: `Completato: ${result.newCustomers} nuovi, ${result.updatedCustomers} aggiornati`
      });

      return result;

    } catch (error: any) {
      const duration = Date.now() - startTime;
      logger.error(`[CustomerSync] Failed after ${duration}ms:`, error);

      // Cleanup temp file on error
      if (pdfPath && fs.existsSync(pdfPath)) {
        fs.unlinkSync(pdfPath);
      }

      return {
        success: false,
        customersProcessed: 0,
        newCustomers: 0,
        updatedCustomers: 0,
        deletedCustomers: 0,
        duration,
        error: error.message
      };

    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Apply delta changes to database (insert new, update changed)
   * @param pdfCustomers Customers from PDF parser
   * @returns Stats: inserted, updated, skipped
   */
  private async applyDelta(pdfCustomers: ParsedCustomer[]): Promise<{
    inserted: number;
    updated: number;
    skipped: number;
  }> {
    let inserted = 0;
    let updated = 0;
    let skipped = 0;

    for (const pdfCustomer of pdfCustomers) {
      try {
        // Compute hash for delta detection (all PDF fields)
        const hash = this.computeHash(pdfCustomer);

        // Check if customer exists
        const existing = await customerDb.getCustomer(pdfCustomer.customer_profile);

        if (!existing) {
          // New customer: INSERT
          await customerDb.createCustomer(this.mapPDFToCustomer(pdfCustomer, hash));
          inserted++;
        } else if (existing.hash !== hash) {
          // Changed customer: UPDATE
          await customerDb.updateCustomer(
            pdfCustomer.customer_profile,
            this.mapPDFToCustomer(pdfCustomer, hash)
          );
          updated++;
        } else {
          // Unchanged: SKIP
          skipped++;
        }

      } catch (error: any) {
        logger.error(`[CustomerSync] Failed to process customer ${pdfCustomer.customer_profile}:`, error);
        // Continue with other customers
      }
    }

    logger.info(`[CustomerSync] Delta: ${inserted} inserted, ${updated} updated, ${skipped} skipped`);

    return { inserted, updated, skipped };
  }

  /**
   * Compute hash from all PDF fields for delta detection
   * @param customer Parsed customer from PDF
   * @returns MD5 hash hex string
   */
  private computeHash(customer: ParsedCustomer): string {
    // Include all 27 business fields in deterministic order (pages 0-7)
    const hashFields = [
      // Page 0: Identification
      customer.customer_profile,
      customer.name,
      customer.vat_number || '',
      // Page 1: Fiscal & Delivery
      customer.pec || '',
      customer.sdi || '',
      customer.fiscal_code || '',
      customer.delivery_terms || '',
      // Page 2: Address
      customer.street || '',
      customer.logistics_address || '',
      customer.postal_code || '',
      customer.city || '',
      // Page 3: Contact & Last Order
      customer.phone || '',
      customer.mobile || '',
      customer.url || '',
      customer.attention_to || '',
      customer.last_order_date || '',
      // Page 4: Order Analytics
      String(customer.actual_order_count ?? ''),
      customer.customer_type || '',
      String(customer.previous_order_count_1 ?? ''),
      // Page 5: Sales Analytics
      String(customer.previous_sales_1 ?? ''),
      String(customer.previous_order_count_2 ?? ''),
      String(customer.previous_sales_2 ?? ''),
      // Page 6: Business Info
      customer.description || '',
      customer.type || '',
      customer.external_account_number || '',
      // Page 7: Internal Account
      customer.our_account_number || ''
    ];

    const data = hashFields.join('|');
    return crypto.createHash('md5').update(data).digest('hex');
  }

  /**
   * Map ParsedCustomer to Customer schema
   * @param pdf Parsed customer from PDF
   * @param hash Computed hash
   * @returns Customer object for DB
   */
  private mapPDFToCustomer(pdf: ParsedCustomer, hash: string): Partial<Customer> {
    const now = new Date().toISOString();

    return {
      customerProfile: pdf.customer_profile,
      name: pdf.name,
      vatNumber: pdf.vat_number || undefined,
      fiscalCode: pdf.fiscal_code || undefined,
      sdi: pdf.sdi || undefined,
      pec: pdf.pec || undefined,
      phone: pdf.phone || undefined,
      mobile: pdf.mobile || undefined,
      url: pdf.url || undefined,
      attentionTo: pdf.attention_to || undefined,
      street: pdf.street || undefined,
      logisticsAddress: pdf.logistics_address || undefined,
      postalCode: pdf.postal_code || undefined,
      city: pdf.city || undefined,
      customerType: pdf.customer_type || undefined,
      type: pdf.type || undefined,
      deliveryTerms: pdf.delivery_terms || undefined,
      description: pdf.description || undefined,
      lastOrderDate: pdf.last_order_date || undefined,
      actualOrderCount: pdf.actual_order_count ?? undefined,
      previousOrderCount1: pdf.previous_order_count_1 ?? undefined,
      previousSales1: pdf.previous_sales_1 ?? undefined,
      previousOrderCount2: pdf.previous_order_count_2 ?? undefined,
      previousSales2: pdf.previous_sales_2 ?? undefined,
      externalAccountNumber: pdf.external_account_number || undefined,
      ourAccountNumber: pdf.our_account_number || undefined,
      hash,
      lastSync: now,
      updatedAt: now
      // createdAt handled by DB if new record
    };
  }

  /**
   * Get last sync timestamp
   */
  getLastSyncTime(): Date | null {
    return this.lastSyncTime;
  }

  /**
   * Check if sync is currently running
   */
  isSyncInProgress(): boolean {
    return this.syncInProgress;
  }
}

// Singleton instance
export const customerSyncService = new CustomerSyncService();
```

**Key Features:**
- Replaces HTML scraping with PDF-based sync (~50-67% faster)
- Hash-based delta detection (all 27 fields)
- Progress callbacks for UI updates (5 stages)
- Comprehensive error handling and logging
- Temp file cleanup (on success and error)
- Singleton pattern for app-wide use
</task>

<task type="auto">
## 3. Update customer-db schema to include new fields

**File:** `archibald-web-app/backend/src/customer-db.ts`

Verify schema includes all 27 PDF fields + 4 system fields (30 total).

**Add missing fields if not present:**

```typescript
export interface Customer {
  // Primary identification (existing)
  customerProfile: string;
  name: string;

  // Italian fiscal data (existing)
  vatNumber?: string;
  fiscalCode?: string;
  sdi?: string;
  pec?: string;

  // Contact (existing)
  phone?: string;
  mobile?: string;
  url?: string;
  attentionTo?: string;

  // Address (existing)
  street?: string;
  logisticsAddress?: string;
  postalCode?: string;
  city?: string;

  // Business (existing + NEW)
  customerType?: string;  // NEW: Page 4
  type?: string;  // NEW: Page 6
  deliveryTerms?: string;
  description?: string;  // NEW: Page 6

  // Order history & analytics (existing + NEW)
  lastOrderDate?: string;
  actualOrderCount?: number;  // NEW: Page 4
  previousOrderCount1?: number;  // NEW: Page 4
  previousSales1?: number;  // NEW: Page 5
  previousOrderCount2?: number;  // NEW: Page 5
  previousSales2?: number;  // NEW: Page 5

  // Account references (NEW)
  externalAccountNumber?: string;  // NEW: Page 6
  ourAccountNumber?: string;  // NEW: Page 7

  // System fields (existing)
  hash?: string;  // For delta detection
  lastSync?: string;  // ISO timestamp of last sync
  createdAt?: string;
  updatedAt?: string;
}
```

Update DB schema migration if needed (add columns for new fields).

**CREATE TABLE statement should include:**
```sql
CREATE TABLE IF NOT EXISTS customers (
  customerProfile TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  vatNumber TEXT,
  fiscalCode TEXT,
  sdi TEXT,
  pec TEXT,
  phone TEXT,
  mobile TEXT,
  url TEXT,
  attentionTo TEXT,
  street TEXT,
  logisticsAddress TEXT,
  postalCode TEXT,
  city TEXT,
  customerType TEXT,  -- NEW
  type TEXT,  -- NEW
  deliveryTerms TEXT,
  description TEXT,  -- NEW
  lastOrderDate TEXT,
  actualOrderCount INTEGER,  -- NEW
  previousOrderCount1 INTEGER,  -- NEW
  previousSales1 REAL,  -- NEW
  previousOrderCount2 INTEGER,  -- NEW
  previousSales2 REAL,  -- NEW
  externalAccountNumber TEXT,  -- NEW
  ourAccountNumber TEXT,  -- NEW
  hash TEXT,
  lastSync TEXT,
  createdAt TEXT DEFAULT (datetime('now')),
  updatedAt TEXT DEFAULT (datetime('now'))
);
```

**Migration:** If columns don't exist, add via ALTER TABLE:
```sql
ALTER TABLE customers ADD COLUMN customerType TEXT;
ALTER TABLE customers ADD COLUMN type TEXT;
ALTER TABLE customers ADD COLUMN description TEXT;
-- ... etc for all new fields
```
</task>

<task type="checkpoint:human-verify">
## 4. Test PDF download bot flow manually

**Validation:** Run bot manually to verify PDF download works end-to-end.

**Test Script:** Create `test-pdf-download.ts`:

```typescript
import { queueManager } from './queue-manager';
import logger from './logger';

async function testPDFDownload() {
  try {
    logger.info('Starting PDF download test...');

    const bot = queueManager['bot'];
    const context = await bot.acquireContext();

    const pdfPath = await bot.downloadCustomersPDF(context);
    logger.info(`‚úÖ PDF downloaded: ${pdfPath}`);

    // Verify file
    const fs = require('fs');
    const stats = fs.statSync(pdfPath);
    logger.info(`‚úÖ PDF size: ${(stats.size / 1024).toFixed(2)} KB`);

    // Cleanup
    fs.unlinkSync(pdfPath);
    logger.info('‚úÖ Temp file cleaned up');

    logger.info('üéâ Test passed!');
    process.exit(0);

  } catch (error: any) {
    logger.error('‚ùå Test failed:', error);
    process.exit(1);
  }
}

testPDFDownload();
```

**Run test:**
```bash
cd archibald-web-app/backend
npm run build
node dist/test-pdf-download.js
```

**Expected Output:**
- `‚úÖ PDF downloaded: /tmp/clienti-{timestamp}-{userId}.pdf`
- `‚úÖ PDF size: ~1200 KB`
- `‚úÖ Temp file cleaned up`
- `üéâ Test passed!`

If test fails, check:
1. Bot login credentials valid
2. Archibald Clienti page accessible
3. Export button selector correct
4. Download timeout sufficient

Adjust selectors or timeouts if needed, then retest.
</task>

<task type="checkpoint:human-verify">
## 5. Integration test: Full sync flow (download ‚Üí parse ‚Üí DB)

**Validation:** Test complete sync pipeline end-to-end.

**Test Script:** Create `test-full-sync.ts`:

```typescript
import { customerSyncService } from './customer-sync-service';
import logger from './logger';

async function testFullSync() {
  try {
    logger.info('Starting full sync test...');

    const result = await customerSyncService.syncCustomers((progress) => {
      logger.info(`[Progress] ${progress.stage}: ${progress.message}`);
    });

    if (result.success) {
      logger.info('‚úÖ Sync successful:', result);
      logger.info(`  - Processed: ${result.customersProcessed}`);
      logger.info(`  - New: ${result.newCustomers}`);
      logger.info(`  - Updated: ${result.updatedCustomers}`);
      logger.info(`  - Duration: ${result.duration}ms`);
      logger.info('üéâ Test passed!');
      process.exit(0);
    } else {
      logger.error('‚ùå Sync failed:', result.error);
      process.exit(1);
    }

  } catch (error: any) {
    logger.error('‚ùå Test failed:', error);
    process.exit(1);
  }
}

testFullSync();
```

**Run test:**
```bash
cd archibald-web-app/backend
npm run build
node dist/test-full-sync.js
```

**Expected Output:**
- `[Progress] login: Connessione ad Archibald...`
- `[Progress] download: Scaricamento PDF clienti...`
- `[Progress] parse: Analisi PDF in corso...`
- `[Progress] update: Aggiornamento ~1515 clienti...`
- `[Progress] cleanup: Finalizzazione...`
- `‚úÖ Sync successful: { customersProcessed: 1515, newCustomers: X, updatedCustomers: Y, duration: 15000-20000ms }`
- `üéâ Test passed!`

**Performance Target:**
- Total duration: 15-20s (within target!)

If test passes, Plan 18-02 is complete.
</task>
</tasks>

<verification>
## Success Criteria
- ‚úÖ Bot downloads PDF from Archibald Clienti page successfully
- ‚úÖ PDF saved to `/tmp` with unique filename
- ‚úÖ File size validation prevents empty downloads
- ‚úÖ CustomerSyncService orchestrates download ‚Üí parse ‚Üí DB update
- ‚úÖ Hash-based delta detection works (insert new, update changed, skip unchanged)
- ‚úÖ All 27 PDF fields mapped to DB schema
- ‚úÖ Temp file cleanup on success and error
- ‚úÖ Progress callbacks work for UI integration
- ‚úÖ Full sync completes in 15-20s (target met)
- ‚úÖ TypeScript compiles without errors

## Test Commands
```bash
# Test PDF download only
node dist/test-pdf-download.js

# Test full sync pipeline
node dist/test-full-sync.js

# Check database after sync
sqlite3 .cache/customers.db "SELECT COUNT(*) FROM customers;"  # Should be ~1515
sqlite3 .cache/customers.db "SELECT * FROM customers LIMIT 1;" | head -30  # Verify all fields
```

## Performance Validation
- Bot download: 5-8s
- PDF parse: ~6s
- Delta detection: 1-2s
- DB updates: 1-2s
- Total: **15-20s** ‚úÖ (vs 30-60s HTML scraping - **50-67% faster!**)
</verification>

<success_criteria>
Plan complete when:
1. downloadCustomersPDF() method works reliably
2. CustomerSyncService replaces old HTML scraping
3. Delta detection correctly identifies new/updated/unchanged
4. All 27 PDF fields flow to database
5. Temp file cleanup working
6. Full sync completes in < 20s
7. Integration tests pass with real Archibald
8. Ready for Phase 18-03 (manual sync UI)
</success_criteria>

<output>
**Deliverables:**
1. New `ArchibaldBot.downloadCustomersPDF()` method
2. Refactored `CustomerSyncService` with PDF-based sync
3. Hash-based delta detection for efficient incremental syncs
4. Updated `customer-db.ts` schema with 27 PDF fields
5. Integration tests validating end-to-end flow

**Files Modified:**
- `archibald-web-app/backend/src/archibald-bot.ts` (+60 lines - downloadCustomersPDF)
- `archibald-web-app/backend/src/customer-sync-service.ts` (replaced ~800 lines with ~250 lines PDF approach)
- `archibald-web-app/backend/src/customer-db.ts` (+11 new fields in schema)

**Files Created:**
- `test-pdf-download.ts` (manual test script)
- `test-full-sync.ts` (integration test script)
- `customer-sync-service.OLD_HTML_SCRAPING.ts.backup` (backup of old implementation)

**Performance Improvement:**
- Old: 30-60s (HTML scraping)
- New: 15-20s (PDF parsing)
- **Improvement: 50-67% faster!**

**Next:** Plan 18-03 will add manual sync button UI in Clienti page.
</output>
