# Phase 4, Plan 1: Voice Parser Enhancement

<objective>
Refactor voice parser for reliable entity extraction (cliente, articolo, quantità) with better error handling and confidence scoring.
</objective>

<execution_context>
@archibald-web-app/frontend/src/utils/orderParser.ts
@archibald-web-app/frontend/src/hooks/useVoiceInput.ts
@archibald-web-app/frontend/src/types/order.ts
@~/.claude/get-shit-done/references/tdd.md
@/Users/hatholdir/Downloads/.claude/CLAUDE.md
</execution_context>

<context>
**Current State:**
- Basic voice parser exists in `orderParser.ts` with regex-based extraction
- Supports: customer name/ID, article code, quantity, price
- Normalizes article codes ("TD1272 punto 314" → "TD1272.314")
- Simple suggestions based on missing keywords

**Problems:**
- No confidence scoring - can't tell if extraction was reliable
- No validation of extracted entities
- Limited error recovery when recognition fails
- No handling of ambiguous input
- Doesn't leverage customer/product autocomplete for validation

**Goal:**
Enhance parser with:
1. Confidence scoring for each extracted entity
2. Validation against customer/product database
3. Better error messages for malformed input
4. Fuzzy matching for customer/product names
5. Support for multiple items in single voice input
6. **Quantity-First strategy** with smart variant selection
7. Mixed-package disambiguation (es. 7pz = 5+2 o 7×1?)

**Parsing Strategy (Quantity-First):**
- User says total quantity needed (e.g., "quantità 7")
- Bot automatically selects optimal variant based on mathematical validation
- Example: H129FSQ qty=10 → K2 (5-pack × 2) preferred over K3 (1-pack × 10)
- **Future Evolution**: Add Hybrid mode supporting "3 confezioni da 5" or "K2" explicit override

**Critical Voice Input Patterns:**
1. **Article code dots**: Agents say "H71 (pause) 104 (pause) 032" NOT "H71 punto 104 punto 032"
   - Parser must handle: `"H71 104 032"` → normalize to `"H71.104.032"`
2. **Mixed-package scenarios**: Qty=7 with 5-pack + 1-pack available
   - Option A: 7×K3 (1-pack) = 7 confezioni
   - Option B: 1×K2 (5-pack) + 2×K3 (1-pack) = 3 confezioni totali (più efficiente)
   - **Solution**: Ask user for clarification when multiple solutions exist

**Success Criteria:**
- Parser returns confidence scores (0-1) for each entity
- Invalid customer names return suggestions from database
- Invalid article codes return suggestions from catalog
- Article codes without "punto" parsed correctly (H71 104 032 → H71.104.032)
- Mixed-package scenarios detected and flagged for user confirmation
- Unit tests cover edge cases (ambiguous, partial, malformed input, mixed-package)
- No breaking changes to existing OrderForm.tsx integration
</context>

<tasks>

## Task 1: Add Confidence Scoring Types

**Objective:** Define TypeScript interfaces for enhanced parsing results with confidence scores.

**Steps:**
1. Read current `ParsedOrder` interface in `orderParser.ts:3-7`
2. Create new `ParsedOrderWithConfidence` interface:
   - `customerId?: string` with `customerIdConfidence?: number`
   - `customerName?: string` with `customerNameConfidence?: number`
   - `items: ParsedOrderItem[]` with per-item confidence
3. Create `ParsedOrderItem` interface extending `OrderItem`:
   - `articleCodeConfidence?: number`
   - `quantityConfidence?: number`
   - `validationErrors?: string[]`
   - `suggestions?: string[]`
4. Export new types from `orderParser.ts`

**Verification:**
```bash
cd archibald-web-app/frontend && npm run typecheck
```

---

## Task 2: Write Tests for Enhanced Parser (TDD RED)

**Objective:** Write failing tests for confidence scoring and validation features.

**Steps:**
1. Create `orderParser.spec.ts` in `frontend/src/utils/`
2. Write test cases for `parseVoiceOrderWithConfidence()`:
   - **High confidence**: "cliente Mario Rossi, articolo SF1000 quantità 5" → confidence = 1.0
   - **Medium confidence**: "cliente mario rossi articolo sf mille quantità cinque" → confidence = 0.7
   - **Low confidence**: "mario rossi sf quantità" → confidence = 0.4
   - **Validation**: Invalid article code → suggestions array populated
   - **Fuzzy matching**: "cliente Fresi" (typo) → suggests "Fresis"
3. Write test cases for **article code normalization** (CRITICAL):
   - **With "punto"**: "H71 punto 104 punto 032" → "H71.104.032"
   - **Without "punto"**: "H71 104 032" → "H71.104.032" (COMMON CASE)
   - **Mixed format**: "H71.104 032" → "H71.104.032"
   - **No spaces**: "H71104032" → "H71.104.032" (if pattern detected)
4. Write test cases for **mixed-package scenarios**:
   - **Scenario 1**: qty=7, variants=[K2:5pz, K3:1pz]
     - Solution A: 7×K3 = 7 packages
     - Solution B: 1×K2 + 2×K3 = 3 packages (MORE EFFICIENT)
     - Expected: `needsDisambiguation: true`, `suggestions: [{packages: 3, breakdown: "1×K2+2×K3"}, {packages: 7, breakdown: "7×K3"}]`
   - **Scenario 2**: qty=10, variants=[K2:5pz, K3:1pz]
     - Only solution: 2×K2
     - Expected: `needsDisambiguation: false`, auto-select K2
   - **Scenario 3**: qty=6, variants=[K2:5pz, K3:1pz]
     - Only solution: 6×K3 (6 % 5 ≠ 0)
     - Expected: `needsDisambiguation: false`, auto-select K3
5. Write test cases for `validateExtractedEntities()`:
   - Valid customer from mock database → validation passes
   - Invalid customer → validation error with suggestions
   - Valid article code → validation passes
   - Invalid article code → validation error with suggestions

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Tests fail (functions not implemented yet)
```

---

## Task 3: Implement Article Code Normalization (CRITICAL)

**Objective:** Handle article codes spoken without "punto" (most common case).

**Steps:**
1. Update `normalizeArticleCode()` in `orderParser.ts:108-117`:
   - Current: handles "punto" → ".", "trattino" → "-", "slash" → "/"
   - **Enhancement**: Detect numeric sequences separated by spaces
   - Pattern: `[A-Z]+\d*\s+\d+\s+\d+` → insert dots between numbers
   - Example: "H71 104 032" → "H71.104.032"
2. Implementation:
   ```typescript
   function normalizeArticleCode(code: string): string {
     let normalized = code
       // Handle explicit "punto" keyword
       .replace(/\s+punto\s+/gi, ".")
       .replace(/\s+trattino\s+/gi, "-")
       .replace(/\s+slash\s+/gi, "/")
       .replace(/mille/gi, "1000")
       .replace(/cento/gi, "100");

     // CRITICAL: Handle spaces as implicit dots for numeric sequences
     // Pattern: "H71 104 032" → "H71.104.032"
     // Match: letter+optional-digit, then space-separated digits
     const spacePattern = /([A-Z]+\d*)\s+(\d+)\s+(\d+)/gi;
     normalized = normalized.replace(spacePattern, '$1.$2.$3');

     // Handle remaining single spaces between digits (e.g., "H71.104 032")
     normalized = normalized.replace(/(\d+)\s+(\d+)/g, '$1.$2');

     return normalized.toUpperCase().trim();
   }
   ```
3. Write additional edge case tests:
   - "H71 104 032" → "H71.104.032"
   - "TD 1272 314" → "TD.1272.314"
   - "SF 1000" → "SF.1000" (2 numbers only)
   - "H250E 104 040" → "H250E.104.040"
   - Mixed: "H71.104 032" → "H71.104.032"

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Article code normalization tests pass
```

---

## Task 4: Implement Mixed-Package Detection Algorithm

**Objective:** Detect when multiple packaging solutions exist and flag for user confirmation.

**Steps:**
1. Create `detectMixedPackageSolutions()` utility:
   - Input: quantity, variants (sorted by multipleQty DESC)
   - Output: `PackageSolution[]` with disambiguation flag
2. Algorithm (Knapsack-style):
   ```typescript
   interface PackageSolution {
     totalPackages: number;
     breakdown: Array<{ variantId: string; packageContent: number; count: number }>;
     isOptimal: boolean; // Fewest packages
   }

   function detectMixedPackageSolutions(
     quantity: number,
     variants: Product[]
   ): { needsDisambiguation: boolean; solutions: PackageSolution[] } {
     const solutions: PackageSolution[] = [];

     // Solution 1: Single variant (smallest package that divides evenly)
     for (const variant of [...variants].reverse()) { // Start with smallest
       const multiple = variant.multipleQty || 1;
       if (quantity % multiple === 0) {
         solutions.push({
           totalPackages: quantity / multiple,
           breakdown: [{ variantId: variant.id, packageContent: multiple, count: quantity / multiple }],
           isOptimal: false // Will be marked later
         });
         break; // Only one single-variant solution
       }
     }

     // Solution 2: Mixed packages (if 2+ variants available)
     if (variants.length >= 2) {
       const large = variants[0]; // Highest multipleQty
       const small = variants[variants.length - 1]; // Smallest multipleQty

       const largeMultiple = large.multipleQty || 1;
       const smallMultiple = small.multipleQty || 1;

       // Try: maximize large packages, fill remainder with small
       const largeCount = Math.floor(quantity / largeMultiple);
       const remainder = quantity % largeMultiple;

       if (remainder % smallMultiple === 0 && largeCount > 0) {
         const smallCount = remainder / smallMultiple;
         solutions.push({
           totalPackages: largeCount + smallCount,
           breakdown: [
             { variantId: large.id, packageContent: largeMultiple, count: largeCount },
             { variantId: small.id, packageContent: smallMultiple, count: smallCount }
           ],
           isOptimal: false
         });
       }
     }

     // Mark optimal solution (fewest packages)
     if (solutions.length > 0) {
       const minPackages = Math.min(...solutions.map(s => s.totalPackages));
       solutions.forEach(s => {
         s.isOptimal = s.totalPackages === minPackages;
       });
     }

     return {
       needsDisambiguation: solutions.length > 1,
       solutions: solutions.sort((a, b) => a.totalPackages - b.totalPackages) // Optimal first
     };
   }
   ```
3. Add to `ParsedOrderItem` interface:
   ```typescript
   interface ParsedOrderItem {
     articleCode: string;
     quantity: number;
     needsDisambiguation?: boolean;
     packageSolutions?: PackageSolution[];
     // ... existing fields
   }
   ```
4. Write tests for algorithm:
   - qty=7, [K2:5, K3:1] → 2 solutions, needs disambiguation
   - qty=10, [K2:5, K3:1] → 1 solution (2×K2), no disambiguation
   - qty=6, [K2:5, K3:1] → 1 solution (6×K3), no disambiguation
   - qty=15, [K2:5, K3:1] → 1 solution (3×K2), no disambiguation

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Mixed-package detection tests pass
```

---

## Task 5: Implement Confidence Scoring Algorithm

**Objective:** Implement confidence calculation based on extraction quality.

**Steps:**
1. Create `calculateEntityConfidence()` function:
   - Input: extracted value, original transcript, entity type
   - Logic:
     - Start with confidence = 1.0
     - Reduce by 0.1 if value was normalized (e.g., "mille" → "1000")
     - Reduce by 0.2 if value is very short (< 3 chars for names)
     - Reduce by 0.3 if multiple possible interpretations exist
     - Reduce by 0.2 if entity keyword missing from transcript
   - Output: confidence score (0-1)
2. Apply confidence calculation to existing regex extraction:
   - Customer ID: high confidence if format matches `[A-Z0-9]{5,}`
   - Customer name: medium confidence if contains special chars
   - Article code: high confidence if matches product code pattern
   - Quantity: high confidence if numeric, low if word-based ("cinque")
3. Update `parseVoiceOrder()` to return confidence scores

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Confidence scoring tests pass
```

---

## Task 6: Add Entity Validation with Fuzzy Matching

**Objective:** Validate extracted entities against customer/product databases with fuzzy matching.

**Steps:**
1. Create `validateExtractedEntities()` async function:
   - Input: `ParsedOrderWithConfidence`, customer list, product list
   - Logic:
     - If customerName extracted, fuzzy match against customer database
       - Use Levenshtein distance (threshold: 2 edits)
       - Return top 3 suggestions if no exact match
     - If articleCode extracted, check against product database
       - Try exact match first
       - Try normalized match (remove spaces, dots)
       - Return top 3 suggestions if no match
     - Update confidence scores based on validation results
   - Output: updated `ParsedOrderWithConfidence` with validation errors and suggestions
2. Install `fuse.js` for fuzzy search:
   ```bash
   cd archibald-web-app/frontend && npm install fuse.js
   ```
3. Integrate fuzzy search for customer and product matching
4. Add validation error messages:
   - "Cliente 'Mario Ross' non trovato. Intendevi: Mario Rossi, Mario Rosso?"
   - "Articolo 'SF100' non trovato. Intendevi: SF1000, SF1001?"

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Validation tests pass
```

---

## Task 7: Support Multiple Items in Single Voice Input

**Objective:** Enhance parser to handle multiple articles in one transcript.

**Steps:**
1. Update `parseItems()` function to better split multi-item input:
   - Current: splits by "articolo" keyword
   - Enhancement: also split by commas and "poi" ("then")
   - Example: "SF1000 quantità 5, poi TD1272 quantità 2"
2. Add confidence penalty for multi-item input (reduce by 0.1 per item)
3. Write tests for multi-item scenarios:
   - 2 items with clear separation → high confidence
   - 3+ items → medium confidence (higher error risk)
   - Items without quantity → low confidence with validation error

**Verification:**
```bash
cd archibald-web-app/frontend && npm test orderParser.spec.ts
# Expected: Multi-item tests pass
```

---

## Task 8: Integration Testing with OrderForm

**Objective:** Verify enhanced parser works with existing OrderForm component.

**Steps:**
1. Read `OrderForm.tsx` voice integration (lines 66-87, 317-346)
2. Create integration test `OrderForm.voice.spec.tsx`:
   - Mock `useVoiceInput` hook with sample transcripts
   - Mock customer and product API responses
   - Test cases:
     - Valid voice input → form fields populated correctly
     - Invalid customer → error message shown with suggestions
     - Invalid article → error message shown with suggestions
     - Low confidence → warning shown to user
3. Run integration tests
4. If tests fail, fix integration issues
5. Update OrderForm to handle new confidence and validation fields (DO NOT implement UI changes, just ensure data flows correctly)

**Verification:**
```bash
cd archibald-web-app/frontend && npm test OrderForm.voice.spec.tsx
# Expected: All integration tests pass
```

---

## Task 9: Documentation and Code Review

**Objective:** Document new parser capabilities and verify code quality.

**Steps:**
1. Add JSDoc comments to new functions:
   - `parseVoiceOrderWithConfidence()`
   - `calculateEntityConfidence()`
   - `validateExtractedEntities()`
2. Update existing comments in `orderParser.ts` to reflect new confidence features
3. Run prettier and linting:
   ```bash
   cd archibald-web-app/frontend && npm run format
   npm run lint
   ```
4. Self-review using QCHECK checklist from CLAUDE.md
5. Run full test suite:
   ```bash
   cd archibald-web-app/frontend && npm test
   ```

**Verification:**
- All tests pass (unit + integration)
- No linting errors
- Code follows TDD best practices from CLAUDE.md

</tasks>

<verification>

## Unit Tests
```bash
cd archibald-web-app/frontend
npm test orderParser.spec.ts
```
Expected: All tests pass (~15-20 test cases)

## Integration Tests
```bash
npm test OrderForm.voice.spec.tsx
```
Expected: All integration tests pass (~5-8 test cases)

## Type Checking
```bash
npm run typecheck
```
Expected: No type errors

## Manual Verification
1. Voice input "cliente Mario Rossi, articolo SF1000 quantità 5" → confidence = 1.0
2. Voice input with typo "cliente Fresi" → suggestions shown
3. Invalid article code → suggestions shown
4. Multi-item input → all items parsed with appropriate confidence

</verification>

<success_criteria>
- [ ] `ParsedOrderWithConfidence` type exported with confidence scores for all entities
- [ ] Confidence scoring algorithm implemented (scores 0-1 based on extraction quality)
- [ ] Entity validation with fuzzy matching against customer/product databases
- [ ] Validation errors and suggestions returned for invalid entities
- [ ] Multi-item voice input supported with appropriate confidence penalties
- [ ] Unit tests cover all edge cases (ambiguous, partial, malformed input)
- [ ] Integration tests verify OrderForm compatibility
- [ ] No breaking changes to existing OrderForm.tsx
- [ ] All tests pass, no linting errors
- [ ] Code follows TDD best practices from CLAUDE.md
</success_criteria>

<output>
**Files Created:**
- `frontend/src/utils/orderParser.spec.ts` - Unit tests for enhanced parser
- `frontend/src/components/OrderForm.voice.spec.tsx` - Integration tests

**Files Modified:**
- `frontend/src/utils/orderParser.ts` - Enhanced parser with confidence scoring and validation
- `frontend/package.json` - Added `fuse.js` dependency

**Commits:**
1. `test(voice): add unit tests for enhanced parser with confidence scoring`
2. `feat(voice): implement confidence scoring for entity extraction`
3. `feat(voice): add entity validation with fuzzy matching`
4. `feat(voice): support multiple items in single voice input`
5. `test(voice): add integration tests for OrderForm voice input`
6. `docs(voice): document enhanced parser capabilities`

**Next Steps:**
Execute Plan 04-02 to add visual feedback during voice recognition.
</output>
