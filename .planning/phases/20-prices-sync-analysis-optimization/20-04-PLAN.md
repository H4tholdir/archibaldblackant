---
phase: 20-prices-sync-analysis-optimization
plan: 04
title: Price History Tracking System
subsystem: backend
complexity: medium
estimated_duration: 45min
tags: [price-history, database, tracking, retention, audit]
---

# Plan 20-04: Price History Tracking System

## Objective

Create price history tracking system to record all price changes over time, implement 30-day retention for dashboard display, maintain full history for per-article queries, and integrate with price matching service to automatically log changes.

## Execution Context

**User Requirements (from 20-CONTEXT.md):**
- Track complete price history for every product variant
- Record: oldPrice, newPrice, percentageChange, syncDate, source
- Retention policy: 30 days for dashboard, full history for per-article queries
- Automatic logging on every price update (sync or Excel upload)
- Support both global dashboard view and per-article timeline

**Current State:**
- No price history tracking exists
- Price updates happen in PriceMatchingService (Plan 20-03)
- No audit trail for price changes

**Key Files:**
- Reference: `archibald-web-app/backend/src/migrations/002-price-vat-audit.ts` (existing pattern)
- Reference: `archibald-web-app/backend/src/price-audit-helper.ts` (existing pattern)
- Target: `archibald-web-app/backend/src/price-history-db.ts` (new)
- Target: `archibald-web-app/backend/src/price-matching-service.ts` (enhance)

## Context

**Dependencies:**
- Plan 20-03 complete (price matching working)
- PriceDatabase and ProductDatabase operational

**Database Strategy:**
- Separate `price_history` table in `prices.db`
- Indexes for fast queries (productId, syncDate, percentageChange)
- Retention handled via query filters (30 days) + optional cleanup job

**Price Change Detection:**
- Triggered by PriceMatchingService.updateProductPrice()
- Compare old vs new price
- Calculate percentage change: ((new - old) / old) * 100
- Record timestamp, source (PDF sync / Excel upload)

## Tasks

### Task 1: Create Price History Database Schema
**Duration:** 15min
**Type:** auto

Add `price_history` table to `prices.db` via migration.

**Implementation:**

Create `archibald-web-app/backend/src/migrations/003-price-history.ts`:

```typescript
import Database from 'better-sqlite3';
import path from 'path';

/**
 * Migration 003: Add price_history table
 * Tracks all price changes for audit and dashboard display
 */
export function migrate003PriceHistory(dbPath?: string): void {
  const finalPath = dbPath || path.join(__dirname, '../../data/prices.db');
  const db = new Database(finalPath);

  db.exec(`
    CREATE TABLE IF NOT EXISTS price_history (
      id INTEGER PRIMARY KEY AUTOINCREMENT,

      -- Product identification
      productId TEXT NOT NULL,
      productName TEXT NOT NULL,
      variantId TEXT, -- itemSelection (K2, K3, etc.)

      -- Price change data
      oldPrice REAL,
      newPrice REAL NOT NULL,
      priceChange REAL, -- absolute change (newPrice - oldPrice)
      percentageChange REAL, -- percentage change ((new - old) / old * 100)

      -- Change metadata
      syncDate INTEGER NOT NULL, -- Unix timestamp
      source TEXT NOT NULL, -- 'pdf-sync' | 'excel-upload' | 'manual'
      changeType TEXT NOT NULL, -- 'increase' | 'decrease' | 'new'

      -- Additional context
      currency TEXT,
      notes TEXT,

      -- Metadata
      createdAt INTEGER NOT NULL
    );

    -- Indexes for fast queries
    CREATE INDEX IF NOT EXISTS idx_price_history_productId
      ON price_history(productId);

    CREATE INDEX IF NOT EXISTS idx_price_history_syncDate
      ON price_history(syncDate);

    CREATE INDEX IF NOT EXISTS idx_price_history_percentageChange
      ON price_history(percentageChange);

    CREATE INDEX IF NOT EXISTS idx_price_history_product_variant
      ON price_history(productId, variantId);

    -- Compound index for dashboard queries (30 days recent changes)
    CREATE INDEX IF NOT EXISTS idx_price_history_recent
      ON price_history(syncDate DESC, percentageChange DESC);
  `);

  db.close();
  console.log('[Migration 003] Price history table created');
}

// Run migration if executed directly
if (require.main === module) {
  migrate003PriceHistory();
}
```

**Acceptance Criteria:**
- [ ] price_history table created in prices.db
- [ ] All required fields present
- [ ] Indexes created for performance
- [ ] Migration can be run multiple times safely

**Commit:** `feat(20-04): create price_history table with indexes`

---

### Task 2: Create Price History Database Manager
**Duration:** 15min
**Type:** auto

Create `archibald-web-app/backend/src/price-history-db.ts` for managing history records.

**Implementation:**

```typescript
import Database from 'better-sqlite3';
import path from 'path';
import { logger } from './logger';

/**
 * Price history record
 */
export interface PriceHistoryRecord {
  id: number;
  productId: string;
  productName: string;
  variantId: string | null;
  oldPrice: number | null;
  newPrice: number;
  priceChange: number;
  percentageChange: number;
  syncDate: number;
  source: 'pdf-sync' | 'excel-upload' | 'manual';
  changeType: 'increase' | 'decrease' | 'new';
  currency: string | null;
  notes: string | null;
  createdAt: number;
}

/**
 * Price history database manager
 * Tracks all price changes over time
 */
export class PriceHistoryDatabase {
  private static instance: PriceHistoryDatabase;
  private db: Database.Database;

  private constructor(dbPath?: string) {
    const finalPath = dbPath || path.join(__dirname, '../data/prices.db');
    this.db = new Database(finalPath);
    logger.info(`[PriceHistoryDatabase] Initialized at ${finalPath}`);
  }

  static getInstance(dbPath?: string): PriceHistoryDatabase {
    if (!PriceHistoryDatabase.instance) {
      PriceHistoryDatabase.instance = new PriceHistoryDatabase(dbPath);
    }
    return PriceHistoryDatabase.instance;
  }

  /**
   * Record price change
   * Automatically calculates change metrics and determines change type
   */
  recordPriceChange(change: {
    productId: string;
    productName: string;
    variantId?: string | null;
    oldPrice?: number | null;
    newPrice: number;
    source: 'pdf-sync' | 'excel-upload' | 'manual';
    currency?: string;
    notes?: string;
  }): void {
    const now = Math.floor(Date.now() / 1000);

    // Calculate metrics
    const oldPrice = change.oldPrice ?? null;
    const priceChange = oldPrice !== null ? change.newPrice - oldPrice : change.newPrice;
    const percentageChange =
      oldPrice !== null && oldPrice !== 0
        ? ((change.newPrice - oldPrice) / oldPrice) * 100
        : 0;

    // Determine change type
    let changeType: 'increase' | 'decrease' | 'new';
    if (oldPrice === null) {
      changeType = 'new';
    } else if (change.newPrice > oldPrice) {
      changeType = 'increase';
    } else {
      changeType = 'decrease';
    }

    // Insert record
    this.db
      .prepare(`
        INSERT INTO price_history (
          productId, productName, variantId, oldPrice, newPrice,
          priceChange, percentageChange, syncDate, source, changeType,
          currency, notes, createdAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .run(
        change.productId,
        change.productName,
        change.variantId ?? null,
        oldPrice,
        change.newPrice,
        priceChange,
        percentageChange,
        now,
        change.source,
        changeType,
        change.currency ?? null,
        change.notes ?? null,
        now
      );

    logger.info('[PriceHistoryDatabase] Price change recorded', {
      productId: change.productId,
      oldPrice,
      newPrice: change.newPrice,
      percentageChange: percentageChange.toFixed(2) + '%',
      changeType,
    });
  }

  /**
   * Get price history for specific product (all variants)
   * Returns full history ordered by date DESC
   */
  getProductHistory(productId: string): PriceHistoryRecord[] {
    return this.db
      .prepare(`
        SELECT * FROM price_history
        WHERE productId = ?
        ORDER BY syncDate DESC
      `)
      .all(productId) as PriceHistoryRecord[];
  }

  /**
   * Get price history for specific product variant
   */
  getVariantHistory(productId: string, variantId: string | null): PriceHistoryRecord[] {
    return this.db
      .prepare(`
        SELECT * FROM price_history
        WHERE productId = ? AND variantId = ?
        ORDER BY syncDate DESC
      `)
      .all(productId, variantId ?? null) as PriceHistoryRecord[];
  }

  /**
   * Get recent price changes (last N days)
   * Used for dashboard display
   *
   * @param daysBack Number of days to look back (default: 30)
   * @param limit Max results (default: 100)
   */
  getRecentChanges(daysBack: number = 30, limit: number = 100): PriceHistoryRecord[] {
    const cutoffTimestamp = Math.floor(Date.now() / 1000) - daysBack * 24 * 60 * 60;

    return this.db
      .prepare(`
        SELECT * FROM price_history
        WHERE syncDate >= ?
        ORDER BY syncDate DESC, ABS(percentageChange) DESC
        LIMIT ?
      `)
      .all(cutoffTimestamp, limit) as PriceHistoryRecord[];
  }

  /**
   * Get recent price increases (dashboard widget)
   */
  getRecentIncreases(daysBack: number = 30): PriceHistoryRecord[] {
    const cutoffTimestamp = Math.floor(Date.now() / 1000) - daysBack * 24 * 60 * 60;

    return this.db
      .prepare(`
        SELECT * FROM price_history
        WHERE syncDate >= ? AND changeType = 'increase'
        ORDER BY percentageChange DESC
      `)
      .all(cutoffTimestamp) as PriceHistoryRecord[];
  }

  /**
   * Get recent price decreases (dashboard widget)
   */
  getRecentDecreases(daysBack: number = 30): PriceHistoryRecord[] {
    const cutoffTimestamp = Math.floor(Date.now() / 1000) - daysBack * 24 * 60 * 60;

    return this.db
      .prepare(`
        SELECT * FROM price_history
        WHERE syncDate >= ? AND changeType = 'decrease'
        ORDER BY percentageChange ASC
      `)
      .all(cutoffTimestamp) as PriceHistoryRecord[];
  }

  /**
   * Get statistics for recent changes (last N days)
   */
  getRecentStats(daysBack: number = 30): {
    totalChanges: number;
    increases: number;
    decreases: number;
    newPrices: number;
    avgIncrease: number;
    avgDecrease: number;
  } {
    const cutoffTimestamp = Math.floor(Date.now() / 1000) - daysBack * 24 * 60 * 60;

    const stats = this.db
      .prepare(`
        SELECT
          COUNT(*) as totalChanges,
          SUM(CASE WHEN changeType = 'increase' THEN 1 ELSE 0 END) as increases,
          SUM(CASE WHEN changeType = 'decrease' THEN 1 ELSE 0 END) as decreases,
          SUM(CASE WHEN changeType = 'new' THEN 1 ELSE 0 END) as newPrices,
          AVG(CASE WHEN changeType = 'increase' THEN percentageChange ELSE NULL END) as avgIncrease,
          AVG(CASE WHEN changeType = 'decrease' THEN percentageChange ELSE NULL END) as avgDecrease
        FROM price_history
        WHERE syncDate >= ?
      `)
      .get(cutoffTimestamp) as any;

    return {
      totalChanges: stats.totalChanges || 0,
      increases: stats.increases || 0,
      decreases: stats.decreases || 0,
      newPrices: stats.newPrices || 0,
      avgIncrease: stats.avgIncrease || 0,
      avgDecrease: stats.avgDecrease || 0,
    };
  }

  /**
   * Cleanup old records (optional - run periodically)
   * Keeps full history but can archive old data if needed
   */
  archiveOldRecords(daysToKeep: number = 365): number {
    const cutoffTimestamp = Math.floor(Date.now() / 1000) - daysToKeep * 24 * 60 * 60;

    const result = this.db
      .prepare('DELETE FROM price_history WHERE syncDate < ?')
      .run(cutoffTimestamp);

    logger.info('[PriceHistoryDatabase] Archived old records', {
      deleted: result.changes,
      cutoffDays: daysToKeep,
    });

    return result.changes;
  }

  /**
   * Close database connection
   */
  close(): void {
    this.db.close();
    logger.info('[PriceHistoryDatabase] Database closed');
  }
}
```

**Key Features:**
- Automatic change type detection (increase/decrease/new)
- Percentage change calculation
- Query methods for dashboard (30 days) and per-article (full history)
- Statistics aggregation
- Optional archival for old records

**Acceptance Criteria:**
- [ ] recordPriceChange() logs all price changes
- [ ] Automatic change type and percentage calculation
- [ ] getRecentChanges() returns last 30 days
- [ ] getProductHistory() returns full history
- [ ] Statistics methods work correctly
- [ ] Singleton pattern

**Commit:** `feat(20-04): create price history database manager`

---

### Task 3: Integrate History Tracking with Price Matching
**Duration:** 10min
**Type:** auto

Enhance `PriceMatchingService` to automatically log price changes.

**Implementation:**

Update `archibald-web-app/backend/src/price-matching-service.ts`:

```typescript
import { PriceHistoryDatabase } from './price-history-db';

// ... existing code ...

export class PriceMatchingService {
  private static instance: PriceMatchingService;
  private priceDb: PriceDatabase;
  private productDb: ProductDatabase;
  private historyDb: PriceHistoryDatabase; // NEW

  private constructor() {
    this.priceDb = PriceDatabase.getInstance();
    this.productDb = ProductDatabase.getInstance();
    this.historyDb = PriceHistoryDatabase.getInstance(); // NEW
  }

  // ... existing methods ...

  /**
   * Match all prices with history tracking
   */
  async matchPricesToProducts(
    excelVatMap?: Map<string, number>
  ): Promise<{
    result: PriceMatchResult;
    unmatchedPrices: UnmatchedPrice[];
  }> {
    // ... existing matching logic ...

    for (const priceRecord of allPriceRecords) {
      // ... existing matching logic ...

      if (matchedProduct) {
        // Get old price for comparison
        const oldPrice = matchedProduct.price ?? null;
        const newPrice = priceRecord.unitPrice;

        // Update product
        const updated = this.productDb.updateProductPrice(
          matchedProduct.id,
          newPrice,
          vatPercentage,
          'prices-db',
          vatPercentage ? 'excel' : null
        );

        if (updated) {
          matchedProducts++;
          updatedProducts++;

          // Record price change in history (NEW)
          if (oldPrice !== newPrice) {
            this.historyDb.recordPriceChange({
              productId: matchedProduct.id,
              productName: matchedProduct.name,
              variantId: priceRecord.itemSelection,
              oldPrice,
              newPrice,
              source: 'pdf-sync',
              currency: priceRecord.currency ?? 'EUR',
            });
          }
        }
      }
    }

    // ... existing return ...
  }
}
```

**Acceptance Criteria:**
- [ ] Price changes automatically logged to history
- [ ] Only logs when price actually changes (oldPrice ≠ newPrice)
- [ ] Records source as 'pdf-sync'
- [ ] Includes variant information

**Commit:** `feat(20-04): integrate price history tracking with price matching`

---

### Task 4: Add Price History API Endpoints
**Duration:** 5min
**Type:** auto

Add REST endpoints for querying price history.

**Implementation:**

Add to `archibald-web-app/backend/src/index.ts`:

```typescript
import { PriceHistoryDatabase } from './price-history-db';

// ... existing code ...

// Get price history for specific product
app.get("/api/prices/history/:productId", authenticateJWT, async (req, res) => {
  try {
    const { productId } = req.params;
    const historyDb = PriceHistoryDatabase.getInstance();

    const history = historyDb.getProductHistory(productId);

    res.json({
      success: true,
      productId,
      historyCount: history.length,
      history,
    });
  } catch (error) {
    logger.error('[API] Get price history failed', { error });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
});

// Get recent price changes (last 30 days)
app.get("/api/prices/history/recent/:days?", authenticateJWT, async (req, res) => {
  try {
    const days = parseInt(req.params.days || '30');
    const historyDb = PriceHistoryDatabase.getInstance();

    const recentChanges = historyDb.getRecentChanges(days);
    const stats = historyDb.getRecentStats(days);

    res.json({
      success: true,
      daysBack: days,
      stats,
      changes: recentChanges,
    });
  } catch (error) {
    logger.error('[API] Get recent price changes failed', { error });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
});

// Get recent increases/decreases summary
app.get("/api/prices/history/summary", authenticateJWT, async (req, res) => {
  try {
    const historyDb = PriceHistoryDatabase.getInstance();

    const increases = historyDb.getRecentIncreases(30);
    const decreases = historyDb.getRecentDecreases(30);
    const stats = historyDb.getRecentStats(30);

    res.json({
      success: true,
      stats,
      topIncreases: increases.slice(0, 10),
      topDecreases: decreases.slice(0, 10),
    });
  } catch (error) {
    logger.error('[API] Get price history summary failed', { error });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
});
```

**Acceptance Criteria:**
- [ ] GET /api/prices/history/:productId returns full history
- [ ] GET /api/prices/history/recent/:days returns recent changes
- [ ] GET /api/prices/history/summary returns statistics
- [ ] All endpoints JWT-protected
- [ ] Error handling works

**Commit:** `feat(20-04): add price history API endpoints`

---

## Verification

### Success Criteria

- [ ] price_history table created in prices.db
- [ ] PriceHistoryDatabase manager working
- [ ] Price changes automatically logged
- [ ] Recent changes query (30 days) works
- [ ] Per-article full history works
- [ ] Statistics aggregation correct
- [ ] API endpoints functional
- [ ] TypeScript compiles without errors
- [ ] All commits atomic with proper messages

### Manual Test

```bash
# 1. Run migration
cd archibald-web-app/backend
npm run build
node dist/migrations/003-price-history.js

# 2. Run price sync (generates history records)
curl -X POST http://localhost:3000/api/prices/sync \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 3. Check history table
sqlite3 archibald-web-app/backend/data/prices.db \
  "SELECT COUNT(*) FROM price_history;"

# 4. Query recent changes
curl http://localhost:3000/api/prices/history/recent/30 \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 5. Get product history
curl http://localhost:3000/api/prices/history/001627K2 \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 6. Get summary
curl http://localhost:3000/api/prices/history/summary \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"
```

### Expected Results

**After first sync:**
- price_history table has ~4,540 records (all changeType='new')
- percentageChange = 0 for all (no old price)

**After second sync with price changes:**
- New records with changeType='increase' or 'decrease'
- percentageChange calculated correctly
- oldPrice and newPrice populated

**API responses:**
- Recent changes: Array of changes last 30 days
- Product history: Full timeline for single product
- Summary: Statistics with top increases/decreases

## Output

**Files Created:**
1. `archibald-web-app/backend/src/migrations/003-price-history.ts` - Migration
2. `archibald-web-app/backend/src/price-history-db.ts` - History manager

**Files Modified:**
1. `archibald-web-app/backend/src/price-matching-service.ts` - History integration
2. `archibald-web-app/backend/src/index.ts` - API endpoints

**Commits:** 4 atomic commits

**Next:** Plan 20-05 (Price Variations Dashboard & Notifications)

---

## Notes

**Retention Strategy:**
- **Dashboard queries:** Last 30 days via WHERE clause
- **Per-article queries:** Full history (no time limit)
- **Optional cleanup:** archiveOldRecords() can delete old data if needed
- **Default:** Keep all history (storage is cheap, history is valuable)

**Change Type Detection:**
- **new:** oldPrice is null (first time seeing this price)
- **increase:** newPrice > oldPrice
- **decrease:** newPrice < oldPrice

**Percentage Change Formula:**
```
percentageChange = ((newPrice - oldPrice) / oldPrice) * 100
```

Examples:
- €10 → €12 = +20%
- €10 → €8 = -20%
- null → €10 = 0% (new)

**Performance Considerations:**
- Indexes on syncDate and percentageChange for fast dashboard queries
- Compound index (productId, variantId) for per-article queries
- Limit results to prevent large responses (100 for dashboard, unlimited for per-article)

**Integration Points:**
- PriceMatchingService logs changes during sync
- Excel upload can also log changes (add in Plan 20-03 enhancement)
- Manual price edits can log changes (future feature)
