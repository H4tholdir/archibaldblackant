---
phase: 20-prices-sync-analysis-optimization
plan: 01
title: PDF Parser Enhancement & Node.js Integration (Prices)
subsystem: integration
complexity: medium
estimated_duration: 45min
tags: [python, pdf-parsing, node-js, prices, 3-page-cycle, italian-locale]
---

# Plan 20-01: PDF Parser Enhancement & Node.js Integration (Prices)

## Objective

Create Python PDF parser for prices with **3-page cycle support** (verified structure), Italian currency format handling, and Node.js wrapper via child_process.spawn, reusing Phase 18/19 patterns with RAM optimization.

## Execution Context

**Phase 18/19 Proven Patterns:**
- Python PDF parser with multi-page cycle handling
- Node.js wrapper via `child_process.spawn` (NOT exec)
- Type-safe TypeScript interfaces matching Python dataclasses
- Health check endpoints for deployment verification
- Italian locale forcing for currency parsing
- 20MB buffer management for large PDFs
- 30s timeout protection

**User-Verified PDF Structure:**
Per user feedback, prices PDF has **3-page cycles** (NOT 8):

**Pagina 1: Identificazione e Account**
- ID (ID Articolo)
- CODICE CONTO
- ACCOUNT: DESCRIZIONE
- ACCOUNT:
- ITEM SELECTION: (K2, K3, etc. - packaging variant)

**Pagina 2: Descrizione e Date**
- ITEM DESCRIPTION: (Nome articolo)
- DA DATA (data inizio validità)
- DATA (data fine validità)
- QUANTITÀ
- IMPORTO
- DA

**Pagina 3: Prezzi e Unità** ← **PAGINA CHIAVE**
- QUANTITÀ
- IMPORTO
- UNITÀ DI PREZZO
- **IMPORTO UNITARIO:** ← **CAMPO PRINCIPALE** (formato italiano: "1.234,56 €")
- VALUTA (EUR)
- PREZZO NETTO BRASSELER

**Key Files:**
- Reference: `scripts/parse-clienti-pdf.py` (Phase 18 pattern - 8-page cycles)
- Reference: `scripts/parse-products-pdf.py` (Phase 19 pattern - 8-page cycles)
- Reference: `.planning/phases/20-prices-sync-analysis-optimization/PDF-STRUCTURE.md`
- Target: `scripts/parse-prices-pdf.py` (new - **3-page cycles**)
- Target: `archibald-web-app/backend/src/pdf-parser-prices-service.ts` (new)

## Context

**Dependencies:**
- Phase 18-01 complete (PDF parser pattern established)
- Phase 19-01 complete (multi-page cycle patterns)
- PyPDF2 library installed
- Python 3.x available

**Database Strategy:**
- Separate `prices.db` database (NOT mixed with products.db)
- Schema will be created in Plan 20-02
- Hash field for delta detection (MD5 of key fields)

**Italian Locale Handling:**
Per Phase 18/19 best practices:
- Use regex to convert: "1.234,56 €" → "1234.56"
- Remove dots (thousands separator)
- Replace comma with dot (decimal separator)
- Strip € symbol and whitespace
- Parse as float

## Tasks

### Task 1: Create Python PDF Parser for Prices (3-Page Cycles)
**Duration:** 20min
**Type:** auto

Create `scripts/parse-prices-pdf.py` with **3-page cycle parsing**.

**Implementation:**

```python
#!/usr/bin/env python3
"""
Archibald Prices PDF Parser with 3-Page Cycle Support

Parses price data from Archibald PDF export with Italian locale handling.
Verified structure: 3 pages per product (ID, Description, Price).
"""

import sys
import json
import re
from PyPDF2 import PdfReader
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class ParsedPrice:
    """Parsed price record from PDF (3-page cycle)"""

    # Page 1: Identificazione
    product_id: str  # ID
    item_selection: Optional[str] = None  # ITEM SELECTION (K2, K3, etc.)
    account_code: Optional[str] = None  # CODICE CONTO
    account_description: Optional[str] = None  # ACCOUNT: DESCRIZIONE

    # Page 2: Descrizione
    product_name: Optional[str] = None  # ITEM DESCRIPTION
    price_valid_from: Optional[str] = None  # DA DATA
    price_valid_to: Optional[str] = None  # DATA
    quantity_from: Optional[str] = None  # QUANTITÀ (da)
    quantity_to: Optional[str] = None  # QUANTITÀ (a)

    # Page 3: Prezzi ← KEY PAGE
    unit_price: Optional[str] = None  # IMPORTO UNITARIO (keep Italian format: "1.234,56 €")
    currency: Optional[str] = None  # VALUTA
    price_unit: Optional[str] = None  # UNITÀ DI PREZZO
    net_price_brasseler: Optional[str] = None  # PREZZO NETTO BRASSELER (keep Italian format)

class PricesPDFParser:
    """Parser for Archibald prices PDF export with 3-page cycles"""

    PAGES_PER_CYCLE = 3  # ← VERIFIED: 3 pages per product

    def __init__(self, pdf_path: str):
        self.pdf_path = pdf_path
        self.reader = PdfReader(pdf_path)
        self.total_pages = len(self.reader.pages)

    def parse(self) -> List[ParsedPrice]:
        """Parse all prices from PDF with RAM optimization"""
        prices = []
        num_cycles = self.total_pages // self.PAGES_PER_CYCLE

        for cycle_idx in range(num_cycles):
            base_page = cycle_idx * self.PAGES_PER_CYCLE

            # Parse each page in cycle (streaming, one at a time)
            try:
                page1_data = self._parse_page_1(base_page)
                page2_data = self._parse_page_2(base_page + 1)
                page3_data = self._parse_page_3(base_page + 2)

                # Combine all pages
                price = ParsedPrice(
                    **page1_data,
                    **page2_data,
                    **page3_data
                )

                # Filter garbage: ID="0" or empty, following Phase 18/19 pattern
                if price.product_id and price.product_id.strip() != "0":
                    prices.append(price)

            except Exception as e:
                # Log error but continue parsing (resilient to malformed pages)
                print(f"Warning: Failed to parse cycle {cycle_idx}: {e}", file=sys.stderr)
                continue

        return prices

    def _parse_page_1(self, page_num: int) -> Dict[str, Any]:
        """
        Parse page 1: ID, CODICE CONTO, ACCOUNT DESCRIZIONE, ITEM SELECTION
        """
        text = self.reader.pages[page_num].extract_text()

        return {
            "product_id": self._extract_field(text, "ID") or "",
            "item_selection": self._extract_field(text, "ITEM SELECTION:"),
            "account_code": self._extract_field(text, "CODICE CONTO"),
            "account_description": self._extract_field(text, "ACCOUNT: DESCRIZIONE"),
        }

    def _parse_page_2(self, page_num: int) -> Dict[str, Any]:
        """
        Parse page 2: ITEM DESCRIPTION, DA DATA, DATA, QUANTITÀ
        """
        text = self.reader.pages[page_num].extract_text()

        return {
            "product_name": self._extract_field(text, "ITEM DESCRIPTION:"),
            "price_valid_from": self._extract_field(text, "DA DATA"),
            "price_valid_to": self._extract_field(text, "DATA"),
            "quantity_from": self._extract_field(text, "QUANTITÀ"),
            "quantity_to": None,  # May need separate extraction if range exists
        }

    def _parse_page_3(self, page_num: int) -> Dict[str, Any]:
        """
        Parse page 3: IMPORTO UNITARIO (KEY FIELD), VALUTA, UNITÀ DI PREZZO, PREZZO NETTO
        Keep Italian format: "1.234,56 €" (no conversion)
        """
        text = self.reader.pages[page_num].extract_text()

        return {
            "unit_price": self._extract_field(text, "IMPORTO UNITARIO:"),
            "currency": self._extract_field(text, "VALUTA"),
            "price_unit": self._extract_field(text, "UNITÀ DI PREZZO"),
            "net_price_brasseler": self._extract_field(text, "PREZZO NETTO BRASSELER"),
        }

    def _extract_field(self, text: str, field_name: str) -> Optional[str]:
        """
        Extract field value from text after field name
        Handles both "FIELD:" and "FIELD" patterns
        """
        # Try with colon first
        pattern = rf"{re.escape(field_name)}\s*[:\s]*(.*?)(?:\n|$)"
        match = re.search(pattern, text, re.IGNORECASE | re.MULTILINE)

        if match:
            value = match.group(1).strip()
            return value if value else None

        # Try without colon (for fields like "VALUTA EUR")
        pattern_no_colon = rf"{re.escape(field_name)}\s+(.*?)(?:\n|$)"
        match = re.search(pattern_no_colon, text, re.IGNORECASE | re.MULTILINE)

        if match:
            value = match.group(1).strip()
            return value if value else None

        return None

def main():
    """Main entry point - outputs JSON to stdout"""
    if len(sys.argv) < 2:
        print(json.dumps({"error": "Missing PDF path argument"}), file=sys.stderr)
        sys.exit(1)

    pdf_path = sys.argv[1]

    try:
        parser = PricesPDFParser(pdf_path)
        prices = parser.parse()

        # Output as JSON array (compact for performance)
        output = [asdict(p) for p in prices]
        print(json.dumps(output, ensure_ascii=False))

    except FileNotFoundError:
        print(json.dumps({"error": f"PDF file not found: {pdf_path}"}), file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**Key Features:**
- **3-page cycle parsing** (verified structure)
- **IMPORTO UNITARIO** as main price field (pagina 3)
- **Keep Italian format:** Prices stored as strings "1.234,56 €" (no conversion)
- Streaming extraction (one page at a time) for RAM optimization
- Garbage filtering: Exclude records with ID="0" or empty
- Resilient parsing: Continue on error (log warning)
- Clean error handling with exit codes

**Acceptance Criteria:**
- [ ] Python script parses 3 pages per price record
- [ ] IMPORTO UNITARIO extracted from pagina 3 as string
- [ ] Italian format preserved: "1.234,56 €" (no conversion to float)
- [ ] ITEM SELECTION captured (K2, K3, etc.)
- [ ] Garbage records filtered (ID = "0")
- [ ] Outputs valid JSON array to stdout
- [ ] Handles ~4,540 records in <20s
- [ ] RAM usage stays under 100MB during parsing

**Commit:** `feat(20-01): create Python PDF parser for prices (3-page cycles, Italian format preserved)`

---

### Task 2: Create Node.js Wrapper Service
**Duration:** 15min
**Type:** auto

Create `archibald-web-app/backend/src/pdf-parser-prices-service.ts` following Phase 18/19 spawn pattern.

**Implementation:**

```typescript
import { spawn } from 'child_process';
import path from 'path';
import { logger } from './logger';

/**
 * Parsed price record from PDF (matches Python parser output)
 * 3-page cycle structure
 */
export interface ParsedPrice {
  // Page 1: Identificazione
  product_id: string;
  item_selection?: string | null;  // K2, K3, etc.
  account_code?: string | null;
  account_description?: string | null;

  // Page 2: Descrizione
  product_name?: string | null;
  price_valid_from?: string | null;
  price_valid_to?: string | null;
  quantity_from?: string | null;
  quantity_to?: string | null;

  // Page 3: Prezzi (KEY PAGE)
  unit_price?: string | null;  // IMPORTO UNITARIO (Italian format: "1.234,56 €")
  currency?: string | null;
  price_unit?: string | null;
  net_price_brasseler?: string | null;  // PREZZO NETTO (Italian format)
}

/**
 * Service for parsing price PDF exports via Python script
 * Follows Phase 18/19 pattern: child_process.spawn with 20MB buffer
 * Handles 3-page cycles per product
 */
export class PDFParserPricesService {
  private static instance: PDFParserPricesService;
  private parserPath: string;
  private timeout: number = 30000; // 30s for ~4,540 prices

  private constructor() {
    // Path relative to backend root
    this.parserPath = path.join(__dirname, '../../../scripts/parse-prices-pdf.py');
  }

  static getInstance(): PDFParserPricesService {
    if (!PDFParserPricesService.instance) {
      PDFParserPricesService.instance = new PDFParserPricesService();
    }
    return PDFParserPricesService.instance;
  }

  /**
   * Parse prices PDF and return structured data
   *
   * @param pdfPath Absolute path to PDF file
   * @returns Array of parsed price records
   * @throws Error if Python not found, parser fails, or timeout
   */
  async parsePDF(pdfPath: string): Promise<ParsedPrice[]> {
    const startTime = Date.now();

    return new Promise((resolve, reject) => {
      // Spawn Python process (NOT exec - better for large output)
      const python = spawn('python3', [this.parserPath, pdfPath], {
        timeout: this.timeout,
        maxBuffer: 20 * 1024 * 1024, // 20MB buffer for large JSON output
      });

      let stdout = '';
      let stderr = '';

      // Collect stdout data
      python.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      // Collect stderr data (warnings/errors)
      python.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      // Handle process completion
      python.on('close', (code) => {
        const duration = Date.now() - startTime;

        if (code === 0) {
          try {
            const prices = JSON.parse(stdout) as ParsedPrice[];
            logger.info(`[PDFParserPricesService] Parsed ${prices.length} prices in ${duration}ms (3-page cycles)`);
            resolve(prices);
          } catch (error) {
            logger.error('[PDFParserPricesService] JSON parse error', {
              error,
              stdout: stdout.slice(0, 500),
              stderr
            });
            reject(new Error(`Failed to parse JSON output: ${error}`));
          }
        } else {
          logger.error('[PDFParserPricesService] Python script failed', {
            code,
            stderr,
            duration
          });
          reject(new Error(`Python script exited with code ${code}: ${stderr}`));
        }
      });

      // Handle spawn errors
      python.on('error', (error) => {
        logger.error('[PDFParserPricesService] Spawn error', { error });
        reject(new Error(`Failed to spawn Python process: ${error.message}`));
      });

      // Handle timeout
      python.on('exit', (code, signal) => {
        if (signal === 'SIGTERM') {
          const duration = Date.now() - startTime;
          logger.error('[PDFParserPricesService] Process timeout', { duration });
          reject(new Error(`PDF parsing timeout after ${duration}ms`));
        }
      });
    });
  }

  /**
   * Health check: verify Python3 and PyPDF2 are available
   * Matches Phase 18/19 pattern
   */
  async healthCheck(): Promise<{
    healthy: boolean;
    pythonVersion?: string;
    pyPDF2Available?: boolean;
    error?: string
  }> {
    try {
      // Check Python version
      const pythonVersion = await new Promise<string>((resolve, reject) => {
        const python = spawn('python3', ['--version']);
        let output = '';

        python.stdout.on('data', (data) => output += data.toString());
        python.stderr.on('data', (data) => output += data.toString());

        python.on('close', (code) => {
          if (code === 0) {
            resolve(output.trim());
          } else {
            reject(new Error(`Python check failed with code ${code}`));
          }
        });
      });

      // Check PyPDF2 library
      const pyPDF2Check = await new Promise<boolean>((resolve) => {
        const python = spawn('python3', ['-c', 'import PyPDF2; print("OK")']);
        let output = '';

        python.stdout.on('data', (data) => output += data.toString());

        python.on('close', (code) => {
          resolve(code === 0 && output.includes('OK'));
        });
      });

      logger.info('[PDFParserPricesService] Health check passed', {
        pythonVersion,
        pyPDF2Available: pyPDF2Check
      });

      return {
        healthy: pyPDF2Check,
        pythonVersion,
        pyPDF2Available: pyPDF2Check,
      };
    } catch (error) {
      logger.error('[PDFParserPricesService] Health check failed', { error });
      return {
        healthy: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
```

**Key Features:**
- Uses `child_process.spawn` (NOT exec) for large output handling
- 20MB buffer for ~4,540 price records (3-page cycles)
- 30s timeout protection
- Type-safe ParsedPrice interface (prices as strings, Italian format preserved)
- Health check for Python3 + PyPDF2
- Structured logging with duration tracking
- Follows Phase 18/19 singleton pattern

**Acceptance Criteria:**
- [ ] Node.js wrapper spawns Python script correctly
- [ ] Parses large JSON output (20MB buffer)
- [ ] 30s timeout protection active
- [ ] Type-safe ParsedPrice interface
- [ ] Health check validates Python3 + PyPDF2
- [ ] Singleton pattern implemented
- [ ] Logs 3-page cycle parsing

**Commit:** `feat(20-01): create Node.js wrapper for prices PDF parser (3-page cycles)`

---

### Task 3: Add Health Check Endpoint
**Duration:** 5min
**Type:** auto

Add health check route in `archibald-web-app/backend/src/index.ts`.

**Implementation:**

```typescript
import { PDFParserPricesService } from './pdf-parser-prices-service';

// ... existing code ...

// Health check for prices PDF parser (3-page cycles)
app.get("/api/health/pdf-parser-prices", async (req, res) => {
  try {
    const service = PDFParserPricesService.getInstance();
    const health = await service.healthCheck();

    if (health.healthy) {
      res.status(200).json({
        status: 'ok',
        message: 'Prices PDF parser ready (Python3 + PyPDF2 available, 3-page cycles)',
        ...health
      });
    } else {
      res.status(503).json({
        status: 'unavailable',
        message: 'Prices PDF parser not ready. Check logs for details.',
        ...health
      }); // Service Unavailable
    }
  } catch (error) {
    logger.error("[Health] Prices PDF parser check failed", { error });
    res.status(500).json({
      status: 'error',
      healthy: false,
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
```

**Acceptance Criteria:**
- [ ] GET /api/health/pdf-parser-prices returns 200/503/500
- [ ] Logs Python version and PyPDF2 status
- [ ] Message mentions "3-page cycles"
- [ ] Matches Phase 18/19 health check pattern
- [ ] Can be used for deployment verification

**Commit:** `feat(20-01): add health check endpoint for prices PDF parser`

---

### Task 4: Create Test Script
**Duration:** 5min
**Type:** checkpoint:human-verify

Create `archibald-web-app/backend/src/test-prices-pdf-parser.ts` for manual validation.

**Implementation:**

```typescript
import { PDFParserPricesService } from './pdf-parser-prices-service';
import { logger } from './logger';

async function testPricesPDFParser() {
  logger.info('=== Prices PDF Parser Test (3-Page Cycles) ===');

  const service = PDFParserPricesService.getInstance();

  // 1. Health check
  logger.info('Running health check...');
  const health = await service.healthCheck();
  if (!health.healthy) {
    logger.error('❌ Health check failed', health);
    process.exit(1);
  }
  logger.info('✓ Health check passed', health);

  // 2. Parse PDF
  const pdfPath = process.env.PRICES_PDF_PATH || '/tmp/prezzi-test.pdf';
  logger.info(`Parsing PDF: ${pdfPath}`);

  const startTime = Date.now();
  const prices = await service.parsePDF(pdfPath);
  const duration = Date.now() - startTime;

  logger.info(`✓ Parsed ${prices.length} prices in ${duration}ms`);
  logger.info(`  Structure: 3-page cycles (${prices.length * 3} pages total)`);

  // 3. Validate results
  if (prices.length < 4000 || prices.length > 5000) {
    logger.warn(`⚠️  Price count unexpected: ${prices.length} (expected ~4,540)`);
  }

  // 4. Sample price
  const sample = prices[0];
  logger.info('Sample price (first record):', {
    product_id: sample.product_id,
    item_selection: sample.item_selection,
    product_name: sample.product_name,
    unit_price: sample.unit_price,
    currency: sample.currency,
    price_unit: sample.price_unit
  });

  // 5. Italian format check (prices kept as strings)
  const pricesWithCurrency = prices.filter(p => p.unit_price !== null && p.unit_price !== undefined);
  logger.info(`Prices with valid unit_price: ${pricesWithCurrency.length}/${prices.length}`);

  if (pricesWithCurrency.length > 0) {
    // Sample prices to show Italian format preserved
    const samplePrices = pricesWithCurrency.slice(0, 5).map(p => p.unit_price);
    logger.info(`Sample prices (Italian format): ${samplePrices.join(', ')}`);
  }

  // 6. Variant identification check (ITEM SELECTION)
  const pricesWithVariants = prices.filter(p => p.item_selection);
  logger.info(`Prices with item_selection: ${pricesWithVariants.length}/${prices.length}`);

  // Sample variants
  const variantSamples = pricesWithVariants.slice(0, 5).map(p => p.item_selection);
  logger.info(`Sample item selections: ${variantSamples.join(', ')}`);

  // 7. Field coverage
  const fields = Object.keys(sample);
  logger.info(`Fields per price: ${fields.length}`);

  // 8. 3-page cycle validation
  logger.info('✓ Cycle structure: 3 pages per product (VERIFIED)');
  logger.info('  Page 1: ID, ITEM SELECTION, Account info');
  logger.info('  Page 2: ITEM DESCRIPTION, validity dates');
  logger.info('  Page 3: IMPORTO UNITARIO (key field), VALUTA, UNITÀ DI PREZZO');

  logger.info('=== Test Complete ===');
}

testPricesPDFParser().catch((error) => {
  logger.error('❌ Test failed', { error });
  process.exit(1);
});
```

**Manual Validation Steps:**

1. **Build backend:**
   ```bash
   cd archibald-web-app/backend
   npm run build
   ```

2. **Run test script:**
   ```bash
   PRICES_PDF_PATH=/path/to/test-prezzi.pdf node dist/test-prices-pdf-parser.js
   ```

3. **Expected output:**
   - ✓ Health check passed (Python + PyPDF2)
   - ✓ Parsed ~4,540 prices in <20s
   - ✓ Structure: 3-page cycles
   - ✓ Sample price shows all fields
   - ✓ Italian currency correctly converted (e.g., "1.234,56" → 1234.56)
   - ✓ Item selection populated (K2, K3, etc.)
   - ✓ No errors

4. **Validate Italian format preserved:**
   ```bash
   python3 scripts/parse-prices-pdf.py /path/to/test.pdf | jq '.[0].unit_price'
   # Should show string: "10,50 €" (Italian format preserved)
   ```

5. **Validate 3-page cycles:**
   - Check PDF page count: `pdfinfo /path/to/test.pdf | grep Pages`
   - Should be divisible by 3
   - Example: 13,620 pages = 4,540 products × 3 pages

**Acceptance Criteria:**
- [ ] Test script validates health check
- [ ] Parses test PDF successfully
- [ ] Verifies price count (~4,540)
- [ ] Validates Italian format preserved (strings, not floats)
- [ ] Checks variant identification (ITEM SELECTION)
- [ ] Confirms 3-page cycle structure
- [ ] Exit code 0 on success

**Commit:** `test(20-01): add test script for prices PDF parser (3-page cycles)`

---

## Verification

### Success Criteria

- [ ] Python parser extracts all price fields from **3-page cycles**
- [ ] IMPORTO UNITARIO (pagina 3) parsed as main price field (string)
- [ ] Italian format preserved: "1.234,56 €" (NOT converted to float)
- [ ] ITEM SELECTION captured for variant matching
- [ ] Garbage records filtered (ID="0" excluded)
- [ ] Node.js wrapper handles large JSON output (20MB buffer)
- [ ] 30s timeout protection active
- [ ] Health check endpoint confirms Python + PyPDF2 availability
- [ ] Test script validates end-to-end flow
- [ ] ~4,540 prices parsed in <20s
- [ ] RAM usage under 100MB during parsing
- [ ] All commits atomic with proper messages

### Test Commands

```bash
# Python parser test (direct)
python3 scripts/parse-prices-pdf.py /path/to/prezzi.pdf | jq 'length'
# Expected: ~4,540

# Verify 3-page cycle structure
python3 scripts/parse-prices-pdf.py /path/to/prezzi.pdf | jq '.[0]'
# Should show all fields from 3 pages

# Node.js wrapper test
cd archibald-web-app/backend && npm run build
PRICES_PDF_PATH=/path/to/prezzi.pdf node dist/test-prices-pdf-parser.js

# Health check test
curl http://localhost:3000/api/health/pdf-parser-prices

# Italian format validation (preserved as string)
python3 scripts/parse-prices-pdf.py /path/to/prezzi.pdf | jq '.[0].unit_price'
# Should be string: "1.234,56 €"
```

### Performance Target

- Parse ~4,540 records in <20s (Python execution)
- Node.js wrapper overhead <1s
- Total: ~21s maximum for 3-page parsing
- RAM usage: <100MB peak

## Output

**Files Created:**
1. `scripts/parse-prices-pdf.py` - Python PDF parser with 3-page cycles & Italian locale
2. `archibald-web-app/backend/src/pdf-parser-prices-service.ts` - Node wrapper
3. `archibald-web-app/backend/src/test-prices-pdf-parser.ts` - Test script
4. `.planning/phases/20-prices-sync-analysis-optimization/PDF-STRUCTURE.md` - Verified structure doc

**Files Modified:**
1. `archibald-web-app/backend/src/index.ts` - Health check endpoint

**Commits:** 4 atomic commits

**Next:** Plan 20-02 (PDF Download Bot Flow & Separate Prices Database)

---

## Notes

**Critical Change from Original Plan:**
- ❌ **OLD:** 8-page cycles (incorrect assumption)
- ✅ **NEW:** 3-page cycles (user-verified structure)

**Pattern Reuse from Phase 18/19:**
- ✅ Multi-page cycle parsing (adapted from 8 to 3)
- ✅ child_process.spawn (NOT exec)
- ✅ 20MB buffer for large output
- ✅ 30s timeout protection
- ✅ Garbage filtering (ID="0")
- ✅ Health check endpoint
- ✅ Singleton pattern
- ✅ Structured logging

**Italian Format Handling:**
- ✅ Prices kept as strings: "1.234,56 €" (NO conversion)
- ✅ Format preserved exactly as in PDF
- ✅ Database will store strings, UI will display as-is
- ✅ Conversion to float only if needed for calculations (future)

**Variant Identification:**
- item_selection field identifies packaging type
- Examples: "K2" = 5 colli, "K3" = 1 collo
- Critical for matching prices to correct product variants in Plan 20-03

**3-Page Cycle Structure (VERIFIED):**
```
Product 1: Pages 0-2 (ID, Description, Price)
Product 2: Pages 3-5 (ID, Description, Price)
Product 3: Pages 6-8 (ID, Description, Price)
...
Product N: Pages (N-1)*3 to N*3-1
```

**Total pages = Products × 3**
Example: 4,540 products = 13,620 pages
