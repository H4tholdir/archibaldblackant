---
phase: 20-prices-sync-analysis-optimization
plan: 02
title: PDF Download Bot Flow & Separate Prices Database
subsystem: sync
complexity: medium
estimated_duration: 45min
tags: [bot, pdf-download, database, prices-db, delta-sync, hash-detection]
---

# Plan 20-02: PDF Download Bot Flow & Separate Prices Database

## Objective

Migrate prices sync from HTML scraping to PDF download via bot, create separate `prices.db` database with proper schema, implement delta hash detection, and refactor PriceSyncService to use PDF parser instead of page scraping.

## Execution Context

**Phase 18/19 Proven Patterns:**
- Bot PDF download flow with `/tmp` file management
- Separate database per entity (customers.db, products.db → prices.db)
- MD5 hash delta detection to avoid unnecessary updates
- SyncCheckpointManager for resume capability
- Health check integration

**User Requirements (from 20-CONTEXT.md):**
- PDF download from Archibald "Prezzi" menu
- Separate `prices.db` database (NOT mixed with products.db)
- Delta sync using MD5 hash (only update changed prices)
- Manual sync only (no automatic scheduler yet - Phase 22)
- Reuse bot patterns from Phase 18/19

**Current State:**
- `PriceSyncService` exists but uses HTML scraping
- No separate prices.db database
- Prices currently stored in products.db table
- No delta detection implemented

**Key Files:**
- Reference: `archibald-web-app/backend/src/customer-sync-service.ts` (Phase 18-02)
- Reference: `archibald-web-app/backend/src/product-sync-service.ts` (Phase 19-02)
- Reference: `archibald-web-app/backend/src/pdf-parser-prices-service.ts` (Plan 20-01)
- Target: `archibald-web-app/backend/src/price-sync-service.ts` (refactor)
- Target: `archibald-web-app/backend/src/price-db.ts` (new)

## Context

**Dependencies:**
- Plan 20-01 complete (PDF parser ready)
- Phase 18-02 pattern (bot PDF download)
- Phase 19-02 pattern (product sync refactor)

**Database Strategy:**
Per user requirements:
- Separate `prices.db` in `archibald-web-app/backend/data/prices.db`
- Schema matches ParsedPrice interface from Plan 20-01
- Hash field for MD5 delta detection
- Foreign key to products.db via product_id

**Bot Flow:**
1. Navigate to https://4.231.124.90/Archibald/INVENTTABLE_ListView/
2. Force Italian locale (same as Phase 18/19)
3. Click "Esportare in PDF File" button
4. Wait for download to `/tmp/prezzi-{timestamp}.pdf`
5. Pass PDF path to PDFParserPricesService
6. Update prices.db with delta detection

## Tasks

### Task 1: Create Separate Prices Database Schema
**Duration:** 15min
**Type:** auto

Create `archibald-web-app/backend/src/price-db.ts` with full schema.

**Implementation:**

```typescript
import Database from 'better-sqlite3';
import path from 'path';
import { logger } from './logger';
import crypto from 'crypto';

/**
 * Price record in database
 * Matches ParsedPrice from PDF parser with additional metadata
 */
export interface Price {
  // Core identification
  id: number; // Auto-increment primary key
  productId: string; // ID ARTICOLO (matches Product.id in products.db)
  productName: string; // NOME ARTICOLO

  // Price data (Italian format preserved)
  unitPrice: string | null; // IMPORTO UNITARIO (Italian format: "1.234,56 €")

  // Variant identification (critical for matching)
  itemSelection: string | null; // K2, K3, etc. (packaging type)
  packagingDescription: string | null;

  // Additional metadata
  currency: string | null;
  priceValidFrom: string | null;
  priceValidTo: string | null;
  priceUnit: string | null;
  accountDescription: string | null;
  accountCode: string | null;
  priceQtyFrom: number | null;
  priceQtyTo: number | null;

  // System fields
  lastModified: string | null;
  dataAreaId: string | null;

  // Delta detection
  hash: string; // MD5 hash of key fields for change detection
  lastSync: number; // Unix timestamp of last sync

  // Metadata
  createdAt: number; // Unix timestamp
  updatedAt: number; // Unix timestamp
}

/**
 * Price database manager - separate database for prices
 * Follows Phase 18/19 pattern: separate DB per entity
 */
export class PriceDatabase {
  private static instance: PriceDatabase;
  private db: Database.Database;

  private constructor(dbPath?: string) {
    const finalPath = dbPath || path.join(__dirname, '../data/prices.db');
    this.db = new Database(finalPath);
    this.initSchema();
    logger.info(`[PriceDatabase] Initialized at ${finalPath}`);
  }

  static getInstance(dbPath?: string): PriceDatabase {
    if (!PriceDatabase.instance) {
      PriceDatabase.instance = new PriceDatabase(dbPath);
    }
    return PriceDatabase.instance;
  }

  /**
   * Initialize database schema
   * Creates prices table and indexes
   */
  private initSchema(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS prices (
        id INTEGER PRIMARY KEY AUTOINCREMENT,

        -- Core identification
        productId TEXT NOT NULL,
        productName TEXT NOT NULL,

        -- Price data (Italian format preserved as TEXT)
        unitPrice TEXT,

        -- Variant identification
        itemSelection TEXT,
        packagingDescription TEXT,

        -- Additional metadata
        currency TEXT,
        priceValidFrom TEXT,
        priceValidTo TEXT,
        priceUnit TEXT,
        accountDescription TEXT,
        accountCode TEXT,
        priceQtyFrom INTEGER,
        priceQtyTo INTEGER,

        -- System fields
        lastModified TEXT,
        dataAreaId TEXT,

        -- Delta detection
        hash TEXT NOT NULL UNIQUE,
        lastSync INTEGER NOT NULL,

        -- Metadata
        createdAt INTEGER NOT NULL,
        updatedAt INTEGER NOT NULL
      );

      -- Indexes for fast lookups
      CREATE INDEX IF NOT EXISTS idx_prices_productId ON prices(productId);
      CREATE INDEX IF NOT EXISTS idx_prices_itemSelection ON prices(itemSelection);
      CREATE INDEX IF NOT EXISTS idx_prices_hash ON prices(hash);
      CREATE INDEX IF NOT EXISTS idx_prices_lastSync ON prices(lastSync);

      -- Compound index for variant matching
      CREATE INDEX IF NOT EXISTS idx_prices_product_variant
        ON prices(productId, itemSelection);
    `);

    logger.info('[PriceDatabase] Schema initialized');
  }

  /**
   * Calculate MD5 hash for price record
   * Used for delta detection - only key fields included
   */
  private calculateHash(price: Partial<Price>): string {
    const hashInput = [
      price.productId,
      price.productName,
      price.unitPrice?.toString() || '',
      price.itemSelection || '',
      price.currency || '',
      price.priceValidFrom || '',
      price.priceValidTo || '',
    ].join('|');

    return crypto.createHash('md5').update(hashInput).digest('hex');
  }

  /**
   * Upsert price record with delta detection
   * Only updates if hash changed (following Phase 18/19 pattern)
   *
   * @returns 'inserted' | 'updated' | 'skipped'
   */
  upsertPrice(priceData: Omit<Price, 'id' | 'hash' | 'createdAt' | 'updatedAt'>): 'inserted' | 'updated' | 'skipped' {
    const hash = this.calculateHash(priceData);
    const now = Math.floor(Date.now() / 1000);

    // Check if price exists with same hash
    const existing = this.db
      .prepare('SELECT id, hash FROM prices WHERE productId = ? AND itemSelection = ?')
      .get(priceData.productId, priceData.itemSelection || null) as { id: number; hash: string } | undefined;

    if (existing) {
      if (existing.hash === hash) {
        // No changes - skip update
        return 'skipped';
      }

      // Hash changed - update
      this.db
        .prepare(`
          UPDATE prices SET
            productName = ?,
            unitPrice = ?,
            packagingDescription = ?,
            currency = ?,
            priceValidFrom = ?,
            priceValidTo = ?,
            priceUnit = ?,
            accountDescription = ?,
            accountCode = ?,
            priceQtyFrom = ?,
            priceQtyTo = ?,
            lastModified = ?,
            dataAreaId = ?,
            hash = ?,
            lastSync = ?,
            updatedAt = ?
          WHERE id = ?
        `)
        .run(
          priceData.productName,
          priceData.unitPrice,
          priceData.packagingDescription,
          priceData.currency,
          priceData.priceValidFrom,
          priceData.priceValidTo,
          priceData.priceUnit,
          priceData.accountDescription,
          priceData.accountCode,
          priceData.priceQtyFrom,
          priceData.priceQtyTo,
          priceData.lastModified,
          priceData.dataAreaId,
          hash,
          priceData.lastSync,
          now,
          existing.id
        );

      return 'updated';
    }

    // New price - insert
    this.db
      .prepare(`
        INSERT INTO prices (
          productId, productName, unitPrice, itemSelection, packagingDescription,
          currency, priceValidFrom, priceValidTo, priceUnit,
          accountDescription, accountCode, priceQtyFrom, priceQtyTo,
          lastModified, dataAreaId, hash, lastSync, createdAt, updatedAt
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `)
      .run(
        priceData.productId,
        priceData.productName,
        priceData.unitPrice,
        priceData.itemSelection,
        priceData.packagingDescription,
        priceData.currency,
        priceData.priceValidFrom,
        priceData.priceValidTo,
        priceData.priceUnit,
        priceData.accountDescription,
        priceData.accountCode,
        priceData.priceQtyFrom,
        priceData.priceQtyTo,
        priceData.lastModified,
        priceData.dataAreaId,
        hash,
        priceData.lastSync,
        now,
        now
      );

    return 'inserted';
  }

  /**
   * Get price for specific product and variant
   * Used for matching with products.db
   */
  getPrice(productId: string, itemSelection: string | null): Price | undefined {
    return this.db
      .prepare('SELECT * FROM prices WHERE productId = ? AND itemSelection = ?')
      .get(productId, itemSelection || null) as Price | undefined;
  }

  /**
   * Get all prices for a product (all variants)
   */
  getPricesByProductId(productId: string): Price[] {
    return this.db
      .prepare('SELECT * FROM prices WHERE productId = ? ORDER BY itemSelection')
      .all(productId) as Price[];
  }

  /**
   * Get total count of prices
   */
  getTotalCount(): number {
    const result = this.db
      .prepare('SELECT COUNT(*) as count FROM prices')
      .get() as { count: number };
    return result.count;
  }

  /**
   * Get sync statistics
   */
  getSyncStats(): {
    totalPrices: number;
    lastSyncTimestamp: number | null;
    pricesWithNullPrice: number;
  } {
    const total = this.getTotalCount();

    const lastSyncResult = this.db
      .prepare('SELECT MAX(lastSync) as lastSync FROM prices')
      .get() as { lastSync: number | null };

    const nullPriceResult = this.db
      .prepare('SELECT COUNT(*) as count FROM prices WHERE unitPrice IS NULL')
      .get() as { count: number };

    return {
      totalPrices: total,
      lastSyncTimestamp: lastSyncResult.lastSync,
      pricesWithNullPrice: nullPriceResult.count,
    };
  }

  /**
   * Close database connection
   */
  close(): void {
    this.db.close();
    logger.info('[PriceDatabase] Database closed');
  }
}
```

**Key Features:**
- Separate `prices.db` database
- Schema matches ParsedPrice from Plan 20-01
- MD5 hash delta detection (only key fields)
- Indexes for fast lookups (productId, itemSelection, compound)
- Upsert logic: insert/update/skip based on hash
- Sync statistics for monitoring

**Acceptance Criteria:**
- [ ] Separate prices.db created in data/ directory
- [ ] Schema matches ParsedPrice interface
- [ ] MD5 hash delta detection working
- [ ] Indexes created for performance
- [ ] Upsert returns 'inserted' | 'updated' | 'skipped'
- [ ] Singleton pattern implemented

**Commit:** `feat(20-02): create separate prices database with delta detection`

---

### Task 2: Refactor PriceSyncService to Use PDF Download
**Duration:** 20min
**Type:** auto

Refactor existing `archibald-web-app/backend/src/price-sync-service.ts` to use bot PDF download instead of HTML scraping.

**Implementation:**

```typescript
import { EventEmitter } from 'events';
import { BrowserPool } from './browser-pool';
import { logger } from './logger';
import { SyncCheckpointManager } from './sync-checkpoint';
import { PDFParserPricesService, ParsedPrice } from './pdf-parser-prices-service';
import { PriceDatabase } from './price-db';
import * as fs from 'fs/promises';
import * as path from 'path';

export interface PriceSyncProgress {
  status: 'idle' | 'downloading' | 'parsing' | 'saving' | 'completed' | 'error';
  message: string;
  pricesProcessed: number;
  pricesInserted: number;
  pricesUpdated: number;
  pricesSkipped: number;
  error?: string;
}

/**
 * Price Sync Service - PDF-based sync
 * Follows Phase 18/19 pattern: bot download → PDF parse → delta save
 */
export class PriceSyncService extends EventEmitter {
  private static instance: PriceSyncService;
  private browserPool: BrowserPool;
  private pdfParser: PDFParserPricesService;
  private priceDb: PriceDatabase;
  private checkpointManager: SyncCheckpointManager;
  private syncInProgress = false;
  private paused = false;
  private progress: PriceSyncProgress = {
    status: 'idle',
    message: 'Nessuna sincronizzazione prezzi in corso',
    pricesProcessed: 0,
    pricesInserted: 0,
    pricesUpdated: 0,
    pricesSkipped: 0,
  };

  private constructor() {
    super();
    this.browserPool = BrowserPool.getInstance();
    this.pdfParser = PDFParserPricesService.getInstance();
    this.priceDb = PriceDatabase.getInstance();
    this.checkpointManager = SyncCheckpointManager.getInstance();
  }

  static getInstance(): PriceSyncService {
    if (!PriceSyncService.instance) {
      PriceSyncService.instance = new PriceSyncService();
    }
    return PriceSyncService.instance;
  }

  /**
   * Pause sync service (for PriorityManager)
   */
  async pause(): Promise<void> {
    logger.info('[PriceSyncService] Pause requested');
    this.paused = true;

    if (this.syncInProgress) {
      logger.info('[PriceSyncService] Waiting for current sync to complete...');
      while (this.syncInProgress) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }

    logger.info('[PriceSyncService] Paused');
  }

  /**
   * Resume sync service
   */
  resume(): void {
    logger.info('[PriceSyncService] Resumed');
    this.paused = false;
  }

  /**
   * Get current sync progress
   */
  getProgress(): PriceSyncProgress {
    return { ...this.progress };
  }

  /**
   * Main sync method: Download PDF → Parse → Save with delta detection
   * Follows Phase 18/19 pattern
   */
  async syncPrices(): Promise<void> {
    if (this.syncInProgress) {
      throw new Error('Sync already in progress');
    }

    if (this.paused) {
      throw new Error('Sync service is paused');
    }

    this.syncInProgress = true;
    const startTime = Date.now();

    try {
      // Reset progress
      this.progress = {
        status: 'downloading',
        message: 'Scaricamento PDF prezzi da Archibald...',
        pricesProcessed: 0,
        pricesInserted: 0,
        pricesUpdated: 0,
        pricesSkipped: 0,
      };
      this.emit('progress', this.progress);

      // Step 1: Download PDF via bot
      const pdfPath = await this.downloadPricesPDF();
      logger.info(`[PriceSyncService] PDF downloaded to ${pdfPath}`);

      // Step 2: Parse PDF
      this.progress = {
        ...this.progress,
        status: 'parsing',
        message: 'Estrazione dati PDF...',
      };
      this.emit('progress', this.progress);

      const parsedPrices = await this.pdfParser.parsePDF(pdfPath);
      logger.info(`[PriceSyncService] Parsed ${parsedPrices.length} prices from PDF`);

      // Step 3: Save with delta detection
      this.progress = {
        ...this.progress,
        status: 'saving',
        message: `Salvataggio ${parsedPrices.length} prezzi...`,
      };
      this.emit('progress', this.progress);

      const saveResults = await this.savePrices(parsedPrices);

      // Step 4: Cleanup PDF
      await fs.unlink(pdfPath).catch((err) => {
        logger.warn(`[PriceSyncService] Failed to delete PDF ${pdfPath}:`, err);
      });

      // Complete
      const duration = Math.floor((Date.now() - startTime) / 1000);
      this.progress = {
        ...this.progress,
        status: 'completed',
        message: `✓ Sync completato in ${duration}s`,
        ...saveResults,
      };
      this.emit('progress', this.progress);

      logger.info('[PriceSyncService] Sync completed', {
        duration,
        ...saveResults,
      });

    } catch (error) {
      const duration = Math.floor((Date.now() - startTime) / 1000);
      logger.error('[PriceSyncService] Sync failed', { error, duration });

      this.progress = {
        ...this.progress,
        status: 'error',
        message: `❌ Errore sync: ${error instanceof Error ? error.message : String(error)}`,
        error: error instanceof Error ? error.message : String(error),
      };
      this.emit('progress', this.progress);

      throw error;
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Download prices PDF via bot
   * Follows Phase 18/19 bot pattern with Italian locale forcing
   */
  private async downloadPricesPDF(): Promise<string> {
    const browser = await this.browserPool.acquire('price-sync');

    try {
      const page = await browser.newPage();

      // Set Italian locale (following Phase 18/19 pattern)
      await page.setExtraHTTPHeaders({
        'Accept-Language': 'it-IT,it;q=0.9',
      });

      // Navigate to products list page
      await page.goto('https://4.231.124.90/Archibald/INVENTTABLE_ListView/', {
        waitUntil: 'networkidle0',
        timeout: 60000,
      });

      logger.info('[PriceSyncService] Navigated to products page');

      // Wait for page to load
      await page.waitForSelector('body', { timeout: 10000 });

      // Setup download handling
      const downloadPath = path.join('/tmp', `prezzi-${Date.now()}.pdf`);
      const client = await page.target().createCDPSession();
      await client.send('Page.setDownloadBehavior', {
        behavior: 'allow',
        downloadPath: '/tmp',
      });

      // Click "Esportare in PDF File" button
      // NOTE: Exact selector needs verification with real page
      // This is a placeholder - adjust based on actual page structure
      await page.evaluate(() => {
        const buttons = Array.from(document.querySelectorAll('button, a'));
        const pdfButton = buttons.find((btn) =>
          btn.textContent?.includes('Esportare in PDF')
        );
        if (pdfButton) {
          (pdfButton as HTMLElement).click();
        } else {
          throw new Error('PDF export button not found');
        }
      });

      logger.info('[PriceSyncService] Clicked PDF export button');

      // Wait for download to complete (max 60s)
      const maxWait = 60000;
      const startWait = Date.now();

      while (Date.now() - startWait < maxWait) {
        const files = await fs.readdir('/tmp');
        const pdfFile = files.find((f) => f.startsWith('prezzi-') && f.endsWith('.pdf'));

        if (pdfFile) {
          const fullPath = path.join('/tmp', pdfFile);
          logger.info(`[PriceSyncService] PDF download complete: ${fullPath}`);
          return fullPath;
        }

        await new Promise((resolve) => setTimeout(resolve, 1000));
      }

      throw new Error('PDF download timeout (60s)');

    } finally {
      await this.browserPool.release(browser);
    }
  }

  /**
   * Save prices to database with delta detection
   * Returns statistics: inserted, updated, skipped
   */
  private async savePrices(parsedPrices: ParsedPrice[]): Promise<{
    pricesProcessed: number;
    pricesInserted: number;
    pricesUpdated: number;
    pricesSkipped: number;
  }> {
    const now = Math.floor(Date.now() / 1000);
    let inserted = 0;
    let updated = 0;
    let skipped = 0;

    for (const parsedPrice of parsedPrices) {
      // Map ParsedPrice to Price schema
      const priceData = {
        productId: parsedPrice.product_id,
        productName: parsedPrice.product_name,
        unitPrice: parsedPrice.unit_price ?? null,
        itemSelection: parsedPrice.item_selection ?? null,
        packagingDescription: parsedPrice.packaging_description ?? null,
        currency: parsedPrice.currency ?? null,
        priceValidFrom: parsedPrice.price_valid_from ?? null,
        priceValidTo: parsedPrice.price_valid_to ?? null,
        priceUnit: parsedPrice.price_unit ?? null,
        accountDescription: parsedPrice.account_description ?? null,
        accountCode: parsedPrice.account_code ?? null,
        priceQtyFrom: parsedPrice.price_qty_from ?? null,
        priceQtyTo: parsedPrice.price_qty_to ?? null,
        lastModified: parsedPrice.last_modified ?? null,
        dataAreaId: parsedPrice.data_area_id ?? null,
        lastSync: now,
      };

      // Upsert with delta detection
      const result = this.priceDb.upsertPrice(priceData);

      if (result === 'inserted') inserted++;
      else if (result === 'updated') updated++;
      else if (result === 'skipped') skipped++;
    }

    return {
      pricesProcessed: parsedPrices.length,
      pricesInserted: inserted,
      pricesUpdated: updated,
      pricesSkipped: skipped,
    };
  }
}
```

**Key Changes:**
- ✅ Removed HTML scraping logic
- ✅ Added PDF download via bot
- ✅ Italian locale forcing (Accept-Language header)
- ✅ PDF parser integration
- ✅ Delta detection via PriceDatabase
- ✅ Progress tracking with detailed stats
- ✅ Cleanup downloaded PDF after sync
- ✅ Follows Phase 18/19 pattern exactly

**Acceptance Criteria:**
- [ ] Bot downloads PDF from Archibald
- [ ] Italian locale forced (Accept-Language: it-IT)
- [ ] PDF parsed via PDFParserPricesService
- [ ] Prices saved with delta detection
- [ ] Progress events emitted
- [ ] PDF cleaned up after sync
- [ ] Statistics tracked (inserted/updated/skipped)

**Commit:** `refactor(20-02): migrate PriceSyncService from HTML scraping to PDF download`

---

### Task 3: Add Prices Sync Metrics Endpoint
**Duration:** 5min
**Type:** auto

Add GET endpoint for sync statistics in `archibald-web-app/backend/src/index.ts`.

**Implementation:**

```typescript
import { PriceDatabase } from './price-db';

// ... existing code ...

// Get prices sync statistics
app.get("/api/prices/sync/stats", authenticateJWT, async (req, res) => {
  try {
    const priceDb = PriceDatabase.getInstance();
    const stats = priceDb.getSyncStats();

    res.json({
      success: true,
      stats: {
        totalPrices: stats.totalPrices,
        lastSyncTimestamp: stats.lastSyncTimestamp,
        lastSyncDate: stats.lastSyncTimestamp
          ? new Date(stats.lastSyncTimestamp * 1000).toISOString()
          : null,
        pricesWithNullPrice: stats.pricesWithNullPrice,
        coverage: stats.totalPrices > 0
          ? ((stats.totalPrices - stats.pricesWithNullPrice) / stats.totalPrices * 100).toFixed(2) + '%'
          : '0%',
      },
    });
  } catch (error) {
    logger.error('[API] Get prices sync stats failed', { error });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
});
```

**Acceptance Criteria:**
- [ ] GET /api/prices/sync/stats returns statistics
- [ ] JWT-protected endpoint
- [ ] Returns: totalPrices, lastSyncDate, coverage %
- [ ] Logs errors properly

**Commit:** `feat(20-02): add prices sync statistics endpoint`

---

### Task 4: Update TypeScript Configuration
**Duration:** 5min
**Type:** checkpoint:human-verify

Compile TypeScript and verify no errors.

**Validation Steps:**

```bash
cd archibald-web-app/backend
npm run build
```

**Expected Output:**
- ✅ No TypeScript compilation errors
- ✅ New files compiled: price-db.ts, updated price-sync-service.ts
- ✅ No type mismatches

**If errors:**
- Fix type mismatches between ParsedPrice and Price interfaces
- Ensure all imports are correct
- Verify singleton pattern types

**Acceptance Criteria:**
- [ ] TypeScript compiles without errors
- [ ] All new files included in build output
- [ ] No type safety warnings

**Commit:** `build(20-02): verify TypeScript compilation passes`

---

## Verification

### Success Criteria

- [ ] Separate `prices.db` database created
- [ ] PriceDatabase class with delta detection working
- [ ] PriceSyncService refactored to use PDF download
- [ ] Bot downloads PDF from Archibald with Italian locale
- [ ] PDF parser integrated correctly
- [ ] Delta detection skips unchanged prices
- [ ] Progress events emitted during sync
- [ ] Sync statistics endpoint working
- [ ] PDF cleaned up after sync
- [ ] TypeScript compiles without errors
- [ ] All commits atomic with proper messages

### Manual Test

```bash
# 1. Build backend
cd archibald-web-app/backend
npm run build

# 2. Start backend
npm run dev

# 3. Test health check
curl http://localhost:3000/api/health/pdf-parser-prices

# 4. Test sync (requires JWT token)
curl -X POST http://localhost:3000/api/prices/sync \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 5. Check sync stats
curl http://localhost:3000/api/prices/sync/stats \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 6. Verify database created
ls -lh archibald-web-app/backend/data/prices.db
sqlite3 archibald-web-app/backend/data/prices.db "SELECT COUNT(*) FROM prices;"
```

### Performance Target

- PDF download: <30s
- PDF parse: <20s (from Plan 20-01)
- Database save: <10s for ~4,540 prices
- Total sync time: <60s

### Delta Detection Test

Run sync twice:
1. First sync: Should insert ~4,540 prices
2. Second sync: Should skip ~4,540 prices (no changes)

Expected output:
```
First sync: inserted=4540, updated=0, skipped=0
Second sync: inserted=0, updated=0, skipped=4540
```

## Output

**Files Created:**
1. `archibald-web-app/backend/src/price-db.ts` - Price database manager
2. `archibald-web-app/backend/data/prices.db` - Separate prices database

**Files Modified:**
1. `archibald-web-app/backend/src/price-sync-service.ts` - Refactored to PDF
2. `archibald-web-app/backend/src/index.ts` - Stats endpoint

**Commits:** 4 atomic commits

**Next:** Plan 20-03 (Excel IVA Upload Enhancement & Price Matching)

---

## Notes

**Pattern Reuse from Phase 18/19:**
- ✅ Separate database per entity (customers.db, products.db, prices.db)
- ✅ Bot PDF download with Italian locale forcing
- ✅ MD5 hash delta detection
- ✅ Progress events for UI feedback
- ✅ SyncCheckpointManager for resume capability
- ✅ Cleanup temporary files

**Database Location:**
- `archibald-web-app/backend/data/prices.db`
- Same directory as products.db, customers.db
- Separate for clean architecture

**Bot PDF Download Notes:**
- PDF button selector is placeholder - may need adjustment based on actual page
- Italian locale forced via Accept-Language header
- Download waits max 60s (configurable if needed)
- PDF saved to /tmp with timestamp: `prezzi-{timestamp}.pdf`

**Delta Detection Benefits:**
- Avoids unnecessary database writes
- Speeds up sync significantly on subsequent runs
- Preserves price history integrity (Plan 20-04 will track changes)
