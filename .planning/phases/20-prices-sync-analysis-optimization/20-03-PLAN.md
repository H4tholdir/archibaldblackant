---
phase: 20-prices-sync-analysis-optimization
plan: 03
title: Excel IVA Upload Enhancement & Price Matching
subsystem: integration
complexity: medium
estimated_duration: 60min
tags: [excel, iva, matching, products-db, prices-db, admin-ui]
---

# Plan 20-03: Excel IVA Upload Enhancement & Price Matching

## Objective

Enhance existing Excel IVA importer to match prices from `prices.db` with products in `products.db` using multi-level matching strategy (ID ‚Üí item_selection ‚Üí name), update product price/VAT fields, and add admin UI for Excel upload.

## Execution Context

**User Requirements (from 20-CONTEXT.md):**
- Excel IVA upload in admin menu (reuse existing `ExcelVatImporter`)
- File format: `Listino_2026_vendita.xlsx` (already in root)
- Matching strategy:
  1. Match prices.db ‚Üí products.db by `productId`
  2. Match variant by `item_selection` (K2, K3, etc.)
  3. Update `products.db` fields: `price`, `vat`, `priceSource='excel'`, `vatSource='excel'`
- IVA from Excel takes priority over Archibald data
- 100% coverage expected (but handle missing gracefully with badge)

**Current State:**
- `ExcelVatImporter` exists (`archibald-web-app/backend/src/excel-vat-importer.ts`)
- Currently updates `products.db` directly from Excel
- No integration with `prices.db`
- No admin UI for upload

**Key Files:**
- Reference: `archibald-web-app/backend/src/excel-vat-importer.ts` (existing)
- Reference: `Listino_2026_vendita.xlsx` (root)
- Target: `archibald-web-app/backend/src/price-matching-service.ts` (new)
- Target: `archibald-web-app/frontend/src/pages/AdminPage.tsx` (enhance)

## Context

**Dependencies:**
- Plan 20-01 complete (prices.db structure known)
- Plan 20-02 complete (prices.db populated)
- ProductDatabase exists with price/vat fields

**Excel Format (Listino_2026_vendita.xlsx):**
Based on existing ExcelVatImporter code:
- Column 1: "ID" (e.g., "001627K0")
- Column 2: "Codice Articolo" (e.g., "1.204.005")
- Column 5: "Prezzo di listino unit." (optional)
- Column 6: "Prezzo di listino conf." (optional)
- Column 7: "IVA" (e.g., 22)

**Matching Strategy (Triple-Level):**
1. **Primary match**: `prices.db.productId` ‚Üí `products.db.id`
2. **Variant match**: `prices.db.itemSelection` ‚Üí derive package from `products.db.packageContent`
   - Example: K2 = "5 colli", K3 = "1 collo"
3. **Price update**: `prices.db.unitPrice` + Excel IVA ‚Üí `products.db.price` + `products.db.vat`

**Edge Cases:**
- No price in prices.db ‚Üí Don't update products.db (badge already shows "non disponibile")
- No IVA in Excel ‚Üí Use Archibald default (if available)
- Multiple variants ‚Üí Match each separately

## Tasks

### Task 1: Create Price Matching Service
**Duration:** 25min
**Type:** auto

Create `archibald-web-app/backend/src/price-matching-service.ts` to orchestrate prices.db ‚Üí products.db matching.

**Implementation:**

```typescript
import { PriceDatabase, Price } from './price-db';
import { ProductDatabase } from './product-db';
import { logger } from './logger';

export interface PriceMatchResult {
  totalPrices: number;
  matchedProducts: number;
  unmatchedPrices: number;
  variantMismatches: number;
  nullPrices: number;
  updatedProducts: number;
}

export interface UnmatchedPrice {
  productId: string;
  productName: string;
  itemSelection: string | null;
  reason: 'product_not_found' | 'variant_mismatch' | 'null_price';
}

/**
 * Price Matching Service
 *
 * Matches prices from prices.db to products in products.db
 * Uses multi-level strategy: productId + itemSelection matching
 */
export class PriceMatchingService {
  private static instance: PriceMatchingService;
  private priceDb: PriceDatabase;
  private productDb: ProductDatabase;

  private constructor() {
    this.priceDb = PriceDatabase.getInstance();
    this.productDb = ProductDatabase.getInstance();
  }

  static getInstance(): PriceMatchingService {
    if (!PriceMatchingService.instance) {
      PriceMatchingService.instance = new PriceMatchingService();
    }
    return PriceMatchingService.instance;
  }

  /**
   * Match all prices from prices.db to products in products.db
   * Updates product price/vat fields with priceSource='prices-db'
   *
   * @param excelVatMap Optional map of productId ‚Üí IVA percentage from Excel
   * @returns Match statistics and unmatched prices list
   */
  async matchPricesToProducts(
    excelVatMap?: Map<string, number>
  ): Promise<{
    result: PriceMatchResult;
    unmatchedPrices: UnmatchedPrice[];
  }> {
    const startTime = Date.now();
    logger.info('[PriceMatchingService] Starting price matching...');

    const unmatchedPrices: UnmatchedPrice[] = [];
    let matchedProducts = 0;
    let unmatchedPricesCount = 0;
    let variantMismatches = 0;
    let nullPrices = 0;
    let updatedProducts = 0;

    // Get all prices from prices.db
    const allPriceRecords = this.getAllPrices();
    const totalPrices = allPriceRecords.length;

    logger.info(`[PriceMatchingService] Processing ${totalPrices} price records`);

    for (const priceRecord of allPriceRecords) {
      // Skip if price is null
      if (priceRecord.unitPrice === null || priceRecord.unitPrice === undefined) {
        nullPrices++;
        unmatchedPrices.push({
          productId: priceRecord.productId,
          productName: priceRecord.productName,
          itemSelection: priceRecord.itemSelection,
          reason: 'null_price',
        });
        continue;
      }

      // Find matching product variants in products.db
      const matchingProducts = this.productDb.getProductsByName(priceRecord.productName);

      if (matchingProducts.length === 0) {
        unmatchedPricesCount++;
        unmatchedPrices.push({
          productId: priceRecord.productId,
          productName: priceRecord.productName,
          itemSelection: priceRecord.itemSelection,
          reason: 'product_not_found',
        });
        continue;
      }

      // Match by item selection (variant)
      const matchedProduct = this.matchVariant(matchingProducts, priceRecord.itemSelection);

      if (!matchedProduct) {
        variantMismatches++;
        unmatchedPrices.push({
          productId: priceRecord.productId,
          productName: priceRecord.productName,
          itemSelection: priceRecord.itemSelection,
          reason: 'variant_mismatch',
        });
        continue;
      }

      // Update product with price from prices.db
      const vatPercentage = excelVatMap?.get(priceRecord.productId) ?? matchedProduct.vat ?? null;

      const updated = this.productDb.updateProductPrice(
        matchedProduct.id,
        priceRecord.unitPrice,
        vatPercentage,
        'prices-db', // priceSource
        vatPercentage ? 'excel' : null // vatSource (Excel if provided, else null)
      );

      if (updated) {
        matchedProducts++;
        updatedProducts++;
      }
    }

    const duration = Date.now() - startTime;
    logger.info('[PriceMatchingService] Price matching completed', {
      duration,
      totalPrices,
      matchedProducts,
      unmatchedPricesCount,
      variantMismatches,
      nullPrices,
      updatedProducts,
    });

    return {
      result: {
        totalPrices,
        matchedProducts,
        unmatchedPrices: unmatchedPricesCount,
        variantMismatches,
        nullPrices,
        updatedProducts,
      },
      unmatchedPrices,
    };
  }

  /**
   * Match variant by itemSelection
   * Maps K2 ‚Üí "5 colli", K3 ‚Üí "1 collo", etc.
   */
  private matchVariant(products: any[], itemSelection: string | null): any | null {
    if (!itemSelection) {
      // No variant specified - return first product
      return products[0];
    }

    // Map item selection to package content
    // K2 = 5 colli, K3 = 1 collo (adjust mapping based on real data)
    const variantMap: Record<string, string> = {
      'K2': '5 colli',
      'K3': '1 collo',
      'K0': '10 colli', // Example - adjust based on real data
      'K1': '2 colli',
    };

    const expectedPackage = variantMap[itemSelection];

    if (expectedPackage) {
      const matched = products.find((p) => p.packageContent === expectedPackage);
      if (matched) return matched;
    }

    // Fallback: try exact item selection match in product ID suffix
    const matched = products.find((p) => p.id.endsWith(itemSelection));
    if (matched) return matched;

    // No match found
    return null;
  }

  /**
   * Get all prices from prices.db (helper method)
   */
  private getAllPrices(): Price[] {
    // This would ideally be a method in PriceDatabase
    // For now, implement inline or add to PriceDatabase in Task 2
    return [];
  }
}
```

**Key Features:**
- Multi-level matching: productId ‚Üí name ‚Üí variant
- Item selection mapping (K2 = 5 colli, etc.)
- Updates products.db with priceSource='prices-db'
- Excel IVA integration via optional map
- Detailed statistics and unmatched prices list

**Acceptance Criteria:**
- [ ] Matches prices.db records to products.db
- [ ] Variant matching by itemSelection works
- [ ] Updates product price/vat fields
- [ ] Returns detailed statistics
- [ ] Handles null prices gracefully
- [ ] Singleton pattern

**Commit:** `feat(20-03): create price matching service for prices.db ‚Üí products.db`

---

### Task 2: Enhance PriceDatabase with Query Methods
**Duration:** 10min
**Type:** auto

Add helper methods to `PriceDatabase` for fetching all prices.

**Implementation:**

Add to `archibald-web-app/backend/src/price-db.ts`:

```typescript
/**
 * Get all prices (for matching with products)
 * Returns all price records ordered by productId
 */
getAllPrices(): Price[] {
  return this.db
    .prepare('SELECT * FROM prices ORDER BY productId, itemSelection')
    .all() as Price[];
}

/**
 * Get prices by product ID (all variants)
 */
getPricesByProductId(productId: string): Price[] {
  return this.db
    .prepare('SELECT * FROM prices WHERE productId = ? ORDER BY itemSelection')
    .all(productId) as Price[];
}

/**
 * Search prices by product name (fuzzy match)
 */
searchPricesByName(searchTerm: string): Price[] {
  return this.db
    .prepare('SELECT * FROM prices WHERE productName LIKE ? ORDER BY productName')
    .all(`%${searchTerm}%`) as Price[];
}
```

**Acceptance Criteria:**
- [ ] getAllPrices() returns all price records
- [ ] getPricesByProductId() returns variants
- [ ] searchPricesByName() supports fuzzy search
- [ ] Methods use proper indexing for performance

**Commit:** `feat(20-03): add query methods to PriceDatabase`

---

### Task 3: Enhance ProductDatabase with Price Update Method
**Duration:** 10min
**Type:** auto

Add `updateProductPrice` method to `ProductDatabase`.

**Implementation:**

Add to `archibald-web-app/backend/src/product-db.ts`:

```typescript
/**
 * Update product price and VAT
 * Used by price matching service
 *
 * @returns true if updated, false if product not found
 */
updateProductPrice(
  productId: string,
  price: number,
  vat: number | null,
  priceSource: 'archibald' | 'excel' | 'prices-db',
  vatSource: 'archibald' | 'excel' | null
): boolean {
  const now = Math.floor(Date.now() / 1000);

  const result = this.db
    .prepare(`
      UPDATE products SET
        price = ?,
        vat = ?,
        priceSource = ?,
        vatSource = ?,
        priceUpdatedAt = ?,
        vatUpdatedAt = ?
      WHERE id = ?
    `)
    .run(price, vat, priceSource, vatSource, now, now, productId);

  return result.changes > 0;
}

/**
 * Get products by name (for matching with prices.db)
 * Returns all variants with matching name
 */
getProductsByName(productName: string): any[] {
  return this.db
    .prepare('SELECT * FROM products WHERE name = ? ORDER BY packageContent')
    .all(productName) as any[];
}
```

**Acceptance Criteria:**
- [ ] updateProductPrice() updates price and VAT
- [ ] Sets priceSource and vatSource correctly
- [ ] Updates timestamps
- [ ] Returns boolean success indicator
- [ ] getProductsByName() returns all variants

**Commit:** `feat(20-03): add price update methods to ProductDatabase`

---

### Task 4: Create Price Match API Endpoint
**Duration:** 10min
**Type:** auto

Add POST endpoint to trigger price matching.

**Implementation:**

Add to `archibald-web-app/backend/src/index.ts`:

```typescript
import { PriceMatchingService } from './price-matching-service';

// ... existing code ...

// Trigger price matching from prices.db to products.db
app.post("/api/prices/match", authenticateJWT, async (req, res) => {
  try {
    logger.info('[API] Price matching triggered');

    const matchingService = PriceMatchingService.getInstance();

    // Optional: include Excel VAT map if provided
    const excelVatMap = req.body.excelVatMap as Map<string, number> | undefined;

    const { result, unmatchedPrices } = await matchingService.matchPricesToProducts(excelVatMap);

    logger.info('[API] Price matching completed', result);

    res.json({
      success: true,
      result,
      unmatchedPrices: unmatchedPrices.slice(0, 100), // Limit to first 100 for response size
      totalUnmatched: unmatchedPrices.length,
    });
  } catch (error) {
    logger.error('[API] Price matching failed', { error });
    res.status(500).json({
      success: false,
      error: error instanceof Error ? error.message : String(error),
    });
  }
});
```

**Acceptance Criteria:**
- [ ] POST /api/prices/match endpoint created
- [ ] JWT-protected
- [ ] Returns match statistics and unmatched prices
- [ ] Logs errors properly

**Commit:** `feat(20-03): add price matching API endpoint`

---

### Task 5: Enhance Admin UI with Excel Upload
**Duration:** 5min
**Type:** checkpoint:human-verify

Add Excel IVA upload button to admin page.

**Implementation:**

Enhance `archibald-web-app/frontend/src/pages/AdminPage.tsx`:

```tsx
import { useState } from 'react';

// ... existing code ...

function AdminPage() {
  const [uploading, setUploading] = useState(false);
  const [uploadResult, setUploadResult] = useState<any>(null);

  const handleExcelUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setUploading(true);
    setUploadResult(null);

    try {
      const formData = new FormData();
      formData.append('file', file);

      const token = localStorage.getItem('token');
      const response = await fetch('/api/excel/upload-vat', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
        },
        body: formData,
      });

      const result = await response.json();
      setUploadResult(result);

      if (result.success) {
        alert(`‚úì IVA caricata con successo!\n\nProdotti aggiornati: ${result.vatUpdatedCount}`);

        // Trigger price matching after Excel upload
        await fetch('/api/prices/match', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json',
          },
        });
      } else {
        alert(`‚ùå Errore upload: ${result.error}`);
      }
    } catch (error) {
      console.error('Excel upload error:', error);
      alert(`‚ùå Errore upload: ${error}`);
    } finally {
      setUploading(false);
    }
  };

  return (
    <div style={{ padding: '20px' }}>
      <h1>Admin Panel</h1>

      {/* Excel IVA Upload Section */}
      <div style={{ marginTop: '20px', padding: '20px', border: '1px solid #ddd', borderRadius: '8px' }}>
        <h2>üìä Carica Listino Excel (IVA)</h2>
        <p>File formato: Listino_2026_vendita.xlsx</p>

        <input
          type="file"
          accept=".xlsx,.xls"
          onChange={handleExcelUpload}
          disabled={uploading}
          style={{ marginTop: '10px' }}
        />

        {uploading && <p>‚è≥ Caricamento in corso...</p>}

        {uploadResult && (
          <div style={{ marginTop: '20px', padding: '10px', backgroundColor: '#f0f0f0', borderRadius: '4px' }}>
            <h3>{uploadResult.success ? '‚úì Upload completato' : '‚ùå Errore'}</h3>
            <pre>{JSON.stringify(uploadResult, null, 2)}</pre>
          </div>
        )}
      </div>

      {/* ... existing admin sections ... */}
    </div>
  );
}

export default AdminPage;
```

**Manual Verification:**
1. Navigate to /admin page
2. Click "Choose File" and select `Listino_2026_vendita.xlsx`
3. Click upload
4. Verify success message shows updated product count
5. Check that price matching is triggered automatically

**Acceptance Criteria:**
- [ ] Excel file input in admin page
- [ ] Upload triggers /api/excel/upload-vat
- [ ] Success shows updated product count
- [ ] Automatically triggers price matching
- [ ] Error handling shows clear messages

**Commit:** `feat(20-03): add Excel IVA upload UI to admin page`

---

## Verification

### Success Criteria

- [ ] PriceMatchingService matches prices.db ‚Üí products.db
- [ ] Multi-level matching: productId + itemSelection works
- [ ] Product price/vat fields updated correctly
- [ ] Excel IVA upload integrated
- [ ] Admin UI allows Excel upload
- [ ] Price matching triggered after Excel upload
- [ ] Unmatched prices logged for investigation
- [ ] Statistics returned to UI
- [ ] All TypeScript compiles without errors
- [ ] All commits atomic with proper messages

### Manual Test

```bash
# 1. Run price sync (populate prices.db)
curl -X POST http://localhost:3000/api/prices/sync \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 2. Trigger price matching
curl -X POST http://localhost:3000/api/prices/match \
  -H "Authorization: Bearer YOUR_JWT_TOKEN"

# 3. Check products.db updated
sqlite3 archibald-web-app/backend/data/products.db \
  "SELECT id, name, price, vat, priceSource, vatSource FROM products LIMIT 10;"

# 4. Upload Excel via UI
# Navigate to /admin ‚Üí Upload Listino_2026_vendita.xlsx

# 5. Verify IVA updated
sqlite3 archibald-web-app/backend/data/products.db \
  "SELECT COUNT(*) FROM products WHERE vatSource='excel';"
```

### Expected Results

**After price matching:**
- products.db.price populated from prices.db.unitPrice
- products.db.priceSource = 'prices-db'
- Unmatched prices logged in console

**After Excel upload:**
- products.db.vat updated from Excel
- products.db.vatSource = 'excel'
- ~4,540 products with VAT percentages

### Coverage Target

- Goal: 100% price coverage (all products have price)
- Reality: ~95-98% (some products may be missing from PDF)
- Products without price: Show "Prezzo non disponibile" badge (already implemented in Phase 19.1-02)

## Output

**Files Created:**
1. `archibald-web-app/backend/src/price-matching-service.ts` - Price matching logic

**Files Modified:**
1. `archibald-web-app/backend/src/price-db.ts` - Query methods
2. `archibald-web-app/backend/src/product-db.ts` - Update methods
3. `archibald-web-app/backend/src/index.ts` - Match endpoint
4. `archibald-web-app/frontend/src/pages/AdminPage.tsx` - Excel upload UI

**Commits:** 5 atomic commits

**Next:** Plan 20-04 (Price History Tracking System)

---

## Notes

**Matching Strategy Details:**

1. **Primary match by productId:**
   - prices.db.productId ‚Üí products.db.id
   - Exact string match

2. **Variant match by itemSelection:**
   - K2 = 5 colli
   - K3 = 1 collo
   - K0 = 10 colli (example)
   - Adjust mapping based on real data

3. **Fallback strategies:**
   - Match by product ID suffix (e.g., 001627K2 ‚Üí K2)
   - Match first variant if no itemSelection

**Excel IVA Priority:**
- Excel VAT > Archibald VAT (always)
- If Excel has no VAT ‚Üí keep Archibald VAT
- vatSource field tracks source

**Edge Cases Handled:**
- ‚úÖ No price in prices.db ‚Üí Skip update, badge shows "non disponibile"
- ‚úÖ Multiple variants ‚Üí Match each separately
- ‚úÖ Variant mismatch ‚Üí Log as unmatched
- ‚úÖ Product not found ‚Üí Log as unmatched

**Admin UI Integration:**
- Excel upload button in admin page
- Automatic price matching after upload
- Statistics shown in UI
- Clear error messages
