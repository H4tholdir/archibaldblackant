---
phase: 27-bot-performance-profiling-v2
plan: 02
type: execute
---

<objective>
Create Binary Search Optimizer framework to find minimum stable slowdown for each bot step.

Purpose: Implement automated binary search algorithm that tests progressively lower slowdown values until finding the minimum that prevents crashes.
Output: SlowdownOptimizer class with binary search, crash detection, and retry logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-bot-performance-profiling-v2/27-CONTEXT.md
@.planning/phases/27-bot-performance-profiling-v2/27-01-SUMMARY.md
@archibald-web-app/backend/src/archibald-bot.ts

**From Plan 27-01:**
- SlowdownConfig interface and infrastructure ready
- Direct paste optimization implemented
- Bot instrumented with per-step slowdown tracking

**Binary Search Strategy:**
- Range: 0ms to 200ms
- Initial: 200ms (known safe)
- Convergence: Stop when range < 5ms
- On crash: Abort order, increase slowdown, restart from beginning

**Test Data:**
- Customer: fresis
- Article: TD1272.314
- Quantity: 1 (no discount, single article)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SlowdownOptimizer class with binary search algorithm</name>
  <files>archibald-web-app/backend/src/slowdown-optimizer.ts</files>
  <action>
    Create new file with SlowdownOptimizer class implementing binary search:

    **Class structure:**
    ```typescript
    interface StepOptimization {
      stepName: string;
      minValue: number;  // Known safe minimum
      maxValue: number;  // Known crash value (or max tested)
      testedValues: number[];
      crashes: number[];  // Values that caused crashes
      converged: boolean;
      optimalValue: number | null;
    }

    class SlowdownOptimizer {
      private steps: Map<string, StepOptimization>;
      private bot: ArchibaldBot;
      private testCustomer: string;
      private testArticle: string;
      
      constructor(bot: ArchibaldBot, customer: string, article: string);
      
      // Find optimal slowdown for a single step
      async optimizeStep(stepName: string): Promise<number>;
      
      // Binary search logic for one step
      private async binarySearch(step: StepOptimization): Promise<void>;
      
      // Test a specific slowdown value
      private async testSlowdownValue(
        stepName: string, 
        value: number
      ): Promise<{success: boolean, error?: string}>;
      
      // Get next value to test (midpoint of current range)
      private getNextTestValue(step: StepOptimization): number;
      
      // Check if step has converged (range < 5ms)
      private hasConverged(step: StepOptimization): boolean;
      
      // Get current optimization state
      getState(): Map<string, StepOptimization>;
    }
    ```

    **Binary search algorithm:**
    1. Start with range [0, 200]
    2. Test midpoint value (100)
    3. If success: narrow range to [0, 100]
    4. If crash: narrow range to [100, 200]
    5. Repeat until range < 5ms
    6. Return highest safe value

    **What to avoid:** Don't test multiple steps in parallel - test sequentially to avoid interference. Each test must complete a full order.
  </action>
  <verify>
    - TypeScript compiles without errors
    - Unit test: optimizeStep("test_step") with mock bot returns value between 0-200
    - Unit test: hasConverged returns true when max-min < 5
    - Unit test: getNextTestValue returns midpoint of range
  </verify>
  <done>
    - SlowdownOptimizer class created with all methods
    - Binary search logic implemented correctly
    - Unit tests pass
    - TypeScript types are sound
  </done>
</task>

<task type="auto">
  <name>Task 2: Add crash detection and retry logic</name>
  <files>archibald-web-app/backend/src/slowdown-optimizer.ts</files>
  <action>
    Implement crash detection and order restart logic:

    **Crash detection:**
    - Wrap bot.createOrder() in try-catch
    - Detect crashes via:
      - Uncaught exceptions
      - Timeout (>120s indicates crash/hang)
      - Bot error flag (bot.hasError)
    - Log crash details (step, slowdown value, error message)

    **Restart logic:**
    On crash:
    1. Mark slowdown value as unsafe (add to crashes array)
    2. Increase minimum safe range (minValue = crashedValue + 1)
    3. Close/cleanup bot state
    4. Restart bot with fresh context
    5. Retry with new slowdown value (higher in range)

    **Restart implementation:**
    ```typescript
    private async restartAfterCrash(): Promise<void> {
      // Close current bot context
      if (this.bot.page) await this.bot.page.close();
      if (this.bot.context) await this.bot.context.close();
      
      // Reinitialize bot
      await this.bot.init();
      
      logger.info("[Optimizer] Bot restarted after crash");
    }
    ```

    **Safety limits:**
    - Max 10 crashes per step (prevents infinite loops)
    - Max 50 total iterations per step
    - Timeout each test at 120s

    **What to avoid:** Don't attempt partial order recovery - always restart from beginning. Archibald state may be corrupted after crash.
  </action>
  <verify>
    - Mock test: Simulate crash, verify restart is called
    - Mock test: Verify minValue increases after crash
    - Mock test: Verify max crashes limit (10) is enforced
    - Mock test: Verify max iterations limit (50) is enforced
    - Integration test: Real crash triggers restart and continues optimization
  </verify>
  <done>
    - Crash detection implemented (exception + timeout + error flag)
    - Restart logic restores bot to clean state
    - Safety limits prevent infinite loops
    - Tests verify crash handling works correctly
    - Logs show clear crash/restart messages
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation passes
- [ ] Unit tests pass (binary search, convergence, midpoint calculation)
- [ ] Mock tests pass (crash detection, restart, safety limits)
- [ ] Integration test: Optimize single step with real bot completes successfully
- [ ] Logs show iteration progress and crash handling
</verification>

<success_criteria>

- SlowdownOptimizer class fully implemented
- Binary search algorithm working correctly
- Crash detection identifies failures reliably
- Restart logic restores clean bot state
- Safety limits prevent runaway loops
- All tests pass
- Ready for Phase 27-03 (Automated Profiling Execution)
</success_criteria>

<output>
After completion, create .planning/phases/27-bot-performance-profiling-v2/27-02-SUMMARY.md
</output>
