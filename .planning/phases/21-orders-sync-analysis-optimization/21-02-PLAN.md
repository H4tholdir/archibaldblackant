---
phase: 21-orders-sync-analysis-optimization
plan: 02
title: DDT PDF Parser & Separate Database with Tracking
subsystem: integration
complexity: medium
estimated_duration: 60min
tags: [python, pdf-parsing, node-js, ddt, tracking, 6-page-cycle, italian-locale]
---

# Plan 21-02: DDT PDF Parser & Separate Database with Tracking

## Objective

Create Python PDF parser for DDT (Documenti di Trasporto) with **6-page cycle support**, tracking extraction, separate `ddt.db` database, and tracking URL generation - following Phase 18/19/20/21-01 proven patterns.

## Execution Context

**Discovery Results (PDF-ANALYSIS-RESULTS.md):**
- ✅ Documenti di trasporto.pdf has **6-page cycle pattern**
- ✅ 606 pages = ~101 DDT entries
- ✅ Table-based format (~18 rows per page)
- ✅ Tracking info on Page 4/6 (NUMERO DI TRACCIABILITÀ column)
- ✅ Match key: orderNumber (ID DI VENDITA) on Page 1/6
- ✅ ~30-40% of DDTs have tracking numbers

**Page Cycle Structure:**
- Page 1/6: DDT ID, Order Number, Delivery Date (5 cols)
- Page 2/6: Customer Account, Sales Name (2 cols)
- Page 3/6: Delivery Names (2 cols - duplicate column)
- Page 4/6: **TRACKING** + Delivery Terms + Method (3 cols) ⭐
- Page 5/6: Delivery City + Location (3 cols)
- Page 6/6: Additional fields (2-3 cols)

**Matching Strategy:**
- **Primary Key:** `ddt.orderNumber = orders.orderNumber`
- **Relationship:** One order → 0-N DDTs (multiple shipments)
- **Join:** Frontend displays DDT info when showing order details

## Context

**Goals:**
1. Parse Documenti di trasporto.pdf with 6-page cycle
2. Extract tracking numbers (~30-40% coverage)
3. Generate tracking URLs per courier
4. Create separate ddt.db with MD5 delta detection
5. Match DDTs to orders via orderNumber
6. Performance target: < 60s for ~101 DDTs

## Tasks

### Task 1: Python PDF Parser for DDT (6-Page Cycle) (25min)

**Goal:** Create Python script to parse DDT PDF with tracking extraction.

**Deliverables:**

1. **`scripts/parse-ddt-pdf.py`** - Python parser with 6-page cycle logic

**Implementation:**
```python
#!/usr/bin/env python3
"""
Parse Documenti di trasporto.pdf - 6-page cycle structure
Outputs JSON to stdout (one DDT per line)
"""

import pdfplumber
import json
import sys
from dataclasses import dataclass, asdict
from datetime import datetime
from typing import Optional

@dataclass
class ParsedDDT:
    """DDT data from Documenti di trasporto.pdf"""
    # Page 1/6: DDT Identification
    id: str  # Internal ID
    ddt_number: str  # e.g., "DDT/26000613"
    delivery_date: Optional[str]  # ISO 8601
    order_number: str  # Match key! e.g., "ORD/26000695"

    # Page 2/6: Customer
    customer_account: Optional[str]
    sales_name: Optional[str]

    # Page 3/6: Delivery Name
    delivery_name: Optional[str]

    # Page 4/6: TRACKING (Key page!)
    tracking_number: Optional[str]  # e.g., "445291888246"
    delivery_terms: Optional[str]  # e.g., "CFR"
    delivery_method: Optional[str]  # Courier: "FedEx", "UPS", "DHL"

    # Page 5/6: Location
    delivery_city: Optional[str]


def parse_italian_date(date_str: str) -> Optional[str]:
    """Parse Italian date to ISO 8601: DD/MM/YYYY → YYYY-MM-DD"""
    if not date_str or date_str.strip() == "":
        return None
    try:
        dt = datetime.strptime(date_str.strip(), "%d/%m/%Y")
        return dt.date().isoformat()
    except ValueError:
        return None


def parse_ddt_pdf(pdf_path: str):
    """
    Parse Documenti di trasporto.pdf with 6-page cycle structure.
    Yields one ParsedDDT per DDT entry.
    """
    with pdfplumber.open(pdf_path) as pdf:
        total_pages = len(pdf.pages)

        # Process in 6-page cycles
        for cycle_start in range(0, total_pages, 6):
            # Extract all 6 pages as tables
            tables = []
            for i in range(6):
                page_idx = cycle_start + i
                if page_idx >= total_pages:
                    break

                page = pdf.pages[page_idx]
                page_tables = page.extract_tables()

                if not page_tables or not page_tables[0]:
                    tables.append([])
                else:
                    tables.append(page_tables[0])

                page = None

            # Need all 6 pages
            if len(tables) < 6:
                break

            # Skip if first table empty
            if not tables[0] or len(tables[0]) <= 1:
                continue

            num_rows = len(tables[0])

            for row_idx in range(1, num_rows):  # Skip header
                try:
                    # Page 1/6: DDT ID (5 columns)
                    # Columns: [PDF_DDT, ID, DDT_NUMBER, DELIVERY_DATE, ORDER_NUMBER]
                    row1 = tables[0][row_idx] if row_idx < len(tables[0]) else [None] * 5
                    ddt_id = row1[1] if len(row1) > 1 else None
                    ddt_number = row1[2] if len(row1) > 2 else None
                    delivery_date = parse_italian_date(row1[3]) if len(row1) > 3 else None
                    order_number = row1[4] if len(row1) > 4 else None

                    # Skip if no DDT number or order number
                    if not ddt_number or not order_number:
                        continue

                    # Skip garbage rows
                    if ddt_id == "0" or ddt_number == "0":
                        continue

                    # Page 2/6: Customer (2 columns)
                    row2 = tables[1][row_idx] if row_idx < len(tables[1]) else [None] * 2
                    customer_account = row2[0] if len(row2) > 0 else None
                    sales_name = row2[1] if len(row2) > 1 else None

                    # Page 3/6: Delivery Name (2 columns - use first)
                    row3 = tables[2][row_idx] if row_idx < len(tables[2]) else [None] * 2
                    delivery_name = row3[0] if len(row3) > 0 else None

                    # Page 4/6: TRACKING (3 columns) ⭐ KEY PAGE
                    # Columns: [TRACKING_NUMBER, DELIVERY_TERMS, DELIVERY_METHOD]
                    row4 = tables[3][row_idx] if row_idx < len(tables[3]) else [None] * 3
                    tracking_number = row4[0] if len(row4) > 0 and row4[0] and row4[0].strip() else None
                    delivery_terms = row4[1] if len(row4) > 1 else None
                    delivery_method = row4[2] if len(row4) > 2 else None

                    # Page 5/6: Location (3 columns)
                    row5 = tables[4][row_idx] if row_idx < len(tables[4]) else [None] * 3
                    delivery_city = row5[0] if len(row5) > 0 else None

                    # Create ParsedDDT
                    ddt = ParsedDDT(
                        id=ddt_id,
                        ddt_number=ddt_number,
                        delivery_date=delivery_date,
                        order_number=order_number,
                        customer_account=customer_account,
                        sales_name=sales_name,
                        delivery_name=delivery_name,
                        tracking_number=tracking_number,
                        delivery_terms=delivery_terms,
                        delivery_method=delivery_method,
                        delivery_city=delivery_city
                    )

                    yield ddt

                except Exception as e:
                    print(f"Warning: Error parsing row {row_idx} in cycle {cycle_start}: {e}", file=sys.stderr)
                    continue

            tables = None


def main():
    """Main entry point"""
    if len(sys.argv) < 2:
        print("Usage: parse-ddt-pdf.py <pdf_path>", file=sys.stderr)
        sys.exit(1)

    pdf_path = sys.argv[1]

    try:
        for ddt in parse_ddt_pdf(pdf_path):
            print(json.dumps(asdict(ddt), ensure_ascii=False))

    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
```

**Success Criteria:**
- [x] 6-page cycle logic working
- [x] Tracking extraction from Page 4/6
- [x] Match key (orderNumber) extracted correctly
- [x] Streaming JSON output

---

### Task 2: Separate DDT Database with Tracking URLs (20min)

**Goal:** Create ddt.db with tracking URL generation.

**Deliverables:**

1. **`src/ddt-db.ts`** - DDT Database class with tracking logic

**Database Schema:**
```sql
CREATE TABLE ddt (
  id TEXT PRIMARY KEY,
  ddt_number TEXT NOT NULL UNIQUE,
  delivery_date TEXT,
  order_number TEXT NOT NULL,      -- Match key to orders!
  customer_account TEXT,
  sales_name TEXT,
  delivery_name TEXT,
  tracking_number TEXT,
  delivery_terms TEXT,
  delivery_method TEXT,
  delivery_city TEXT,

  -- Computed tracking fields
  tracking_url TEXT,
  tracking_courier TEXT,           -- Normalized: "fedex", "ups", "dhl"

  -- Sync metadata
  hash TEXT NOT NULL,
  last_sync INTEGER NOT NULL,
  created_at TEXT NOT NULL
);

CREATE INDEX idx_ddt_order_number ON ddt(order_number);
CREATE INDEX idx_ddt_tracking ON ddt(tracking_number);
CREATE INDEX idx_ddt_sync ON ddt(last_sync);
```

**Implementation:**
```typescript
import Database from "better-sqlite3";
import crypto from "crypto";
import { logger } from "./logger";
import path from "node:path";

export interface DDTRecord {
  id: string;
  ddtNumber: string;
  deliveryDate: string | null;
  orderNumber: string;  // Match key!
  customerAccount: string | null;
  salesName: string | null;
  deliveryName: string | null;
  trackingNumber: string | null;
  deliveryTerms: string | null;
  deliveryMethod: string | null;
  deliveryCity: string | null;
  trackingUrl: string | null;
  trackingCourier: string | null;
  lastSync: number;
}

export class DDTDatabase {
  private static instance: DDTDatabase;
  private db: Database.Database;

  private constructor(dbPath?: string) {
    const finalPath = dbPath || path.join(process.cwd(), "data", "ddt.db");
    this.db = new Database(finalPath);
    this.db.pragma("journal_mode = WAL");
    this.initSchema();
    logger.info("DDTDatabase initialized", { path: finalPath });
  }

  static getInstance(dbPath?: string): DDTDatabase {
    if (!DDTDatabase.instance) {
      DDTDatabase.instance = new DDTDatabase(dbPath);
    }
    return DDTDatabase.instance;
  }

  private initSchema(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS ddt (
        id TEXT PRIMARY KEY,
        ddt_number TEXT NOT NULL UNIQUE,
        delivery_date TEXT,
        order_number TEXT NOT NULL,
        customer_account TEXT,
        sales_name TEXT,
        delivery_name TEXT,
        tracking_number TEXT,
        delivery_terms TEXT,
        delivery_method TEXT,
        delivery_city TEXT,
        tracking_url TEXT,
        tracking_courier TEXT,
        hash TEXT NOT NULL,
        last_sync INTEGER NOT NULL,
        created_at TEXT NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_ddt_order_number ON ddt(order_number);
      CREATE INDEX IF NOT EXISTS idx_ddt_tracking ON ddt(tracking_number);
      CREATE INDEX IF NOT EXISTS idx_ddt_sync ON ddt(last_sync);
    `);
  }

  private normalizeCourier(courier: string | null): string | null {
    if (!courier) return null;
    const lower = courier.toLowerCase().trim();

    // Normalize common variations
    if (lower.includes("fedex") || lower.includes("fidex")) return "fedex";
    if (lower.includes("ups")) return "ups";
    if (lower.includes("dhl")) return "dhl";
    if (lower.includes("tnt")) return "tnt";
    if (lower.includes("gls")) return "gls";
    if (lower.includes("bartolini") || lower.includes("brt")) return "brt";
    if (lower.includes("sda")) return "sda";

    return lower;
  }

  private generateTrackingUrl(trackingNumber: string, courier: string | null): string | null {
    if (!trackingNumber || !courier) return null;

    const normalized = this.normalizeCourier(courier);

    switch (normalized) {
      case "fedex":
        return `https://www.fedex.com/fedextrack/?trknbr=${trackingNumber}`;
      case "ups":
        return `https://www.ups.com/track?tracknum=${trackingNumber}`;
      case "dhl":
        return `https://www.dhl.com/it-it/home/tracking/tracking-express.html?submit=1&tracking-id=${trackingNumber}`;
      case "tnt":
        return `https://www.tnt.com/express/it_it/site/tracking.html?searchType=con&cons=${trackingNumber}`;
      case "gls":
        return `https://www.gls-italy.com/?option=com_gls&view=track_e_trace&mode=search&trackNumber=${trackingNumber}`;
      case "brt":
        return `https://vas.brt.it/vas/sped_nuova_ui.htm?brtCode=${trackingNumber}`;
      case "sda":
        return `https://www.sda.it/wps/portal/Servizi_online/dettaglio-spedizione?locale=it&tracing.letteraVettura=${trackingNumber}`;
      default:
        return null;
    }
  }

  private computeHash(ddt: Omit<DDTRecord, 'lastSync' | 'trackingUrl' | 'trackingCourier'>): string {
    const hashInput = [
      ddt.id,
      ddt.ddtNumber,
      ddt.orderNumber,
      ddt.trackingNumber,
      ddt.deliveryDate
    ].join('|');
    return crypto.createHash('md5').update(hashInput).digest('hex');
  }

  upsertDDT(ddt: Omit<DDTRecord, 'lastSync' | 'trackingUrl' | 'trackingCourier'>): 'inserted' | 'updated' | 'skipped' {
    const now = Math.floor(Date.now() / 1000);
    const hash = this.computeHash(ddt);

    // Compute tracking fields
    const trackingCourier = this.normalizeCourier(ddt.deliveryMethod);
    const trackingUrl = ddt.trackingNumber
      ? this.generateTrackingUrl(ddt.trackingNumber, ddt.deliveryMethod)
      : null;

    // Check if exists
    const existing = this.db.prepare(`
      SELECT hash FROM ddt WHERE ddt_number = ?
    `).get(ddt.ddtNumber) as { hash: string } | undefined;

    if (!existing) {
      // Insert
      this.db.prepare(`
        INSERT INTO ddt (
          id, ddt_number, delivery_date, order_number, customer_account,
          sales_name, delivery_name, tracking_number, delivery_terms,
          delivery_method, delivery_city, tracking_url, tracking_courier,
          hash, last_sync, created_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
      `).run(
        ddt.id, ddt.ddtNumber, ddt.deliveryDate, ddt.orderNumber, ddt.customerAccount,
        ddt.salesName, ddt.deliveryName, ddt.trackingNumber, ddt.deliveryTerms,
        ddt.deliveryMethod, ddt.deliveryCity, trackingUrl, trackingCourier,
        hash, now, new Date().toISOString()
      );
      return 'inserted';
    }

    if (existing.hash === hash) {
      this.db.prepare(`UPDATE ddt SET last_sync = ? WHERE ddt_number = ?`)
        .run(now, ddt.ddtNumber);
      return 'skipped';
    }

    // Update
    this.db.prepare(`
      UPDATE ddt SET
        delivery_date = ?, order_number = ?, customer_account = ?,
        sales_name = ?, delivery_name = ?, tracking_number = ?,
        delivery_terms = ?, delivery_method = ?, delivery_city = ?,
        tracking_url = ?, tracking_courier = ?, hash = ?, last_sync = ?
      WHERE ddt_number = ?
    `).run(
      ddt.deliveryDate, ddt.orderNumber, ddt.customerAccount,
      ddt.salesName, ddt.deliveryName, ddt.trackingNumber,
      ddt.deliveryTerms, ddt.deliveryMethod, ddt.deliveryCity,
      trackingUrl, trackingCourier, hash, now,
      ddt.ddtNumber
    );
    return 'updated';
  }

  getDDTsByOrderNumber(orderNumber: string): DDTRecord[] {
    return this.db.prepare(`
      SELECT * FROM ddt WHERE order_number = ? ORDER BY delivery_date DESC
    `).all(orderNumber) as DDTRecord[];
  }

  getTotalCount(): number {
    const result = this.db.prepare(`SELECT COUNT(*) as count FROM ddt`).get() as { count: number };
    return result.count;
  }

  getTrackingCoverage(): { total: number; withTracking: number; percentage: number } {
    const total = this.getTotalCount();
    const withTracking = this.db.prepare(`
      SELECT COUNT(*) as count FROM ddt WHERE tracking_number IS NOT NULL AND tracking_number != ''
    `).get() as { count: number };

    return {
      total,
      withTracking: withTracking.count,
      percentage: total > 0 ? Math.round((withTracking.count / total) * 100) : 0
    };
  }
}
```

**Success Criteria:**
- [x] Database schema created
- [x] Tracking URL generation for 7 couriers
- [x] Courier normalization working
- [x] Match by orderNumber functional

---

### Task 3: Node.js Wrapper & Health Check (15min)

**Goal:** Node.js service wrapper for DDT parser.

**Deliverables:**

1. **`src/pdf-parser-ddt-service.ts`** - Service wrapper
2. **Update `src/index.ts`** - Add health check endpoint

**Service Implementation:**
```typescript
import { spawn } from "child_process";
import { logger } from "./logger";
import path from "node:path";

export interface ParsedDDT {
  id: string;
  ddt_number: string;
  delivery_date: string | null;
  order_number: string;
  customer_account: string | null;
  sales_name: string | null;
  delivery_name: string | null;
  tracking_number: string | null;
  delivery_terms: string | null;
  delivery_method: string | null;
  delivery_city: string | null;
}

export class PDFParserDDTService {
  private static instance: PDFParserDDTService;
  private readonly parserPath: string;
  private readonly timeout: number = 180000; // 3 minutes
  private readonly maxBuffer: number = 20 * 1024 * 1024; // 20MB

  private constructor() {
    this.parserPath = path.join(process.cwd(), "scripts", "parse-ddt-pdf.py");
  }

  static getInstance(): PDFParserDDTService {
    if (!PDFParserDDTService.instance) {
      PDFParserDDTService.instance = new PDFParserDDTService();
    }
    return PDFParserDDTService.instance;
  }

  async parseDDTPDF(pdfPath: string): Promise<ParsedDDT[]> {
    logger.info("[PDFParserDDTService] Starting PDF parsing", { pdfPath });

    return new Promise((resolve, reject) => {
      const startTime = Date.now();
      const ddts: ParsedDDT[] = [];
      let stdoutBuffer = "";

      const pythonProcess = spawn("python3", [this.parserPath, pdfPath], {
        maxBuffer: this.maxBuffer,
        timeout: this.timeout,
      });

      pythonProcess.stdout.on("data", (data: Buffer) => {
        stdoutBuffer += data.toString();
        const lines = stdoutBuffer.split("\n");
        stdoutBuffer = lines.pop() || "";

        for (const line of lines) {
          if (line.trim()) {
            try {
              const ddt = JSON.parse(line) as ParsedDDT;
              ddts.push(ddt);
            } catch (e) {
              logger.warn("[PDFParserDDTService] Failed to parse line", { line });
            }
          }
        }
      });

      pythonProcess.stderr.on("data", (data: Buffer) => {
        logger.warn("[PDFParserDDTService] Python stderr", { stderr: data.toString() });
      });

      pythonProcess.on("close", (code) => {
        const duration = Date.now() - startTime;

        if (code === 0) {
          logger.info("[PDFParserDDTService] Parsing complete", {
            duration: `${duration}ms`,
            ddtCount: ddts.length,
          });
          resolve(ddts);
        } else {
          logger.error("[PDFParserDDTService] Parsing failed", { code, duration: `${duration}ms` });
          reject(new Error(`DDT PDF parsing failed with code ${code}`));
        }
      });

      pythonProcess.on("error", (err) => {
        logger.error("[PDFParserDDTService] Process error", { error: err.message });
        reject(err);
      });
    });
  }

  isAvailable(): boolean {
    try {
      const fs = require("fs");
      return fs.existsSync(this.parserPath);
    } catch {
      return false;
    }
  }
}
```

**Health Check:**
```typescript
// Add to src/index.ts
app.get("/api/health/pdf-parser-ddt", (req, res) => {
  const parserService = PDFParserDDTService.getInstance();

  const health = {
    available: parserService.isAvailable(),
    parser: "parse-ddt-pdf.py",
    timeout: "180s",
    maxBuffer: "20MB",
  };

  if (health.available) {
    res.json({ success: true, ...health });
  } else {
    res.status(503).json({
      success: false,
      message: "DDT PDF parser not available",
      ...health,
    });
  }
});
```

**Success Criteria:**
- [x] Service executes parser
- [x] Health check working
- [x] Timeout/buffer configured

---

## Verification

**E2E Test Script:**
```typescript
// scripts/test-ddt-sync-e2e.ts
import { PDFParserDDTService } from "../src/pdf-parser-ddt-service";
import { DDTDatabase } from "../src/ddt-db";
import { logger } from "../src/logger";

async function testDDTSyncE2E() {
  logger.info("=== DDT Sync E2E Test ===");

  try {
    const parserService = PDFParserDDTService.getInstance();
    const parsedDDTs = await parserService.parseDDTPDF("Documenti di trasporto.pdf");
    logger.info(`✓ Parsed ${parsedDDTs.length} DDTs`);

    const ddtDb = DDTDatabase.getInstance();
    let inserted = 0;
    let updated = 0;
    let skipped = 0;

    for (const ddt of parsedDDTs) {
      const result = ddtDb.upsertDDT({
        id: ddt.id,
        ddtNumber: ddt.ddt_number,
        deliveryDate: ddt.delivery_date,
        orderNumber: ddt.order_number,
        customerAccount: ddt.customer_account,
        salesName: ddt.sales_name,
        deliveryName: ddt.delivery_name,
        trackingNumber: ddt.tracking_number,
        deliveryTerms: ddt.delivery_terms,
        deliveryMethod: ddt.delivery_method,
        deliveryCity: ddt.delivery_city
      });

      if (result === "inserted") inserted++;
      else if (result === "updated") updated++;
      else skipped++;
    }

    logger.info(`✓ Inserted: ${inserted}, Updated: ${updated}, Skipped: ${skipped}`);

    const coverage = ddtDb.getTrackingCoverage();
    logger.info(`✓ Tracking coverage: ${coverage.withTracking}/${coverage.total} (${coverage.percentage}%)`);

    logger.info("=== DDT E2E Test Complete ✓ ===");
    process.exit(0);
  } catch (error) {
    logger.error("❌ DDT E2E Test failed", { error });
    process.exit(1);
  }
}

testDDTSyncE2E();
```

**Manual Verification:**
```bash
npm run build
node dist/scripts/test-ddt-sync-e2e.js

sqlite3 data/ddt.db "SELECT COUNT(*) FROM ddt;"
sqlite3 data/ddt.db "SELECT ddt_number, order_number, tracking_number, tracking_courier FROM ddt WHERE tracking_number IS NOT NULL LIMIT 5;"
```

---

## Success Criteria

- [ ] Python parser handles 6-page cycle
- [ ] Tracking extracted from Page 4/6
- [ ] Match key (orderNumber) working
- [ ] Separate ddt.db created
- [ ] Tracking URLs generated for 7 couriers
- [ ] Courier normalization functional
- [ ] Node.js service wrapper working
- [ ] Health check endpoint operational
- [ ] E2E test completes successfully
- [ ] Performance: < 60s for ~101 DDTs
- [ ] Tracking coverage: ~30-40%

---

## Output

**Files Created:**
1. `scripts/parse-ddt-pdf.py` - DDT parser (6-page cycle)
2. `src/ddt-db.ts` - DDT database with tracking logic
3. `src/pdf-parser-ddt-service.ts` - Node.js wrapper
4. `scripts/test-ddt-sync-e2e.ts` - E2E test

**Files Modified:**
1. `src/index.ts` - Add health check endpoint

**Database Created:**
1. `data/ddt.db` - Separate DDT database with tracking

**Commits:**
1. `feat(21-02): add DDT PDF parser with 6-page cycle and tracking extraction`
2. `feat(21-02): create ddt database with tracking URL generation`
3. `feat(21-02): add Node.js wrapper for DDT parser`
4. `test(21-02): add E2E test for DDT sync`
