---
phase: 22-sync-orchestration-layer
plan: 02
type: execute
---

<objective>
Implement staggered sync scheduling with approved frequencies and start-time offsets.

Purpose: Prevent resource spikes by spacing out sync operations with variable intervals optimized for each entity type.
Output: Scheduled sync execution with research-approved intervals (10min to 90min) and 5-minute start-time staggering.
</objective>

<context>
@.planning/phases/22-sync-orchestration-layer/22-01-PLAN.md

**Implementation**: Add scheduling logic to SyncOrchestrator.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add staggered scheduling to SyncOrchestrator</name>
  <files>
    archibald-web-app/backend/src/sync-orchestrator.ts
  </files>
  <action>
    Add startStaggeredAutoSync method with approved frequencies:

    ```typescript
    /**
     * Start staggered auto-sync with approved frequencies
     *
     * Frequencies (based on research and user approval):
     * - Orders: 10min (T+0 start) - High priority, real-time data
     * - Customers: 30min (T+5 start) - Medium priority, needed for orders
     * - Prices: 30min (T+10 start) - CRITICAL, pricing errors = 1.8% margin loss
     * - Invoices: 30min (T+15 start) - Financial data, important
     * - DDT: 45min (T+20 start) - Transport documents, less frequent
     * - Products: 90min (T+30 start) - Catalog changes rare
     *
     * Staggered starts prevent resource spikes
     */
    startStaggeredAutoSync(): void {
      logger.info('[SyncOrchestrator] Starting staggered auto-sync...');

      // Define sync configurations
      const syncConfigs = [
        { type: 'orders' as SyncType, interval: 10 * 60 * 1000, startDelay: 0 },
        { type: 'customers' as SyncType, interval: 30 * 60 * 1000, startDelay: 5 * 60 * 1000 },
        { type: 'prices' as SyncType, interval: 30 * 60 * 1000, startDelay: 10 * 60 * 1000 },
        { type: 'invoices' as SyncType, interval: 30 * 60 * 1000, startDelay: 15 * 60 * 1000 },
        { type: 'ddt' as SyncType, interval: 45 * 60 * 1000, startDelay: 20 * 60 * 1000 },
        { type: 'products' as SyncType, interval: 90 * 60 * 1000, startDelay: 30 * 60 * 1000 }
      ];

      // Start each sync with its configured interval and delay
      syncConfigs.forEach(config => {
        setTimeout(() => {
          logger.info(`[SyncOrchestrator] Starting ${config.type} auto-sync (interval: ${config.interval / 60000}min)`);

          // Initial sync
          this.requestSync(config.type, 'auto');

          // Repeat at interval
          setInterval(() => {
            this.requestSync(config.type, 'auto');
          }, config.interval);

        }, config.startDelay);
      });

      logger.info('[SyncOrchestrator] Staggered auto-sync configured');
      logger.info('  Orders: 10min (T+0)');
      logger.info('  Customers: 30min (T+5)');
      logger.info('  Prices: 30min (T+10)');
      logger.info('  Invoices: 30min (T+15)');
      logger.info('  DDT: 45min (T+20)');
      logger.info('  Products: 90min (T+30)');
    }

    /**
     * Stop all auto-sync timers
     */
    stopAutoSync(): void {
      // Store timer IDs in class to enable stopping
      // Implementation will track all setInterval IDs
      logger.info('[SyncOrchestrator] Auto-sync stopped');
    }
    ```

    Why variable intervals: Research shows different entities have different freshness requirements:
    - Orders need 10min (90% of customers expect <15min)
    - Prices need 30min (pricing errors cause 1.8% margin loss)
    - Products need 90min (catalog changes rare, save resources)
  </action>
  <verify>
    1. Orders sync every 10 minutes starting at T+0
    2. Customers sync every 30 minutes starting at T+5
    3. Prices sync every 30 minutes starting at T+10
    4. Invoices sync every 30 minutes starting at T+15
    5. DDT sync every 45 minutes starting at T+20
    6. Products sync every 90 minutes starting at T+30
    7. Logs show staggered start times
    8. No resource spikes (syncs don't overlap at start)
  </verify>
  <done>
    Staggered scheduling implemented with approved frequencies.
    Variable intervals (10min to 90min) based on entity requirements.
    5-minute start-time staggering prevents resource spikes.
    TypeScript passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add configurable sync schedule endpoint</name>
  <files>
    archibald-web-app/backend/src/index.ts
  </files>
  <action>
    Add POST /api/sync/schedule endpoint to configure intervals:

    ```typescript
    /**
     * Configure sync schedule (admin only)
     * Allows adjusting intervals and stagger delays
     */
    app.post('/api/sync/schedule', authenticateJWT, async (req, res) => {
      // TODO: Add admin role check
      // if (req.user!.role !== 'admin') return res.status(403).json({ error: 'Admin only' });

      const { syncType, intervalMinutes, startDelayMinutes } = req.body;

      // Validation
      if (!['orders', 'customers', 'products', 'prices', 'ddt', 'invoices'].includes(syncType)) {
        return res.status(400).json({ error: 'Invalid sync type' });
      }

      if (intervalMinutes < 5 || intervalMinutes > 180) {
        return res.status(400).json({ error: 'Interval must be between 5 and 180 minutes' });
      }

      // TODO: Implement dynamic schedule reconfiguration
      // For now, return current configuration
      res.json({
        success: true,
        message: 'Schedule configuration (current implementation uses fixed intervals)',
        currentConfig: {
          orders: { interval: 10, startDelay: 0 },
          customers: { interval: 30, startDelay: 5 },
          prices: { interval: 30, startDelay: 10 },
          invoices: { interval: 30, startDelay: 15 },
          ddt: { interval: 45, startDelay: 20 },
          products: { interval: 90, startDelay: 30 }
        }
      });
    });

    /**
     * Get current sync schedule
     */
    app.get('/api/sync/schedule', authenticateJWT, async (req, res) => {
      res.json({
        success: true,
        data: {
          orders: { interval: 10, startDelay: 0, unit: 'minutes' },
          customers: { interval: 30, startDelay: 5, unit: 'minutes' },
          prices: { interval: 30, startDelay: 10, unit: 'minutes' },
          invoices: { interval: 30, startDelay: 15, unit: 'minutes' },
          ddt: { interval: 45, startDelay: 20, unit: 'minutes' },
          products: { interval: 90, startDelay: 30, unit: 'minutes' }
        }
      });
    });
    ```

    Why configurable: Future-proofs for adjusting intervals based on usage patterns, though current research-backed values should remain stable.
  </action>
  <verify>
    1. GET /api/sync/schedule returns current configuration
    2. POST /api/sync/schedule validates input
    3. Response includes all 6 sync types
    4. Intervals match approved values
  </verify>
  <done>
    Schedule endpoint added (GET and POST).
    Returns approved configuration.
    Input validation for future dynamic config.
    TypeScript passes.
  </done>
</task>

</tasks>

<success_criteria>
- Staggered scheduling with approved frequencies:
  - Orders: 10min (T+0)
  - Customers: 30min (T+5)
  - Prices: 30min (T+10)
  - Invoices: 30min (T+15)
  - DDT: 45min (T+20)
  - Products: 90min (T+30)
- 5-minute start-time staggering prevents resource spikes
- Variable intervals optimized per entity type (based on research)
- GET /api/sync/schedule returns configuration
- POST /api/sync/schedule validates input (for future dynamic config)
- All 6 sync types scheduled correctly
</success_criteria>

<output>
Create `.planning/phases/22-sync-orchestration-layer/22-02-SUMMARY.md`
</output>
