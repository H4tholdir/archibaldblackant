---
phase: 22-sync-orchestration-layer
plan: 01
type: execute
---

<objective>
Create SyncOrchestrator to coordinate all sync services, prevent overlapping executions, and implement Smart Customer Sync.

Purpose: Central coordinator to manage sync scheduling, prevent conflicts, implement staggered sync intervals, and provide on-demand customer sync when entering order form.
Output: SyncOrchestrator class managing customers, products, prices, orders, DDT, invoices sync services with mutex locking and Smart Customer Sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/backend/src/product-sync-service.ts
@archibald-web-app/backend/src/price-sync-service.ts
@archibald-web-app/backend/src/order-history-service.ts

**Current state:**
- Six independent sync services (customers, products, prices, orders, DDT, invoices)
- Each has auto-sync with independent intervals
- No coordination ‚Üí potential overlapping syncs ‚Üí resource contention
- activeOperation lock in index.ts (basic mutex) but not comprehensive
- PriorityManager exists for pause/resume functionality

**Orchestration requirements:**
- Single coordinator manages all sync services
- Mutex locking: only one sync at a time
- Staggered scheduling with approved frequencies:
  - Orders: 10min (T+0 start)
  - Customers: 30min (T+5 start)
  - Prices: 30min (T+10 start)
  - Invoices: 30min (T+15 start)
  - DDT: 45min (T+20 start)
  - Products: 90min (T+30 start)
- Priority handling: orders=6, customers=5, ddt=4, invoices=3, prices=2, products=1
- Smart Customer Sync: On-demand sync when entering order form
  - Syncs only last 10 minutes of changes (3-5s fast execution)
  - Pauses other syncs until user exits order form
  - Session reference counting for multiple tabs
  - Safety timeout: auto-resume after 10 minutes
- Event-driven architecture for status updates
- Health monitoring for all services

**Design pattern:**
- SyncOrchestrator singleton
- Event emitter for progress broadcasts
- Queueing system for sync requests
- Configurable sync schedule
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncOrchestrator class with mutex locking</name>
  <files>
    archibald-web-app/backend/src/sync-orchestrator.ts
  </files>
  <action>
    Create SyncOrchestrator singleton with comprehensive mutex:

    ```typescript
    import { EventEmitter } from 'events';
    import { CustomerSyncService } from './customer-sync-service';
    import { ProductSyncService } from './product-sync-service';
    import { PriceSyncService } from './price-sync-service';
    import { OrderHistoryService } from './order-history-service';
    import { logger } from './logger';

    export type SyncType = 'customers' | 'products' | 'prices' | 'orders' | 'ddt' | 'invoices';

    export interface SyncStatus {
      type: SyncType;
      status: 'idle' | 'queued' | 'running' | 'completed' | 'error';
      startedAt?: Date;
      completedAt?: Date;
      error?: string;
    }

    /**
     * SyncOrchestrator - Centralized coordinator for all sync services
     *
     * Responsibilities:
     * - Prevent overlapping syncs (mutex locking)
     * - Staggered sync scheduling (15min intervals)
     * - Priority-based queueing
     * - Health monitoring aggregation
     * - Event broadcasting for UI updates
     */
    export class SyncOrchestrator extends EventEmitter {
      private static instance: SyncOrchestrator;

      private customerSync: CustomerSyncService;
      private productSync: ProductSyncService;
      private priceSync: PriceSyncService;
      private orderSync: OrderHistoryService;
      private ddtSync: any; // TODO: Add proper DDT service type
      private invoiceSync: any; // TODO: Add proper Invoice service type

      private activeSyncType: SyncType | null = null;
      private syncQueue: Array<{ type: SyncType; mode: 'full' | 'incremental' | 'auto'; priority: number }> = [];
      private syncInProgress = false;

      // Smart Customer Sync: track active order form sessions
      private orderFormActiveSessions = 0;
      private safetyTimeout: NodeJS.Timeout | null = null;
      private readonly SAFETY_TIMEOUT_MS = 10 * 60 * 1000; // 10 minutes

      private syncStatuses: Map<SyncType, SyncStatus> = new Map([
        ['customers', { type: 'customers', status: 'idle' }],
        ['products', { type: 'products', status: 'idle' }],
        ['prices', { type: 'prices', status: 'idle' }],
        ['orders', { type: 'orders', status: 'idle' }],
        ['ddt', { type: 'ddt', status: 'idle' }],
        ['invoices', { type: 'invoices', status: 'idle' }]
      ]);

      private constructor() {
        super();
        this.customerSync = CustomerSyncService.getInstance();
        this.productSync = ProductSyncService.getInstance();
        this.priceSync = PriceSyncService.getInstance();
        this.orderSync = OrderHistoryService.getInstance();
      }

      static getInstance(): SyncOrchestrator {
        if (!SyncOrchestrator.instance) {
          SyncOrchestrator.instance = new SyncOrchestrator();
        }
        return SyncOrchestrator.instance;
      }

      /**
       * Request sync with priority queueing
       * @param type Sync type
       * @param mode full, incremental, or auto
       * @param priority Higher number = higher priority (orders=4, customers=3, products=2, prices=1)
       */
      async requestSync(type: SyncType, mode: 'full' | 'incremental' | 'auto' = 'auto', priority?: number): Promise<void> {
        // Determine priority if not provided
        const syncPriority = priority ?? this.getDefaultPriority(type);

        logger.info(`Sync requested: ${type} (mode: ${mode}, priority: ${syncPriority})`);

        // If sync in progress, queue the request
        if (this.syncInProgress) {
          this.syncQueue.push({ type, mode, priority: syncPriority });
          this.syncQueue.sort((a, b) => b.priority - a.priority); // Sort by priority (desc)

          this.updateSyncStatus(type, 'queued');
          logger.info(`Sync queued: ${type} (queue length: ${this.syncQueue.length})`);
          return;
        }

        // Execute sync immediately
        await this.executeSync(type, mode);
      }

      /**
       * Execute sync with mutex lock
       */
      private async executeSync(type: SyncType, mode: 'full' | 'incremental' | 'auto'): Promise<void> {
        this.syncInProgress = true;
        this.activeSyncType = type;

        this.updateSyncStatus(type, 'running', { startedAt: new Date() });

        try {
          logger.info(`üîí Sync started: ${type} (mode: ${mode})`);

          // Execute appropriate sync service
          switch (type) {
            case 'customers':
              await this.customerSync.syncCustomersWithRetry?.(mode) || await this.customerSync.syncCustomers();
              break;
            case 'products':
              await this.productSync.syncProductsWithRetry?.(mode) || await this.productSync.syncProducts();
              break;
            case 'prices':
              await this.priceSync.syncPricesWithRetry?.(mode) || await this.priceSync.syncPrices();
              break;
            case 'orders':
              await this.orderSync.syncOrdersWithRetry?.(mode) || await this.orderSync.syncOrders();
              break;
            case 'ddt':
              await this.ddtSync.syncDDTWithRetry?.(mode) || await this.ddtSync.syncDDT();
              break;
            case 'invoices':
              await this.invoiceSync.syncInvoicesWithRetry?.(mode) || await this.invoiceSync.syncInvoices();
              break;
          }

          this.updateSyncStatus(type, 'completed', { completedAt: new Date() });
          logger.info(`‚úÖ Sync completed: ${type}`);

        } catch (error) {
          this.updateSyncStatus(type, 'error', {
            completedAt: new Date(),
            error: error instanceof Error ? error.message : 'Unknown error'
          });
          logger.error(`‚ùå Sync failed: ${type}`, { error });
        } finally {
          this.syncInProgress = false;
          this.activeSyncType = null;

          // Process next queued sync
          await this.processQueue();
        }
      }

      /**
       * Process next sync from queue
       */
      private async processQueue(): Promise<void> {
        if (this.syncQueue.length === 0) {
          logger.info('Sync queue empty');
          return;
        }

        const next = this.syncQueue.shift()!;
        logger.info(`Processing next queued sync: ${next.type}`);
        await this.executeSync(next.type, next.mode);
      }

      /**
       * Get default priority for sync type
       */
      private getDefaultPriority(type: SyncType): number {
        const priorities: Record<SyncType, number> = {
          orders: 6,      // Highest priority (real-time data, most critical)
          customers: 5,   // High priority (needed for orders)
          ddt: 4,         // Medium-high priority (transport documents)
          invoices: 3,    // Medium priority (financial data)
          prices: 2,      // Lower priority (pricing data)
          products: 1     // Lowest priority (catalog changes rare)
        };
        return priorities[type];
      }

      /**
       * Smart Customer Sync - triggered when entering order form
       * Syncs only recent changes (last 10 minutes) for fast execution
       */
      async smartCustomerSync(userId: string): Promise<void> {
        logger.info(`[SmartCustomerSync] Triggered by user ${userId}`);

        try {
          // Pause other syncs
          await this.pauseAllExceptCustomers();

          // Increment session counter
          this.orderFormActiveSessions++;
          logger.info(`[SmartCustomerSync] Active sessions: ${this.orderFormActiveSessions}`);

          // Set safety timeout (auto-resume after 10 minutes)
          this.setSafetyTimeout();

          // Execute fast customer sync (last 10 minutes only)
          await this.customerSync.smartSync?.(10, 100) || await this.customerSync.syncCustomers();

          logger.info(`[SmartCustomerSync] Completed successfully`);

        } catch (error) {
          logger.error(`[SmartCustomerSync] Failed`, { error });
          // Don't resume syncs on error - user may still be on form
        }
      }

      /**
       * Resume other syncs when user exits order form
       */
      resumeOtherSyncs(userId: string): void {
        this.orderFormActiveSessions = Math.max(0, this.orderFormActiveSessions - 1);
        logger.info(`[SmartCustomerSync] Session ended for user ${userId}. Active sessions: ${this.orderFormActiveSessions}`);

        // Only resume if no active sessions
        if (this.orderFormActiveSessions === 0) {
          this.clearSafetyTimeout();
          this.resumeAllSyncs();
          logger.info(`[SmartCustomerSync] All sessions ended. Syncs resumed.`);
        }
      }

      /**
       * Pause all syncs except customers
       */
      private async pauseAllExceptCustomers(): Promise<void> {
        logger.info('[SyncOrchestrator] Pausing all syncs except customers...');
        // Pause logic will be implemented when integrating with scheduled syncs
        // For now, this is a placeholder
      }

      /**
       * Resume all paused syncs
       */
      private resumeAllSyncs(): void {
        logger.info('[SyncOrchestrator] Resuming all syncs...');
        // Resume logic will be implemented when integrating with scheduled syncs
      }

      /**
       * Set safety timeout to auto-resume syncs after 10 minutes
       */
      private setSafetyTimeout(): void {
        this.clearSafetyTimeout();

        this.safetyTimeout = setTimeout(() => {
          logger.warn('[SmartCustomerSync] Safety timeout reached! Force resuming syncs...');
          this.orderFormActiveSessions = 0;
          this.resumeAllSyncs();
        }, this.SAFETY_TIMEOUT_MS);
      }

      /**
       * Clear safety timeout
       */
      private clearSafetyTimeout(): void {
        if (this.safetyTimeout) {
          clearTimeout(this.safetyTimeout);
          this.safetyTimeout = null;
        }
      }

      /**
       * Update sync status and broadcast event
       */
      private updateSyncStatus(type: SyncType, status: SyncStatus['status'], extra?: Partial<SyncStatus>): void {
        const current = this.syncStatuses.get(type)!;
        const updated = { ...current, status, ...extra };
        this.syncStatuses.set(type, updated);

        this.emit('syncStatusChanged', updated);
      }

      /**
       * Get current sync statuses
       */
      getSyncStatuses(): Map<SyncType, SyncStatus> {
        return new Map(this.syncStatuses);
      }

      /**
       * Get aggregated health status for all sync services
       */
      getAggregatedHealth(): {
        allHealthy: boolean;
        services: Record<SyncType, any>;
      } {
        const services = {
          customers: this.customerSync.getSyncHealth?.() || { isHealthy: true },
          products: this.productSync.getSyncHealth?.() || { isHealthy: true },
          prices: this.priceSync.getSyncHealth?.() || { isHealthy: true },
          orders: this.orderSync.getSyncHealth?.() || { isHealthy: true },
          ddt: this.ddtSync?.getSyncHealth?.() || { isHealthy: true },
          invoices: this.invoiceSync?.getSyncHealth?.() || { isHealthy: true }
        };

        const allHealthy = Object.values(services).every(s => s.isHealthy);

        return { allHealthy, services };
      }

      /**
       * Get Smart Customer Sync status
       */
      getSmartSyncStatus(): {
        activeSessions: number;
        syncsPayused: boolean;
        safetyTimeoutActive: boolean;
      } {
        return {
          activeSessions: this.orderFormActiveSessions,
          syncsPayused: this.orderFormActiveSessions > 0,
          safetyTimeoutActive: this.safetyTimeout !== null
        };
      }
    }
    ```

    Why orchestrator: Centralized control prevents race conditions, enables intelligent scheduling, provides unified monitoring.
  </action>
  <verify>
    npm run typecheck passes
    SyncOrchestrator compiles without errors
  </verify>
  <done>
    SyncOrchestrator created with mutex locking.
    Priority-based queueing system.
    Event-driven status updates.
    Aggregated health monitoring.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SyncOrchestrator in index.ts</name>
  <files>
    archibald-web-app/backend/src/index.ts
  </files>
  <action>
    Replace direct sync service calls with orchestrator:

    1. Initialize orchestrator:
    ```typescript
    import { SyncOrchestrator } from './sync-orchestrator';
    const syncOrchestrator = SyncOrchestrator.getInstance();
    ```

    2. Replace existing sync endpoints to use orchestrator:
    ```typescript
    // Customer sync endpoints
    app.post('/api/sync/customers/full', authenticateJWT, async (req, res) => {
      await syncOrchestrator.requestSync('customers', 'full');
      res.json({ success: true, message: 'Customer sync queued' });
    });

    // Similar for products, prices, orders
    ```

    3. Add orchestrator status endpoint:
    ```typescript
    app.get('/api/sync/status', authenticateJWT, async (req, res) => {
      const statuses = syncOrchestrator.getSyncStatuses();
      const health = syncOrchestrator.getAggregatedHealth();
      const smartSyncStatus = syncOrchestrator.getSmartSyncStatus();

      res.json({
        success: true,
        data: {
          statuses: Array.from(statuses.values()),
          health,
          smartSync: smartSyncStatus
        }
      });
    });
    ```

    4. Add Smart Customer Sync endpoints:
    ```typescript
    // Trigger Smart Customer Sync when entering order form
    app.post('/api/customers/smart-sync', authenticateJWT, async (req, res) => {
      const userId = req.user!.id;
      await syncOrchestrator.smartCustomerSync(userId);
      res.json({ success: true, message: 'Smart customer sync completed' });
    });

    // Resume syncs when exiting order form
    app.post('/api/customers/resume-syncs', authenticateJWT, async (req, res) => {
      const userId = req.user!.id;
      syncOrchestrator.resumeOtherSyncs(userId);
      res.json({ success: true, message: 'Syncs resumed' });
    });
    ```

    Why integration: All sync requests go through orchestrator, ensuring no overlaps. Smart Customer Sync provides fast on-demand updates when needed.
  </action>
  <verify>
    npm run typecheck passes
    Sync endpoints route through orchestrator
  </verify>
  <done>
    SyncOrchestrator integrated in index.ts.
    All sync endpoints use orchestrator.
    GET /api/sync/status endpoint added.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Smart Customer Sync in CustomerSyncService and OrderForm</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
    archibald-web-app/frontend/src/components/OrderForm.tsx
  </files>
  <action>
    1. Add smartSync method to CustomerSyncService:
    ```typescript
    /**
     * Smart Customer Sync - syncs only recent changes (last N minutes)
     * Used when entering order form for fast on-demand updates
     *
     * @param lookbackMinutes How many minutes back to check for changes (default: 10)
     * @param maxRecords Maximum records to sync (default: 100)
     */
    async smartSync(lookbackMinutes: number = 10, maxRecords: number = 100): Promise<void> {
      logger.info(`[CustomerSync] Starting smart sync (lookback: ${lookbackMinutes}min, max: ${maxRecords})`);

      const startTime = Date.now();

      try {
        // Download and parse customer PDF
        const pdfBuffer = await this.bot.downloadFile(CUSTOMER_PDF_URL);
        const parsedData = await this.pdfParser.parseCustomerPDF(pdfBuffer);

        // Filter only recent customers (last N minutes)
        const cutoffDate = new Date(Date.now() - lookbackMinutes * 60 * 1000);
        const recentCustomers = parsedData.customers.filter(c => {
          const lastModified = c.lastModified ? new Date(c.lastModified) : null;
          return lastModified && lastModified >= cutoffDate;
        }).slice(0, maxRecords);

        logger.info(`[CustomerSync] Found ${recentCustomers.length} recent customers`);

        if (recentCustomers.length === 0) {
          logger.info('[CustomerSync] No recent changes, smart sync complete');
          return;
        }

        // Sync only recent customers
        await this.syncCustomerBatch(recentCustomers);

        const duration = Date.now() - startTime;
        logger.info(`[CustomerSync] Smart sync completed in ${duration}ms`);

      } catch (error) {
        logger.error('[CustomerSync] Smart sync failed', { error });
        throw error;
      }
    }
    ```

    2. Update OrderForm.tsx to trigger Smart Customer Sync:
    ```typescript
    // In OrderForm.tsx component
    useEffect(() => {
      // Trigger Smart Customer Sync when mounting (entering order form)
      const triggerSmartSync = async () => {
        try {
          await fetch('/api/customers/smart-sync', {
            method: 'POST',
            headers: { 'Authorization': `Bearer ${token}` }
          });
          console.log('Smart customer sync completed');
        } catch (error) {
          console.error('Smart customer sync failed:', error);
        }
      };

      triggerSmartSync();

      // Resume syncs when unmounting (leaving order form)
      return () => {
        fetch('/api/customers/resume-syncs', {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}` }
        }).catch(err => console.error('Failed to resume syncs:', err));
      };
    }, []);
    ```

    3. Modify OrderForm.tsx draft save behavior:
    ```typescript
    // Remove this line from handleSaveDraft:
    // navigate("/drafts"); ‚ùå

    // Instead, show success banner and stay on page:
    setSuccessBanner(`‚úÖ Bozza salvata! (${totalDrafts} bozze totali)`);

    // Add "Done" button to OrderForm header:
    <Button onClick={() => navigate("/drafts")}>Done</Button>
    ```

    Why Smart Sync: Provides fast (3-5s) on-demand customer updates when entering order form, preventing "customer not found" issues while minimizing resource usage.
    Why stay on page: Enables multi-order workflow (create 5+ orders sequentially) without forced navigation after each save.
  </action>
  <verify>
    1. Enter order form ‚Üí smart customer sync triggers
    2. Smart sync completes in 3-5 seconds (not 15-20s)
    3. Save draft ‚Üí stays on order form (no navigation)
    4. Success banner shows draft count
    5. Click "Done" ‚Üí navigates to /drafts
    6. Leave order form ‚Üí syncs resume automatically
    7. Open multiple tabs ‚Üí session counter increments
    8. Close all tabs ‚Üí syncs resume
    9. Leave form open 11 minutes ‚Üí safety timeout auto-resumes syncs
  </verify>
  <done>
    Smart Customer Sync implemented.
    CustomerSyncService.smartSync() method added.
    OrderForm.tsx triggers smart sync on mount.
    OrderForm.tsx resumes syncs on unmount.
    Draft save no longer navigates away.
    "Done" button added for explicit exit.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
- [ ] npm run typecheck passes
- [ ] SyncOrchestrator class created with mutex
- [ ] All 6 sync types included (customers, products, prices, orders, ddt, invoices)
- [ ] Priority-based queueing functional (orders=6, customers=5, ddt=4, invoices=3, prices=2, products=1)
- [ ] Smart Customer Sync methods implemented
- [ ] Session reference counting works
- [ ] Safety timeout (10 min) functional
- [ ] Orchestrator integrated in index.ts
- [ ] Sync endpoints route through orchestrator
- [ ] Smart sync endpoints added (/api/customers/smart-sync, /api/customers/resume-syncs)
- [ ] CustomerSyncService.smartSync() implemented
- [ ] OrderForm.tsx triggers smart sync on mount
- [ ] OrderForm.tsx resumes syncs on unmount
- [ ] OrderForm.tsx draft save stays on page (no navigate)
- [ ] OrderForm.tsx "Done" button added
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- SyncOrchestrator prevents overlapping syncs
- Priority queueing (orders=6 > customers=5 > ddt=4 > invoices=3 > prices=2 > products=1)
- All 6 sync types managed (customers, products, prices, orders, ddt, invoices)
- Smart Customer Sync triggers on order form entry
- Smart Customer Sync completes in 3-5 seconds (vs 15-20s full sync)
- Session reference counting tracks multiple tabs
- Safety timeout auto-resumes syncs after 10 minutes
- Draft save stays on order form (multi-order workflow supported)
- "Done" button provides explicit exit
- Event-driven status updates
- Aggregated health monitoring
- All sync requests coordinated
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/22-sync-orchestration-layer/22-01-SUMMARY.md`
</output>
