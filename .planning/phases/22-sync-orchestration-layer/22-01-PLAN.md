---
phase: 22-sync-orchestration-layer
plan: 01
type: execute
---

<objective>
Create SyncOrchestrator to coordinate all sync services and prevent overlapping executions.

Purpose: Central coordinator to manage sync scheduling, prevent conflicts, and implement staggered sync intervals.
Output: SyncOrchestrator class managing customers, products, prices, orders sync services with mutex locking.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/backend/src/product-sync-service.ts
@archibald-web-app/backend/src/price-sync-service.ts
@archibald-web-app/backend/src/order-history-service.ts

**Current state:**
- Four independent sync services (customers, products, prices, orders)
- Each has auto-sync with independent intervals (30min, 30min, 60min, ?)
- No coordination ‚Üí potential overlapping syncs ‚Üí resource contention
- activeOperation lock in index.ts (basic mutex) but not comprehensive

**Orchestration requirements:**
- Single coordinator manages all sync services
- Mutex locking: only one sync at a time
- Staggered scheduling: 15-minute intervals between syncs
- Priority handling: orders > customers > products > prices
- Event-driven architecture for status updates
- Health monitoring for all services

**Design pattern:**
- SyncOrchestrator singleton
- Event emitter for progress broadcasts
- Queueing system for sync requests
- Configurable sync schedule
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SyncOrchestrator class with mutex locking</name>
  <files>
    archibald-web-app/backend/src/sync-orchestrator.ts
  </files>
  <action>
    Create SyncOrchestrator singleton with comprehensive mutex:

    ```typescript
    import { EventEmitter } from 'events';
    import { CustomerSyncService } from './customer-sync-service';
    import { ProductSyncService } from './product-sync-service';
    import { PriceSyncService } from './price-sync-service';
    import { OrderHistoryService } from './order-history-service';
    import { logger } from './logger';

    export type SyncType = 'customers' | 'products' | 'prices' | 'orders';

    export interface SyncStatus {
      type: SyncType;
      status: 'idle' | 'queued' | 'running' | 'completed' | 'error';
      startedAt?: Date;
      completedAt?: Date;
      error?: string;
    }

    /**
     * SyncOrchestrator - Centralized coordinator for all sync services
     *
     * Responsibilities:
     * - Prevent overlapping syncs (mutex locking)
     * - Staggered sync scheduling (15min intervals)
     * - Priority-based queueing
     * - Health monitoring aggregation
     * - Event broadcasting for UI updates
     */
    export class SyncOrchestrator extends EventEmitter {
      private static instance: SyncOrchestrator;

      private customerSync: CustomerSyncService;
      private productSync: ProductSyncService;
      private priceSync: PriceSyncService;
      private orderSync: OrderHistoryService;

      private activeSyncType: SyncType | null = null;
      private syncQueue: Array<{ type: SyncType; mode: 'full' | 'incremental' | 'auto'; priority: number }> = [];
      private syncInProgress = false;

      private syncStatuses: Map<SyncType, SyncStatus> = new Map([
        ['customers', { type: 'customers', status: 'idle' }],
        ['products', { type: 'products', status: 'idle' }],
        ['prices', { type: 'prices', status: 'idle' }],
        ['orders', { type: 'orders', status: 'idle' }]
      ]);

      private constructor() {
        super();
        this.customerSync = CustomerSyncService.getInstance();
        this.productSync = ProductSyncService.getInstance();
        this.priceSync = PriceSyncService.getInstance();
        this.orderSync = OrderHistoryService.getInstance();
      }

      static getInstance(): SyncOrchestrator {
        if (!SyncOrchestrator.instance) {
          SyncOrchestrator.instance = new SyncOrchestrator();
        }
        return SyncOrchestrator.instance;
      }

      /**
       * Request sync with priority queueing
       * @param type Sync type
       * @param mode full, incremental, or auto
       * @param priority Higher number = higher priority (orders=4, customers=3, products=2, prices=1)
       */
      async requestSync(type: SyncType, mode: 'full' | 'incremental' | 'auto' = 'auto', priority?: number): Promise<void> {
        // Determine priority if not provided
        const syncPriority = priority ?? this.getDefaultPriority(type);

        logger.info(`Sync requested: ${type} (mode: ${mode}, priority: ${syncPriority})`);

        // If sync in progress, queue the request
        if (this.syncInProgress) {
          this.syncQueue.push({ type, mode, priority: syncPriority });
          this.syncQueue.sort((a, b) => b.priority - a.priority); // Sort by priority (desc)

          this.updateSyncStatus(type, 'queued');
          logger.info(`Sync queued: ${type} (queue length: ${this.syncQueue.length})`);
          return;
        }

        // Execute sync immediately
        await this.executeSync(type, mode);
      }

      /**
       * Execute sync with mutex lock
       */
      private async executeSync(type: SyncType, mode: 'full' | 'incremental' | 'auto'): Promise<void> {
        this.syncInProgress = true;
        this.activeSyncType = type;

        this.updateSyncStatus(type, 'running', { startedAt: new Date() });

        try {
          logger.info(`üîí Sync started: ${type} (mode: ${mode})`);

          // Execute appropriate sync service
          switch (type) {
            case 'customers':
              await this.customerSync.syncCustomersWithRetry?.(mode) || await this.customerSync.syncCustomers();
              break;
            case 'products':
              await this.productSync.syncProductsWithRetry?.(mode) || await this.productSync.syncProducts();
              break;
            case 'prices':
              await this.priceSync.syncPricesWithRetry?.(mode) || await this.priceSync.syncPrices();
              break;
            case 'orders':
              await this.orderSync.syncOrdersWithRetry?.(mode) || await this.orderSync.syncOrders();
              break;
          }

          this.updateSyncStatus(type, 'completed', { completedAt: new Date() });
          logger.info(`‚úÖ Sync completed: ${type}`);

        } catch (error) {
          this.updateSyncStatus(type, 'error', {
            completedAt: new Date(),
            error: error instanceof Error ? error.message : 'Unknown error'
          });
          logger.error(`‚ùå Sync failed: ${type}`, { error });
        } finally {
          this.syncInProgress = false;
          this.activeSyncType = null;

          // Process next queued sync
          await this.processQueue();
        }
      }

      /**
       * Process next sync from queue
       */
      private async processQueue(): Promise<void> {
        if (this.syncQueue.length === 0) {
          logger.info('Sync queue empty');
          return;
        }

        const next = this.syncQueue.shift()!;
        logger.info(`Processing next queued sync: ${next.type}`);
        await this.executeSync(next.type, next.mode);
      }

      /**
       * Get default priority for sync type
       */
      private getDefaultPriority(type: SyncType): number {
        const priorities: Record<SyncType, number> = {
          orders: 4,      // Highest priority (real-time data)
          customers: 3,   // High priority (needed for orders)
          products: 2,    // Medium priority (needed for orders)
          prices: 1       // Low priority (less critical)
        };
        return priorities[type];
      }

      /**
       * Update sync status and broadcast event
       */
      private updateSyncStatus(type: SyncType, status: SyncStatus['status'], extra?: Partial<SyncStatus>): void {
        const current = this.syncStatuses.get(type)!;
        const updated = { ...current, status, ...extra };
        this.syncStatuses.set(type, updated);

        this.emit('syncStatusChanged', updated);
      }

      /**
       * Get current sync statuses
       */
      getSyncStatuses(): Map<SyncType, SyncStatus> {
        return new Map(this.syncStatuses);
      }

      /**
       * Get aggregated health status for all sync services
       */
      getAggregatedHealth(): {
        allHealthy: boolean;
        services: Record<SyncType, any>;
      } {
        const services = {
          customers: this.customerSync.getSyncHealth?.() || { isHealthy: true },
          products: this.productSync.getSyncHealth?.() || { isHealthy: true },
          prices: this.priceSync.getSyncHealth?.() || { isHealthy: true },
          orders: this.orderSync.getSyncHealth?.() || { isHealthy: true }
        };

        const allHealthy = Object.values(services).every(s => s.isHealthy);

        return { allHealthy, services };
      }
    }
    ```

    Why orchestrator: Centralized control prevents race conditions, enables intelligent scheduling, provides unified monitoring.
  </action>
  <verify>
    npm run typecheck passes
    SyncOrchestrator compiles without errors
  </verify>
  <done>
    SyncOrchestrator created with mutex locking.
    Priority-based queueing system.
    Event-driven status updates.
    Aggregated health monitoring.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SyncOrchestrator in index.ts</name>
  <files>
    archibald-web-app/backend/src/index.ts
  </files>
  <action>
    Replace direct sync service calls with orchestrator:

    1. Initialize orchestrator:
    ```typescript
    import { SyncOrchestrator } from './sync-orchestrator';
    const syncOrchestrator = SyncOrchestrator.getInstance();
    ```

    2. Replace existing sync endpoints to use orchestrator:
    ```typescript
    // Customer sync endpoints
    app.post('/api/sync/customers/full', authenticateJWT, async (req, res) => {
      await syncOrchestrator.requestSync('customers', 'full');
      res.json({ success: true, message: 'Customer sync queued' });
    });

    // Similar for products, prices, orders
    ```

    3. Add orchestrator status endpoint:
    ```typescript
    app.get('/api/sync/status', authenticateJWT, async (req, res) => {
      const statuses = syncOrchestrator.getSyncStatuses();
      const health = syncOrchestrator.getAggregatedHealth();

      res.json({
        success: true,
        data: {
          statuses: Array.from(statuses.values()),
          health
        }
      });
    });
    ```

    Why integration: All sync requests go through orchestrator, ensuring no overlaps.
  </action>
  <verify>
    npm run typecheck passes
    Sync endpoints route through orchestrator
  </verify>
  <done>
    SyncOrchestrator integrated in index.ts.
    All sync endpoints use orchestrator.
    GET /api/sync/status endpoint added.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
- [ ] npm run typecheck passes
- [ ] SyncOrchestrator class created with mutex
- [ ] Priority-based queueing functional
- [ ] Orchestrator integrated in index.ts
- [ ] Sync endpoints route through orchestrator
- [ ] No TypeScript errors
</verification>

<success_criteria>
- All tasks completed
- SyncOrchestrator prevents overlapping syncs
- Priority queueing (orders > customers > products > prices)
- Event-driven status updates
- Aggregated health monitoring
- All sync requests coordinated
- No errors or warnings introduced
</success_criteria>

<output>
After completion, create `.planning/phases/22-sync-orchestration-layer/22-01-SUMMARY.md`
</output>
