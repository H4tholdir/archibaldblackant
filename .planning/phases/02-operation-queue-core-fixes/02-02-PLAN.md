---
phase: 02-operation-queue-core-fixes
plan: 02
type: execute
---

<objective>
Fix the preemption race condition and add per-operation-type timeout to prevent hung workers.

Purpose: Currently preemption uses a fixed 2-second wait that rarely works, and there's no timeout — a hung Puppeteer session blocks the worker forever. This plan makes preemption reliable and adds safety timeouts.
Output: Preemption uses cancelJob + polling with timeout. Handler execution wrapped in per-type timeout. Worker lockDuration configured for long sync operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-operation-queue-core-fixes/02-RESEARCH.md
@.planning/phases/02-operation-queue-core-fixes/02-CONTEXT.md
@.planning/phases/02-operation-queue-core-fixes/02-01-SUMMARY.md

# Key source files:
@archibald-web-app/backend/src/operations/operation-processor.ts
@archibald-web-app/backend/src/operations/operation-processor.spec.ts
@archibald-web-app/backend/src/operations/operation-types.ts
@archibald-web-app/backend/src/operations/agent-lock.ts
@archibald-web-app/backend/src/operations/agent-lock.spec.ts
@archibald-web-app/backend/src/main.ts

**Depends on:** Plan 02-01 (AbortSignal flows through the stack)

**Research findings (from 02-RESEARCH.md):**
- BullMQ `worker.cancelJob(jobId)` aborts the signal for that specific job
- Preemption pattern: cancelJob → poll for lock release → acquire (with max timeout)
- Timeout pattern: AbortController + setTimeout (from BullMQ docs)
- `UnrecoverableError` prevents retry on timeout (import from bullmq)
- lockDuration must be >= max handler timeout to prevent stalled detection
- Pitfall: stalled job detection conflicts with timeout if lockDuration too low
- Current PREEMPTION_WAIT_MS = 2000 is inadequate — sync can take minutes
- Current concurrency: 1 means preemption code isn't exercised yet, but must be correct for Phase 3
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix preemption with cancelJob + polling wait</name>
  <files>
    archibald-web-app/backend/src/operations/operation-processor.ts,
    archibald-web-app/backend/src/operations/operation-processor.spec.ts,
    archibald-web-app/backend/src/main.ts
  </files>
  <action>
1. In operation-processor.ts:
   - Add `cancelJob: (jobId: string) => boolean` to `ProcessorDeps` type. This function wraps `worker.cancelJob()`.
   - Replace the fixed-wait preemption logic in processJob. Current code:
     ```
     if (acquireResult.preemptable) {
       if (activeJob.requestStop) activeJob.requestStop();
       await new Promise(resolve => setTimeout(resolve, PREEMPTION_WAIT_MS));
       acquireResult = agentLock.acquire(userId, job.id, type);
     }
     ```
     New logic:
     ```
     if (acquireResult.preemptable) {
       const { activeJob } = acquireResult;
       // Cancel via BullMQ — triggers AbortSignal on the active job
       deps.cancelJob(activeJob.jobId);
       // Also call requestStop as fallback (in case active job predates signal wiring)
       if (activeJob.requestStop) activeJob.requestStop();

       // Poll for lock release with timeout
       const PREEMPTION_TIMEOUT_MS = 30_000;
       const POLL_INTERVAL_MS = 500;
       let waited = 0;
       while (waited < PREEMPTION_TIMEOUT_MS) {
         await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL_MS));
         waited += POLL_INTERVAL_MS;
         acquireResult = agentLock.acquire(userId, job.id, type);
         if (acquireResult.acquired) break;
       }
     }
     ```
   - Remove or update `PREEMPTION_WAIT_MS` constant (no longer used for fixed wait). Keep `PREEMPTION_TIMEOUT_MS = 30_000` and `POLL_INTERVAL_MS = 500` as module constants.
   - Keep `REQUEUE_DELAY_MS` for the requeue path.

2. In main.ts:
   - Pass `cancelJob: (jobId) => worker.cancelJob(jobId)` in the ProcessorDeps when creating the processor.
   - Note: `worker.cancelJob()` returns boolean (true if job was active). The processor doesn't need the return value for correctness but can log it.

3. In operation-processor.spec.ts:
   - Add `cancelJob` mock to `createProcessor` helper: `cancelJob: vi.fn().mockReturnValue(true)`
   - Update the existing preemption test ("calls requestStop on active sync when write job arrives"):
     - Verify `cancelJob` is called with the active job's ID
     - Verify requestStop is also called (fallback)
     - Mock agentLock.acquire to return { acquired: true } on the Nth call (simulating lock release after polling)
   - Add test: "times out preemption after max wait and requeues" — mock acquire to always return not-acquired, verify job is requeued after timeout
   - Add test: "acquires lock during polling after cancel" — mock acquire to fail first 3 times then succeed, verify handler executes

Do NOT use fake timers (vi.useFakeTimers) for the polling tests — use real short intervals. Set POLL_INTERVAL_MS as an injectable parameter or use very short intervals in tests. Alternatively, extract the polling loop into a testable helper.
  </action>
  <verify>
    npm run build --prefix archibald-web-app/backend
    npm test --prefix archibald-web-app/backend
  </verify>
  <done>
    - Preemption uses cancelJob + polling instead of fixed 2s wait
    - cancelJob dependency added to ProcessorDeps and wired in main.ts
    - PREEMPTION_WAIT_MS replaced with PREEMPTION_TIMEOUT_MS (30s) + POLL_INTERVAL_MS (500ms)
    - 3+ new/updated preemption tests pass
    - All existing tests pass
    - TypeScript compiles
  </done>
</task>

<task type="auto">
  <name>Task 2: Add per-operation-type handler timeout + lockDuration</name>
  <files>
    archibald-web-app/backend/src/operations/operation-processor.ts,
    archibald-web-app/backend/src/operations/operation-processor.spec.ts,
    archibald-web-app/backend/src/operations/operation-types.ts,
    archibald-web-app/backend/src/main.ts
  </files>
  <action>
1. In operation-types.ts, add timeout constants:
   ```
   const OPERATION_TIMEOUTS: Record<OperationType, number> = {
     'submit-order': 120_000,        // 2 min
     'create-customer': 120_000,     // 2 min
     'update-customer': 120_000,     // 2 min
     'send-to-verona': 120_000,      // 2 min
     'edit-order': 120_000,          // 2 min
     'delete-order': 60_000,         // 1 min
     'download-ddt-pdf': 60_000,     // 1 min
     'download-invoice-pdf': 60_000, // 1 min
     'sync-order-articles': 180_000, // 3 min
     'sync-customers': 300_000,      // 5 min
     'sync-orders': 300_000,         // 5 min
     'sync-ddt': 300_000,            // 5 min
     'sync-invoices': 300_000,       // 5 min
     'sync-products': 300_000,       // 5 min
     'sync-prices': 300_000,         // 5 min
   };
   ```
   Export `OPERATION_TIMEOUTS`.

2. In operation-processor.ts, wrap handler execution with timeout:
   - After acquiring browser context but before calling handler, create a timeout AbortController:
     ```
     const timeoutMs = OPERATION_TIMEOUTS[type] ?? 120_000;
     const timeoutController = new AbortController();
     const timer = setTimeout(() => timeoutController.abort(), timeoutMs);

     // Combine BullMQ signal + timeout signal
     // If either aborts, the combined signal aborts
     const combinedAbort = () => { timeoutController.abort(); };
     job.signal?.addEventListener('abort', combinedAbort, { once: true });
     ```
   - Pass `timeoutController.signal` to handler (instead of raw `job.signal`)
   - In the catch block, detect AbortError:
     ```
     if (error instanceof Error && error.name === 'AbortError') {
       // Don't re-throw as retriable — timeout means handler is stuck
       throw new UnrecoverableError(`Handler timeout after ${timeoutMs}ms for ${type}`);
     }
     ```
   - In finally block: `clearTimeout(timer);`
   - Import `UnrecoverableError` from 'bullmq'

3. In main.ts (Worker options):
   - Add `lockDuration: 600_000` (10 minutes) to Worker options. This must be >= the max operation timeout (5 min for syncs) plus buffer.
   - Keep `concurrency: 1` (Phase 3 changes this)

4. In operation-processor.spec.ts:
   - Add test: "throws UnrecoverableError when handler exceeds timeout" — create handler that never resolves, verify UnrecoverableError is thrown after timeout. Use a very short timeout (50ms) in the test by mocking OPERATION_TIMEOUTS or using a specific operation type with short timeout.
   - Add test: "clears timeout on successful handler completion" — verify no lingering timers
   - Add test: "combined signal aborts on both BullMQ cancel and timeout"

For the timeout tests: Since we can't easily mock the OPERATION_TIMEOUTS constant, consider making the timeout configurable via ProcessorDeps (e.g., `getTimeout?: (type: OperationType) => number`), or use operation-types.ts directly and just test with very fast handlers + artificially slow ones.
  </action>
  <verify>
    npm run build --prefix archibald-web-app/backend
    npm test --prefix archibald-web-app/backend
  </verify>
  <done>
    - OPERATION_TIMEOUTS defined for all 15 operation types
    - Handler execution wrapped in timeout with AbortController
    - BullMQ signal and timeout signal combined correctly
    - Timeout throws UnrecoverableError (no retry on timeout)
    - Worker lockDuration set to 600_000 (10 min)
    - 3+ new timeout tests pass
    - All existing tests pass
    - TypeScript compiles
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix archibald-web-app/backend` passes
- [ ] `npm test --prefix archibald-web-app/backend` passes
- [ ] Preemption no longer uses fixed 2s wait
- [ ] cancelJob is called during preemption
- [ ] Handler execution has timeout per operation type
- [ ] UnrecoverableError thrown on timeout (prevents useless retry)
- [ ] lockDuration >= max timeout in Worker config
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Preemption uses cancelJob + polling (max 30s)
- All 15 operation types have defined timeouts
- Handler execution timeout prevents hung workers
- UnrecoverableError on timeout prevents retry
- Worker lockDuration prevents stalled detection during long syncs
- All tests pass, TypeScript compiles
</success_criteria>

<output>
After completion, create `.planning/phases/02-operation-queue-core-fixes/02-02-SUMMARY.md`
</output>
