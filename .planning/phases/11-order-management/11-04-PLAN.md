---
dependencies:
  - .planning/phases/11-order-management/11-01-RESEARCH.md
  - .planning/phases/11-order-management/11-02-PLAN.md
  - .planning/phases/11-order-management/11-03-PLAN.md
  - archibald-web-app/backend/src/order-history-service.ts
---

# Plan 11-04: Implement Status Tracking Backend with Cache

<objective>
Sync order states from Archibald (Creato, Piazzato, Inviato a Milano, In lavorazione, Spedito, Consegnato) with 2-hour cache TTL and on-demand refresh.
</objective>

<execution_context>
@~/.claude/get-shit-done/references/checkpoints.md
@~/.claude/get-shit-done/references/tdd.md
@archibald-web-app/backend/src/order-history-service.ts
@.planning/phases/11-order-management/11-01-RESEARCH.md
@.planning/phases/10-order-history/10-02-SUMMARY.md
</execution_context>

<context>
## Status Tracking Requirements

From 11-CONTEXT.md:

**States to Track**:
- Creato (only in app, pre-Step 1)
- Piazzato su Archibald (post-Step 1, pre-Step 2)
- Inviato a Milano (post-Step 2)
- In lavorazione
- Spedito (with DDT + tracking number)
- Consegnato

**Data Sources**:
- Order states: Main orders page + ARCHIBALD AGENTI.pptx (reference)
- DDT/Tracking: `CUSTPACKINGSLIPJOUR_ListView` (already implemented in Plan 11-03)

**Synchronization Strategy**:
- **On-demand with cache** (not background job)
- When user opens OrderHistory:
  - If cache is older than **2 hours** → sync from Archibald
  - Otherwise → show cached data
- Reuses existing cache pattern from Phase 10

**Scope**:
- Only orders from **last 3 weeks**
- Reduces data volume and focuses on active orders

## Reusable Patterns from Phase 10

- **Cache Strategy**: 2-hour TTL, on-demand sync (Plan 10-05)
- **BrowserPool**: Per-user locking for concurrent requests
- **Force Sync Button**: Manual refresh when needed (Plan 08-08)
- **Error Handling**: Toast notifications, retry logic

## Implementation Approach

**State Detection Logic**:
1. Check order exists in local database:
   - If not → state = "Creato" (only in app)
2. Check `archibaldOrderId` field:
   - If null → state = "Creato"
   - If present and `sentToMilanoAt` null → state = "Piazzato su Archibald"
   - If present and `sentToMilanoAt` set → check Archibald for progression
3. Scrape order detail page from Archibald:
   - Look for state indicators (from 11-01-RESEARCH.md findings)
   - Date fields provide timeline (Plan 10-03 pattern)
4. Check DDT data (from Plan 11-03):
   - If DDT exists → state = "Spedito" (minimum)
   - Check delivery date to determine if "Consegnato"

**Database Changes**:
- Already added in Plan 11-02: `current_state` field
- Create `order_state_history` table for timeline:
  ```sql
  CREATE TABLE order_state_history (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    order_id TEXT NOT NULL,
    state TEXT NOT NULL,
    changed_at TEXT NOT NULL,
    changed_by TEXT,
    notes TEXT,
    FOREIGN KEY (order_id) REFERENCES orders(id)
  );
  ```

## Out of Scope

- UI timeline components (Plan 11-05)
- Invoice scraping (Plan 11-06)
- Manual state override (future feature)
</context>

<tasks>
## Task 1: Database Schema for State History (type: auto)

**Goal**: Add order_state_history table for timeline tracking.

**Actions**:
1. Update migration `archibald-web-app/backend/migrations/011-order-management.sql`
2. Add table:
   ```sql
   CREATE TABLE order_state_history (
     id INTEGER PRIMARY KEY AUTOINCREMENT,
     order_id TEXT NOT NULL,
     state TEXT NOT NULL,
     changed_at TEXT NOT NULL,
     changed_by TEXT,  -- user_id or 'system'
     notes TEXT,  -- optional context
     FOREIGN KEY (order_id) REFERENCES orders(id)
   );
   CREATE INDEX idx_state_history_order ON order_state_history(order_id);
   CREATE INDEX idx_state_history_changed_at ON order_state_history(changed_at);
   ```
3. Update TypeScript interface in `archibald-web-app/backend/src/order-db.ts`:
   ```typescript
   interface OrderStateHistory {
     id: number;
     orderId: string;
     state: string;
     changedAt: string;  // ISO 8601
     changedBy?: string;
     notes?: string;
   }
   ```
4. Run migration against test database
5. Verify table created

**Acceptance**:
- Migration updated with state history table
- TypeScript types updated
- Indexes created for performance

## Task 2: Implement State Detection Service (type: auto)

**Goal**: Create service to determine current order state from multiple sources.

**Actions**:
1. Create `archibald-web-app/backend/src/order-state-service.ts`
2. Implement `OrderStateService` class with method:
   ```typescript
   async detectOrderState(order: Order): Promise<OrderState>
   ```
3. State detection logic:
   - **If `archibaldOrderId` is null**:
     - Return "creato"
   - **If `archibaldOrderId` present and `sentToMilanoAt` null**:
     - Return "piazzato"
   - **If `sentToMilanoAt` is set**:
     - Check DDT data (from database):
       - If `ddtNumber` present → at least "spedito"
       - Check delivery date: if in past → "consegnato"
       - Otherwise → query Archibald for current state
   - **Query Archibald order detail** (if needed):
     - Navigate to order detail page (reuse Phase 10-03 pattern)
     - Look for state indicators (from 11-01-RESEARCH.md)
     - Parse date fields to determine progression
4. State priority (latest wins):
   - Creato < Piazzato < Inviato a Milano < In lavorazione < Spedito < Consegnato
5. Error handling:
   - Archibald unreachable → use last known state from database
   - State not determinable → default to last known state, log warning

**Acceptance**:
- `OrderStateService` class created
- Multi-source state detection logic
- Graceful fallback to last known state on error
- Comprehensive debug logging

## Task 3: Implement State Sync Service with Cache (type: auto)

**Goal**: Create service to sync order states from Archibald with 2-hour cache.

**Actions**:
1. Create `archibald-web-app/backend/src/order-state-sync-service.ts`
2. Implement `OrderStateSyncService` class with methods:
   ```typescript
   async syncOrderStates(username: string, password: string, forceRefresh: boolean = false): Promise<SyncResult>
   ```
3. Cache management:
   - Check last sync timestamp in cache metadata table (reuse Phase 10 pattern)
   - If last sync < 2 hours ago and not forceRefresh:
     - Return cached states from database
   - Otherwise:
     - Scrape Archibald for order states
     - Update database with new states
     - Record state changes in `order_state_history`
     - Update cache timestamp
4. Sync workflow:
   - Fetch orders from last 3 weeks (filter by `createdAt`)
   - For each order:
     - Call `OrderStateService.detectOrderState()`
     - If state changed:
       - Update `orders.current_state`
       - Insert into `order_state_history`
   - Return sync result: `{ updated: number, unchanged: number, errors: number }`
5. Batch processing:
   - Process orders in parallel (max 5 concurrent)
   - Reuse BrowserContext across multiple orders (performance)
6. Error handling:
   - Continue processing on individual order errors
   - Log errors with order IDs
   - Return partial results if some orders fail

**Acceptance**:
- `OrderStateSyncService` class created
- 2-hour cache TTL enforced
- State changes recorded in history table
- Batch processing for performance
- Comprehensive error handling

## Task 4: Create API Endpoints (type: auto)

**Goal**: Add endpoints for state sync and state history.

**Actions**:
1. Add endpoints to `archibald-web-app/backend/src/index.ts`:
   ```typescript
   POST /api/orders/sync-states        // Sync all order states
   GET /api/orders/:orderId/state-history  // Get state timeline
   ```
2. **Sync states endpoint**:
   - Extract JWT from request (requireAuth middleware)
   - Optional query param: `forceRefresh=true` for manual refresh
   - Fetch user credentials
   - Pause background services (PriorityManager)
   - Call `OrderStateSyncService.syncOrderStates()`
   - Resume background services
   - Return sync result with counts and cache timestamp
3. **State history endpoint**:
   - Extract JWT and orderId
   - Verify order belongs to user
   - Query `order_state_history` table for order
   - Return array of state changes sorted by `changed_at` DESC
4. Response formats:
   ```typescript
   // Sync result
   {
     success: boolean;
     message: string;
     updated: number;
     unchanged: number;
     errors: number;
     cacheTimestamp: string;  // ISO 8601
   }

   // State history
   {
     orderId: string;
     history: Array<{
       state: string;
       changedAt: string;
       changedBy?: string;
       notes?: string;
     }>;
   }
   ```
5. Rate limiting (sync-states only):
   - Max 1 manual sync per 30 minutes per user (unless forceRefresh)

**Acceptance**:
- Both endpoints registered and authenticated
- Sync states uses cache correctly
- State history returned in chronological order
- Rate limiting prevents abuse
- PriorityManager integration for bot safety

## Task 5: Write Unit Tests (type: auto)

**Goal**: TDD test coverage for state detection and sync services.

**Actions**:
1. Create `archibald-web-app/backend/src/order-state-service.spec.ts`
2. Test cases for state detection:
   - **Creato**: Order without archibaldOrderId
   - **Piazzato**: Order with archibaldOrderId but no sentToMilanoAt
   - **Inviato a Milano**: Order with sentToMilanoAt set
   - **Spedito**: Order with DDT data
   - **Consegnato**: Order with delivery date in past
   - **Fallback**: Archibald error → use last known state
3. Create `archibald-web-app/backend/src/order-state-sync-service.spec.ts`
4. Test cases for sync:
   - **Cache hit**: Return cached data (no scraping)
   - **Cache miss**: Scrape Archibald, update database
   - **Force refresh**: Ignore cache, scrape anyway
   - **State change**: Record in state_history table
   - **Partial failure**: Continue processing on individual errors
5. Mock BrowserPool, Puppeteer, and database
6. Run tests: `npm test order-state-*.spec.ts`

**Acceptance**:
- 10+ test cases covering main scenarios
- All tests passing
- Cache logic correct
- State history recording verified
- Test coverage > 80%

## Task 6: Integration Test (type: checkpoint:human-verify)

**Goal**: Test full state sync workflow with real Archibald session.

**Actions**:
1. Ensure test orders exist in multiple states (piazzato, spedito, etc.)
2. Start backend server
3. Make API request (initial sync):
   ```bash
   curl -X POST http://localhost:3000/api/orders/sync-states \
     -H "Authorization: Bearer $JWT"
   ```
4. Observe:
   - Backend logs (state detection for each order)
   - Database updates (current_state changed)
   - State history table (new entries)
5. Make second request (cache test):
   - Should return immediately (no scraping)
   - Verify cache timestamp in response
6. Make force refresh request:
   ```bash
   curl -X POST "http://localhost:3000/api/orders/sync-states?forceRefresh=true" \
     -H "Authorization: Bearer $JWT"
   ```
   - Should scrape Archibald again (ignore cache)
7. Query state history for test order:
   ```bash
   curl http://localhost:3000/api/orders/:orderId/state-history \
     -H "Authorization: Bearer $JWT"
   ```
   - Verify timeline returned correctly

**Acceptance**:
- Real order states synced successfully
- Cache works correctly (2-hour TTL)
- Force refresh ignores cache
- State history records all changes
- No errors in backend logs

**Checkpoint**: User must verify that test orders exist in different states in Archibald.

</tasks>

<verification>
## Success Criteria

- [ ] Database migration adds state_history table
- [ ] OrderStateService detects state from multiple sources
- [ ] OrderStateSyncService implements 2-hour cache correctly
- [ ] State changes recorded in history table
- [ ] API endpoints for sync and history
- [ ] Unit tests cover main scenarios (80%+ coverage)
- [ ] Integration test syncs real data
- [ ] Cache prevents excessive scraping
- [ ] Force refresh works correctly

## Verification Steps

1. Run database migration and verify schema changes
2. Run unit tests: `npm test order-state-*.spec.ts`
3. Run integration test with real Archibald session
4. Verify state updates in database
5. Check state history table for new entries
6. Test cache by making second request
7. Test force refresh ignores cache
</verification>

<success_criteria>
Order state tracking complete, tested, with 2-hour cache and comprehensive state history for timeline display.
</success_criteria>

<output>
- Updated `archibald-web-app/backend/migrations/011-order-management.sql` - State history table
- `archibald-web-app/backend/src/order-state-service.ts` - State detection service
- `archibald-web-app/backend/src/order-state-sync-service.ts` - Sync service with cache
- `archibald-web-app/backend/src/order-state-service.spec.ts` - Unit tests
- `archibald-web-app/backend/src/order-state-sync-service.spec.ts` - Unit tests
- Updated `archibald-web-app/backend/src/index.ts` - Sync and history endpoints
- Updated `archibald-web-app/backend/src/order-db.ts` - Type definitions
- `.planning/phases/11-order-management/11-04-SUMMARY.md` - Implementation summary
</output>
