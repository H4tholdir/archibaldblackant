---
dependencies:
  - .planning/phases/11-order-management/11-01-RESEARCH.md
  - .planning/phases/11-order-management/11-03-PLAN.md
  - archibald-web-app/backend/src/ddt-scraper-service.ts
---

# Plan 11-06: Implement Invoice Scraping and PDF Download

<objective>
Scrape invoice data from Archibald, match to orders, and implement PDF download functionality for user access.
</objective>

<execution_context>
@~/.claude/get-shit-done/references/checkpoints.md
@~/.claude/get-shit-done/references/tdd.md
@archibald-web-app/backend/src/ddt-scraper-service.ts
@.planning/phases/11-order-management/11-01-RESEARCH.md
</execution_context>

<context>
## Invoice Requirements from 11-CONTEXT.md

**Fatture Page**: `https://4.231.124.90/Archibald/CUSTINVOICEJOUR_ListView/`

**Data to Scrape**:
- Invoice number
- Issue date
- Total amount
- PDF download mechanism (to analyze - likely link/button)

**Invoice Matching**: Match via order ID or customer info

**User Flow**:
1. When invoice available on Archibald → flag in DB
2. User clicks "Scarica fattura" → scraping + PDF download
3. PDF served directly to user

## Reusable Patterns

From Plan 11-03 (DDT Scraping):
- Header-based column detection
- Text-based element identification
- Order matching by ID
- Pagination handling

From Phase 10:
- URL normalization
- Graceful error handling
- 2-hour cache TTL

## Implementation Approach

**Scraping Workflow**:
1. Navigate to Fatture page: `https://4.231.124.90/Archibald/CUSTINVOICEJOUR_ListView/`
2. Detect columns by header text (similar to DDT page)
3. Extract invoice metadata (number, date, amount)
4. Locate PDF download link/button per invoice row
5. Match invoices to orders by order ID
6. Store invoice metadata in database

**PDF Download Workflow**:
1. User clicks "Scarica fattura" button in UI
2. Frontend calls backend endpoint: `GET /api/orders/:orderId/invoice/download`
3. Backend:
   - Verify order belongs to user
   - Navigate to Fatture page
   - Locate invoice by order ID
   - Click download link/button
   - Intercept Puppeteer download event
   - Stream PDF to frontend
4. Frontend receives PDF blob and triggers browser download

**Database Changes**:
- Add invoice fields to orders table (from migration 011):
  ```sql
  ALTER TABLE orders ADD COLUMN invoice_number TEXT;
  ALTER TABLE orders ADD COLUMN invoice_date TEXT;
  ALTER TABLE orders ADD COLUMN invoice_amount REAL;
  ```

## Out of Scope

- Invoice preview (PDF rendering in browser)
- Batch invoice download
- Invoice email notifications
</context>

<tasks>
## Task 1: Database Schema Extension (type: auto)

**Goal**: Add invoice fields to orders table.

**Actions**:
1. Update migration `archibald-web-app/backend/migrations/011-order-management.sql`
2. Add columns:
   ```sql
   ALTER TABLE orders ADD COLUMN invoice_number TEXT;
   ALTER TABLE orders ADD COLUMN invoice_date TEXT;  -- ISO 8601
   ALTER TABLE orders ADD COLUMN invoice_amount REAL;
   ```
3. Update TypeScript interface in `archibald-web-app/backend/src/order-db.ts`:
   ```typescript
   interface Order {
     // ... existing fields
     invoiceNumber?: string;
     invoiceDate?: string;  // ISO 8601
     invoiceAmount?: number;
   }
   ```
4. Run migration against test database
5. Verify columns added

**Acceptance**:
- Migration updated with invoice columns
- TypeScript types updated
- Columns visible in database schema

## Task 2: Implement Invoice Scraper Service (type: auto)

**Goal**: Create service to scrape invoice metadata from Archibald.

**Actions**:
1. Create `archibald-web-app/backend/src/invoice-scraper-service.ts`
2. Implement `InvoiceScraperService` class with method:
   ```typescript
   async scrapeInvoiceData(username: string, password: string): Promise<InvoiceData[]>
   ```
3. Service workflow:
   - Acquire BrowserContext from BrowserPool
   - Navigate to Fatture page: `https://4.231.124.90/Archibald/CUSTINVOICEJOUR_ListView/`
   - Wait for table to load
   - **Detect columns by header text** (reuse DDT pattern):
     - "NUMERO FATTURA" → invoice number column
     - "DATA EMISSIONE" → invoice date column
     - "IMPORTO" → amount column
     - "ID ORDINE" or similar → order ID column (to investigate in 11-01-RESEARCH.md)
   - Iterate table rows:
     - Extract invoice number (e.g., "FT/2026/00123")
     - Extract invoice date (parse to ISO 8601)
     - Extract amount (parse currency string to float)
     - Extract order ID for matching
     - Locate PDF download link/button (selector from research)
     - Store download selector for later use
   - **Handle pagination** (similar to DDT page):
     - Click "Next" button until no more pages
     - Duplicate detection
   - Return array of invoice data objects
4. Error handling:
   - Missing columns → log warning, return partial data
   - Pagination timeout → return data scraped so far
   - Invalid amount format → store 0, log warning
5. Logging:
   - Debug logs for each step
   - Error logs with details

**Acceptance**:
- `InvoiceScraperService` class created
- Column detection by header text
- Invoice metadata extracted correctly
- PDF download selector identified
- Pagination handled
- Comprehensive error handling

## Task 3: Implement Invoice Matching Logic (type: auto)

**Goal**: Match invoices to orders in database by order ID.

**Actions**:
1. Add method to `InvoiceScraperService`:
   ```typescript
   async syncInvoicesToOrders(invoiceData: InvoiceData[]): Promise<SyncResult>
   ```
2. Matching logic:
   - For each invoice:
     - Extract order ID (e.g., "ORD/26000552")
     - Query database for order with matching `archibaldOrderId`
     - If found:
       - Update order with invoice data (number, date, amount)
       - Log successful match
     - If not found:
       - Log warning (invoice not in our database)
   - Return sync result: `{ matched: number, notFound: number }`
3. Handle edge cases:
   - Multiple invoices per order (keep most recent by date)
   - Missing order ID (skip, log warning)
   - Invalid invoice data (store as-is, log warning)
4. **Transactional update**:
   - Use database transaction for atomic updates

**Acceptance**:
- Matching by order ID works reliably
- Database updates atomic
- Edge cases handled gracefully
- Sync result provides transparency

## Task 4: Implement PDF Download Service (type: auto)

**Goal**: Create service to download invoice PDF from Archibald.

**Actions**:
1. Add method to `InvoiceScraperService`:
   ```typescript
   async downloadInvoicePDF(orderId: string, username: string, password: string): Promise<Buffer>
   ```
2. PDF download workflow:
   - Acquire BrowserContext from BrowserPool
   - Navigate to Fatture page
   - Locate invoice row by order ID (match in table)
   - Set up Puppeteer download interception:
     ```typescript
     const client = await page.target().createCDPSession();
     await client.send('Page.setDownloadBehavior', {
       behavior: 'allow',
       downloadPath: tmpDir
     });
     ```
   - Click PDF download link/button
   - Wait for download to complete (file appears in tmpDir)
   - Read PDF file into Buffer
   - Delete temp file
   - Return Buffer
3. Error handling:
   - Invoice not found → 404 error
   - Download timeout → 500 error with retry
   - PDF corrupted → log error, return partial data
4. Timeout: 30 seconds for download completion

**Acceptance**:
- `downloadInvoicePDF()` method created
- Puppeteer download interception works
- PDF Buffer returned correctly
- Temp files cleaned up
- Error handling for edge cases

## Task 5: Create API Endpoints (type: auto)

**Goal**: Add endpoints for invoice sync and PDF download.

**Actions**:
1. Add endpoints to `archibald-web-app/backend/src/index.ts`:
   ```typescript
   POST /api/orders/sync-invoices         // Sync invoice metadata
   GET /api/orders/:orderId/invoice/download  // Download invoice PDF
   ```
2. **Sync invoices endpoint**:
   - Extract JWT from request (requireAuth middleware)
   - Fetch user credentials
   - Pause background services (PriorityManager)
   - Call `InvoiceScraperService.scrapeInvoiceData()`
   - Call `InvoiceScraperService.syncInvoicesToOrders()`
   - Resume background services
   - Return sync result with counts
   - Cache result for 2 hours (reuse Phase 10 pattern)
3. **Download invoice PDF endpoint**:
   - Extract JWT and orderId
   - Verify order belongs to user
   - Fetch order from database (verify invoice exists)
   - If no invoice → 404 error
   - Pause background services
   - Call `InvoiceScraperService.downloadInvoicePDF()`
   - Resume background services
   - Set response headers:
     ```typescript
     res.setHeader('Content-Type', 'application/pdf');
     res.setHeader('Content-Disposition', `attachment; filename="invoice-${invoiceNumber}.pdf"`);
     ```
   - Stream PDF Buffer to response
4. Rate limiting:
   - Sync invoices: max 1 per 2 hours per user
   - Download: max 5 per minute per user
5. Error responses:
   - 404: Invoice not found
   - 429: Rate limit exceeded
   - 500: Scraping error

**Acceptance**:
- Both endpoints registered and authenticated
- Sync invoices uses cache correctly
- Download streams PDF correctly
- Rate limiting prevents abuse
- Error responses descriptive

## Task 6: Add UI for Invoice Download (type: auto)

**Goal**: Add "Scarica fattura" button to OrderCard component.

**Actions**:
1. Update `archibald-web-app/frontend/src/components/OrderCard.tsx`
2. Add invoice section to OrderCard body:
   - If `invoiceNumber` present:
     - Display invoice number and date
     - Display invoice amount
     - Button: "Scarica fattura" (download icon)
   - If `invoiceNumber` null:
     - Display: "Fattura non ancora disponibile"
3. Implement download handler:
   ```typescript
   const handleDownloadInvoice = async () => {
     setIsDownloading(true);
     try {
       const response = await fetch(`/api/orders/${orderId}/invoice/download`, {
         headers: { Authorization: `Bearer ${jwt}` }
       });
       const blob = await response.blob();
       const url = window.URL.createObjectURL(blob);
       const a = document.createElement('a');
       a.href = url;
       a.download = `invoice-${invoiceNumber}.pdf`;
       a.click();
       window.URL.revokeObjectURL(url);
       showToast('Fattura scaricata con successo', 'success');
     } catch (error) {
       showToast('Errore durante il download della fattura', 'error');
     } finally {
       setIsDownloading(false);
     }
   };
   ```
4. Button states:
   - Loading state during download (spinner)
   - Disabled if isDownloading
   - Success toast on completion
   - Error toast on failure
5. Styling:
   - Invoice section below tracking section
   - Green "Scarica fattura" button (matches bank UX)
   - Mobile-friendly

**Acceptance**:
- Invoice section added to OrderCard
- "Scarica fattura" button visible when invoice exists
- Download handler triggers browser download
- Loading state prevents double-click
- Success/error toasts provide feedback
- Mobile responsive

## Task 7: Write Unit Tests (type: auto)

**Goal**: TDD test coverage for invoice scraper.

**Actions**:
1. Create `archibald-web-app/backend/src/invoice-scraper-service.spec.ts`
2. Test cases:
   - **Column detection**: Verify header-based column mapping
   - **Data extraction**: Parse invoice entry correctly
   - **Amount parsing**: Handle currency strings (€1.234,56)
   - **Order matching**: Match invoice to order by ID
   - **PDF download**: Mock Puppeteer download
   - **Edge cases**: Missing invoice, download timeout
3. Mock Puppeteer page interactions
4. Mock database queries
5. Run tests: `npm test invoice-scraper-service.spec.ts`

**Acceptance**:
- 6+ test cases covering main scenarios
- All tests passing
- PDF download mocked correctly
- Test coverage > 80%

## Task 8: Integration Test (type: checkpoint:human-verify)

**Goal**: Test full invoice scraping and download workflow.

**Actions**:
1. Ensure test order(s) have invoices in Archibald
2. Start backend server
3. Make API request (sync invoices):
   ```bash
   curl -X POST http://localhost:3000/api/orders/sync-invoices \
     -H "Authorization: Bearer $JWT"
   ```
4. Observe:
   - Backend logs (scraping steps, matches found)
   - Database updates (invoice data stored)
5. Make download request:
   ```bash
   curl http://localhost:3000/api/orders/:orderId/invoice/download \
     -H "Authorization: Bearer $JWT" \
     --output invoice.pdf
   ```
6. Verify:
   - PDF file downloaded successfully
   - PDF opens correctly (not corrupted)
7. Test UI:
   - Navigate to OrderHistory
   - Expand order with invoice
   - Click "Scarica fattura" button
   - Verify browser downloads PDF

**Acceptance**:
- Real invoice data scraped successfully
- Orders matched by ID
- PDF downloaded via API
- PDF opens correctly
- UI button triggers download
- No errors in backend logs

**Checkpoint**: User must verify that test orders have invoices in Archibald.

</tasks>

<verification>
## Success Criteria

- [ ] Database migration adds invoice columns
- [ ] InvoiceScraperService scrapes invoice metadata
- [ ] Order matching by ID works reliably
- [ ] PDF download via Puppeteer works
- [ ] API endpoints for sync and download
- [ ] UI button triggers PDF download
- [ ] Unit tests cover main scenarios (80%+ coverage)
- [ ] Integration test downloads real PDF
- [ ] Cache prevents excessive scraping

## Verification Steps

1. Run database migration and verify schema changes
2. Run unit tests: `npm test invoice-scraper-service.spec.ts`
3. Run integration test with real Archibald session
4. Verify invoice data in database
5. Download PDF via API and open it
6. Test UI button downloads PDF
7. Verify PDF is not corrupted
</verification>

<success_criteria>
Invoice scraping and PDF download complete, tested, and integrated into UI. Users can download invoices directly from OrderHistory.
</success_criteria>

<output>
- Updated `archibald-web-app/backend/migrations/011-order-management.sql` - Invoice columns
- `archibald-web-app/backend/src/invoice-scraper-service.ts` - Invoice scraping service
- `archibald-web-app/backend/src/invoice-scraper-service.spec.ts` - Unit tests
- Updated `archibald-web-app/backend/src/index.ts` - Sync and download endpoints
- Updated `archibald-web-app/backend/src/order-db.ts` - Type definitions
- Updated `archibald-web-app/frontend/src/components/OrderCard.tsx` - Download button
- `.planning/phases/11-order-management/11-06-SUMMARY.md` - Implementation summary
</output>
