---
phase: 03-browser-pool-concurrency
plan: 03
type: execute
---

<objective>
Gestire fallimento transazione post-bot con compensating logic per prevenire duplicazioni su Archibald.

Purpose: Quando il bot completa un'operazione su Archibald (es. crea ordine) ma la transazione DB successiva fallisce, il sistema perde traccia dell'operazione completata. Al prossimo tentativo, senza compensating logic, il bot ricreerebbe l'operazione → duplicato su Archibald. Questa fix registra il risultato bot PRIMA della transazione DB, permettendo il recovery senza duplicazioni.
Output: Tabella bot_results, utility recovery, 4 handler aggiornati con pattern check-save-clear, test per ogni handler.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-pool-concurrency/03-RESEARCH.md
@.planning/phases/03-browser-pool-concurrency/03-CONTEXT.md

@.planning/phases/03-browser-pool-concurrency/03-01-SUMMARY.md
@.planning/phases/03-browser-pool-concurrency/03-02-SUMMARY.md

@archibald-web-app/backend/src/operations/handlers/submit-order.ts
@archibald-web-app/backend/src/operations/handlers/submit-order.spec.ts
@archibald-web-app/backend/src/operations/handlers/send-to-verona.ts
@archibald-web-app/backend/src/operations/handlers/send-to-verona.spec.ts
@archibald-web-app/backend/src/operations/handlers/create-customer.ts
@archibald-web-app/backend/src/operations/handlers/create-customer.spec.ts
@archibald-web-app/backend/src/operations/handlers/delete-order.ts
@archibald-web-app/backend/src/operations/handlers/delete-order.spec.ts
@archibald-web-app/backend/src/db/migrations/

**From RESEARCH.md:**
- Check-before-retry: non serve framework saga generico, pattern specifico per handler
- NON hand-roll distributed locking — singolo processo, Map/pool in-memory bastano
- Pitfall: ordini duplicati se preemption arriva dopo il click "Salva" — check-before-retry è l'unica difesa

**From CONTEXT.md:**
- "prima di ritentare un'operazione, controllare SEMPRE su Archibald se l'operazione è già stata completata"
- "Se il bot stava creando un ordine e qualcosa è andato storto, prima di ricreare l'ordine bisogna verificare se su Archibald l'ordine esiste già"
- Pattern "check-then-act" si applica a: submit-order, send-to-verona, creazione clienti, delete-order
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migration bot_results + utility recovery</name>
  <files>archibald-web-app/backend/src/db/migrations/006-bot-results.sql, archibald-web-app/backend/src/operations/bot-result-store.ts, archibald-web-app/backend/src/operations/bot-result-store.spec.ts</files>
  <action>
**006-bot-results.sql:**
```sql
CREATE TABLE IF NOT EXISTS agents.bot_results (
  id SERIAL PRIMARY KEY,
  user_id TEXT NOT NULL,
  operation_type TEXT NOT NULL,
  operation_key TEXT NOT NULL,
  result_data JSONB NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (user_id, operation_type, operation_key)
);

CREATE INDEX idx_bot_results_lookup ON agents.bot_results (user_id, operation_type, operation_key);
```

**bot-result-store.ts:**
Creare un modulo con 3 funzioni pure che accettano DbPool:

- `checkBotResult(pool: DbPool, userId: string, operationType: string, operationKey: string): Promise&lt;Record&lt;string, unknown&gt; | null&gt;` — SELECT result_data da bot_results. Ritorna il JSON parsato o null.
- `saveBotResult(pool: DbPool, userId: string, operationType: string, operationKey: string, resultData: Record&lt;string, unknown&gt;): Promise&lt;void&gt;` — INSERT INTO ... ON CONFLICT DO UPDATE SET result_data = EXCLUDED.result_data, created_at = NOW().
- `clearBotResult(pool: DbPool, userId: string, operationType: string, operationKey: string): Promise&lt;void&gt;` — DELETE FROM ... WHERE user_id AND operation_type AND operation_key.

Usare query parametrizzate. Tipo per import: `import type { DbPool } from '../db/pool';`.

**bot-result-store.spec.ts:**
Test con mock del pool (pool.query restituisce { rows: [...] } o { rows: [] }):
- "checkBotResult returns result_data when found"
- "checkBotResult returns null when not found"
- "saveBotResult calls INSERT with correct parameters"
- "clearBotResult calls DELETE with correct parameters"

**Cosa evitare:**
- NON creare una classe — 3 funzioni semplici esportate.
- NON aggiungere TTL automatico (cleanup manuale se necessario in futuro).
- NON aggiungere logica di retry — è responsabilità del caller.
  </action>
  <verify>npm run build --prefix archibald-web-app/backend && npm test --prefix archibald-web-app/backend</verify>
  <done>Migration 006 creata, bot-result-store con 3 funzioni esportate, 4 test passano. TypeScript compila.</done>
</task>

<task type="auto">
  <name>Task 2: Applicare pattern recovery a submit-order, send-to-verona, create-customer, delete-order</name>
  <files>archibald-web-app/backend/src/operations/handlers/submit-order.ts, archibald-web-app/backend/src/operations/handlers/submit-order.spec.ts, archibald-web-app/backend/src/operations/handlers/send-to-verona.ts, archibald-web-app/backend/src/operations/handlers/send-to-verona.spec.ts, archibald-web-app/backend/src/operations/handlers/create-customer.ts, archibald-web-app/backend/src/operations/handlers/create-customer.spec.ts, archibald-web-app/backend/src/operations/handlers/delete-order.ts, archibald-web-app/backend/src/operations/handlers/delete-order.spec.ts</files>
  <action>
Applicare lo stesso pattern "check → bot → save → DB transaction → clear" a ciascun handler. Il pattern è identico per tutti, cambia solo il tipo di operazione e il campo operation_key.

**Pattern comune per ogni handler:**
```
1. CHECK: const savedResult = await checkBotResult(pool, userId, OPERATION_TYPE, operationKey);
2. Se savedResult esiste → skip bot call, usa savedResult
3. Se savedResult non esiste → chiama bot → save result con saveBotResult(...)
4. Esegui DB transaction (come prima)
5. CLEAR: await clearBotResult(pool, userId, OPERATION_TYPE, operationKey);
```

**submit-order.ts (handleSubmitOrder):**
- operation_key = `data.pendingOrderId`
- CHECK: `checkBotResult(pool, userId, 'submit-order', data.pendingOrderId)`
- Se esiste: `orderId = savedResult.orderId as string`, skip `bot.createOrder()`
- Se non esiste: `orderId = await bot.createOrder(data)`, poi `saveBotResult(pool, userId, 'submit-order', data.pendingOrderId, { orderId })`
- Dopo pool.withTransaction: `clearBotResult(pool, userId, 'submit-order', data.pendingOrderId)`

**send-to-verona.ts (handleSendToVerona):**
- operation_key = `data.orderId`
- CHECK: `checkBotResult(pool, userId, 'send-to-verona', data.orderId)`
- Se esiste: skip `bot.sendOrderToVerona()`, usa savedResult
- Se non esiste: chiama bot, poi `saveBotResult(..., { success: true, message: result.message })`
- Dopo pool.query UPDATE: `clearBotResult(...)`

**create-customer.ts (handleCreateCustomer):**
- operation_key = `data.name` (identificativo unico minimo del cliente da creare)
- CHECK: `checkBotResult(pool, userId, 'create-customer', data.name)`
- Se esiste: `realProfile = savedResult.customerProfile as string`, skip `bot.createCustomer()`
- Se non esiste: chiama bot, poi `saveBotResult(..., { customerProfile: realProfile })`
- Dopo pool.query UPDATE: `clearBotResult(...)`

**delete-order.ts (handleDeleteOrder):**
- operation_key = `data.orderId`
- CHECK: `checkBotResult(pool, userId, 'delete-order', data.orderId)`
- Se esiste: skip `bot.deleteOrderFromArchibald()`, usa savedResult
- Se non esiste: chiama bot, poi `saveBotResult(..., { success: true, message: result.message })`
- Dopo pool.withTransaction: `clearBotResult(...)`

**Test per ciascun handler (4 test nuovi per handler, pattern identico):**
1. "skips bot call when bot_result exists (recovery path)" — mock checkBotResult ritorna dati, verificare che bot.method NON viene chiamato, DB transaction procede con i dati salvati.
2. "calls bot and saves result when no bot_result exists (normal path)" — mock checkBotResult ritorna null, verificare che bot.method viene chiamato E saveBotResult viene chiamato.
3. "clears bot_result after successful DB transaction" — verificare clearBotResult chiamato dopo la transazione.
4. "bot_result persists if DB transaction fails" — mock pool.withTransaction che rifietta, verificare che clearBotResult NON viene chiamato e saveBotResult ERA stato chiamato (il risultato è recuperabile).

**Cosa evitare:**
- NON modificare la firma pubblica delle funzioni handle* — aggiungere le chiamate bot-result-store internamente.
- NON cambiare la logica della DB transaction — solo wrappare il bot call con check/save/clear.
- NON aggiungere check su Archibald via bot (no nuovi metodi bot) — il bot_results table è sufficiente per recovery.
- NON mettere clearBotResult dentro la transazione — farlo DOPO che la transazione ha avuto successo, come azione separate. Se clear fallisce, la prossima esecuzione troverà il bot_result e skipperà il bot → idempotente.
  </action>
  <verify>npm run build --prefix archibald-web-app/backend && npm test --prefix archibald-web-app/backend</verify>
  <done>4 handler aggiornati con pattern check-save-clear. 16 nuovi test (4 per handler). Nessun duplicato possibile su Archibald se DB transaction fallisce dopo bot success. Tutti i test passano. Phase 3 complete.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix archibald-web-app/backend` succeeds
- [ ] `npm test --prefix archibald-web-app/backend` — all tests pass
- [ ] Migration 006-bot-results.sql esiste con schema corretto
- [ ] bot-result-store esporta checkBotResult, saveBotResult, clearBotResult
- [ ] Ogni handler: recovery path salta il bot call (verificato da test)
- [ ] Ogni handler: normal path salva il bot result (verificato da test)
- [ ] Ogni handler: clear dopo DB transaction (verificato da test)
- [ ] Ogni handler: bot_result persiste se DB transaction fallisce (verificato da test)
</verification>

<success_criteria>

- Tabella agents.bot_results creata con migration
- 4 handler protetti da duplicazioni: submit-order, send-to-verona, create-customer, delete-order
- Pattern check-save-clear verificato per ogni handler
- Nessun duplicato possibile su Archibald dopo crash post-bot
- Tutti i test passano (pre-esistenti + 4 store + 16 handler)
- Phase 3 complete
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-pool-concurrency/03-03-SUMMARY.md`
</output>
