---
phase: 03-browser-pool-concurrency
plan: 02
type: execute
---

<objective>
Abilitare concurrency per-utente nel Worker BullMQ: agenti diversi in parallelo, 1 operazione alla volta per agente.

Purpose: Il Worker attuale ha concurrency: 1 — tutti i job vengono processati sequenzialmente, un collo di bottiglia critico per 60+ agenti. Con concurrency > 1, utenti diversi procedono in parallelo mentre l'agentLock garantisce serializzazione per-utente.
Output: Worker con concurrency 10, re-enqueue con backoff esponenziale, test di concurrency multi-utente.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-browser-pool-concurrency/03-RESEARCH.md
@.planning/phases/03-browser-pool-concurrency/03-CONTEXT.md

@.planning/phases/03-browser-pool-concurrency/03-01-SUMMARY.md

@archibald-web-app/backend/src/operations/operation-processor.ts
@archibald-web-app/backend/src/operations/operation-processor.spec.ts
@archibald-web-app/backend/src/operations/operation-types.ts
@archibald-web-app/backend/src/main.ts

**From RESEARCH.md:**
- Worker concurrency 10 con agentLock = parallelismo tra utenti senza BullMQ Pro
- Re-enqueue con backoff esponenziale (2s → 4s → 8s → 16s → max 30s) per evitare busy loop
- concurrency ≤ maxBrowsers × maxContextsPerBrowser - margine (pool 15, concurrency 10)

**From 03-01:**
- agentLock.release ora verifica jobId (sicuro per concurrency > 1)
- Browser pool non evicta context in-use (sicuro per concurrency > 1)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Aumentare Worker concurrency + backoff esponenziale re-enqueue</name>
  <files>archibald-web-app/backend/src/main.ts, archibald-web-app/backend/src/operations/operation-processor.ts, archibald-web-app/backend/src/operations/operation-types.ts, archibald-web-app/backend/src/operations/operation-processor.spec.ts</files>
  <action>
**main.ts:**
- Cambiare `concurrency: 1` in `concurrency: 10` nella configurazione del Worker (linea 247).
- Aggiungere env var opzionale: `const workerConcurrency = parseInt(process.env.WORKER_CONCURRENCY ?? '10', 10);` e usarla nella config.

**operation-types.ts:**
- Aggiungere campo opzionale `_requeueCount?: number` a `OperationJobData` — traccia quante volte il job è stato re-enqueued per lock contention.

**operation-processor.ts:**
- Nella sezione dove il job non acquisisce il lock e non è preemptable (linee 98-101), modificare il re-enqueue:
  - Leggere `const requeueCount = (job.data._requeueCount ?? 0) + 1;`
  - Calcolare delay con backoff esponenziale: `const delay = Math.min(2_000 * Math.pow(2, requeueCount - 1), 30_000);` (2s, 4s, 8s, 16s, max 30s)
  - Passare `{ ...data, _requeueCount: requeueCount }` come data al nuovo job (tramite enqueue)
  - Aggiungere log: `console.info(\`[Processor] Re-enqueueing ${type} for ${userId} (attempt ${requeueCount}, delay ${delay}ms)\`);`
- Il campo `_requeueCount` deve essere escluso dal data passato al handler (non inquinare handler logic). Estrarre `_requeueCount` con destructuring prima di passare `data` all'handler: `const { _requeueCount, ...handlerData } = data;` — usare `handlerData` nel try block quando si chiama il handler.

**Attenzione alla firma di enqueue:** La firma attuale di `EnqueueFn` è `(type, userId, data, idempotencyKey?) => Promise<string>`. Il delay non è supportato direttamente. Verificare la firma di `operation-queue.ts:enqueue()` — se non supporta un parametro delay/options, aggiungere un parametro opzionale `options?: { delay?: number }` a `enqueue()` in operation-queue.ts e propagarlo a `Queue.add()`. Aggiornare il tipo `EnqueueFn` di conseguenza.

**operation-processor.spec.ts:**
- Aggiungere test: "re-enqueue uses exponential backoff delay based on _requeueCount"
  - Job con _requeueCount: 0 → delay 2000ms
  - Job con _requeueCount: 2 → delay 8000ms
  - Job con _requeueCount: 10 → delay capped a 30000ms
- Aggiornare test "re-enqueue when lock not acquired and not preemptable" per verificare delay e _requeueCount nel data.
- Aggiungere test: "_requeueCount is stripped from handler data" — verificare che l'handler riceva data senza _requeueCount.

**Cosa evitare:**
- NON cambiare la logica di preemption (cancelJob + polling) — quella resta identica.
- NON cambiare la logica di deduplicazione — gestita da BullMQ natively.
- NON rendere il Worker concurrency configurabile oltre la env var — YAGNI.
  </action>
  <verify>npm run build --prefix archibald-web-app/backend && npm test --prefix archibald-web-app/backend</verify>
  <done>Worker concurrency 10, re-enqueue con backoff esponenziale (2s-30s), _requeueCount incrementato e stripped prima dell'handler. Tutti i test passano.</done>
</task>

<task type="auto">
  <name>Task 2: Test per concurrency multi-utente e serializzazione</name>
  <files>archibald-web-app/backend/src/operations/operation-processor.spec.ts</files>
  <action>
Aggiungere un describe block "multi-user concurrency" in operation-processor.spec.ts con i seguenti test:

**Test 1: "different users process in parallel without blocking"**
- Creare processor con agentLock reale (createAgentLock()), mock browserPool e handler.
- Lanciare processJob per userId 'alice' e processJob per userId 'bob' in parallelo (Promise.all).
- Verificare che entrambi acquisiscono il lock e completano — nessuno viene re-enqueued.

**Test 2: "same user jobs serialize via agentLock"**
- Lanciare processJob per userId 'alice' (handler con delay breve).
- Lanciare immediatamente processJob per userId 'alice' con tipo diverso.
- Verificare che il secondo job viene re-enqueued (lock not acquired, not preemptable).

**Test 3: "exponential backoff delay increases with _requeueCount"**
- Job con data._requeueCount = 0 → enqueue chiamato con delay 2000.
- Job con data._requeueCount = 3 → enqueue chiamato con delay 16000.
- Job con data._requeueCount = 100 → enqueue chiamato con delay 30000 (cap).

**Test 4: "handler receives data without _requeueCount"**
- Job con data = { type, userId, ..., _requeueCount: 5 }.
- Verificare che l'handler riceve data SENZA il campo _requeueCount.

Usare mock semplici per browserPool (acquireContext ritorna {}, releaseContext risolve). Usare agentLock reale (createAgentLock()) per test 1 e 2 per verificare il comportamento reale di serializzazione.

**Cosa evitare:** NON creare test con timing-dependent behavior (no setTimeout reali). Usare handler mock che risolvono/rifiutano immediatamente o con Promise controllate.
  </action>
  <verify>npm test --prefix archibald-web-app/backend -- --grep "multi-user concurrency"</verify>
  <done>4 nuovi test di concurrency passano. Il pattern agentLock + concurrency > 1 è verificato come corretto.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix archibald-web-app/backend` succeeds
- [ ] `npm test --prefix archibald-web-app/backend` — all tests pass
- [ ] Worker concurrency è 10 (o env var WORKER_CONCURRENCY)
- [ ] Re-enqueue delay cresce esponenzialmente (verificato da test)
- [ ] _requeueCount non leaks negli handler (verificato da test)
- [ ] Utenti diversi processano in parallelo (verificato da test)
- [ ] Stesso utente serializzato (verificato da test)
</verification>

<success_criteria>

- Worker processa fino a 10 job in parallelo
- agentLock serializza per-utente (da 03-01)
- Re-enqueue con backoff previene busy loop
- Handler non vedono metadati interni (_requeueCount)
- Tutti i test passano
- Pronto per 03-03 (compensating transactions)
</success_criteria>

<output>
After completion, create `.planning/phases/03-browser-pool-concurrency/03-02-SUMMARY.md`
</output>
