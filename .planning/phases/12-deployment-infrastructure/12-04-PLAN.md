---
phase: 12-deployment-infrastructure
type: execute
---

<objective>
Create admin monitoring dashboard integrated into the app at /admin/monitoring.

Purpose: Provide visibility into app health, performance, and usage without external tools.
Output: React dashboard component with metrics collection, real-time stats, and alert system.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.MD
@.planning/ROADMAP.md
@.planning/phases/12-deployment-infrastructure/12-CONTEXT.md
@archibald-web-app/frontend/src/App.tsx
@archibald-web-app/backend/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics collection backend service</name>
  <files>archibald-web-app/backend/src/metrics-service.ts</files>
  <action>
    Create metrics collection service at [archibald-web-app/backend/src/metrics-service.ts](archibald-web-app/backend/src/metrics-service.ts):

    ```typescript
    import { EventEmitter } from 'events';

    export interface AppMetrics {
      uptime: number;
      timestamp: string;
      activeUsers: number;
      totalOrders: number;
      ordersLast24h: number;
      avgResponseTime: number;
      errorRate: number;
      cacheHitRate: number;
      pwaInstalls: number;
      puppeteerSessions: number;
      diskUsage: {
        used: number;
        total: number;
        percentage: number;
      };
      memory: {
        used: number;
        total: number;
        percentage: number;
      };
    }

    export interface ErrorLog {
      timestamp: string;
      level: 'error' | 'warning';
      message: string;
      stack?: string;
      userId?: string;
      endpoint?: string;
    }

    class MetricsService extends EventEmitter {
      private activeUsers: Set<string> = new Set();
      private totalOrders: number = 0;
      private ordersLast24h: number = 0;
      private responseTimes: number[] = [];
      private errorCount: number = 0;
      private requestCount: number = 0;
      private cacheHits: number = 0;
      private cacheMisses: number = 0;
      private recentErrors: ErrorLog[] = [];

      constructor() {
        super();
        this.startCleanupInterval();
      }

      // Track active user session
      trackUserSession(userId: string) {
        this.activeUsers.add(userId);
        setTimeout(() => this.activeUsers.delete(userId), 30 * 60 * 1000); // 30-min session
      }

      // Track order creation
      trackOrder() {
        this.totalOrders++;
        this.ordersLast24h++;
        setTimeout(() => this.ordersLast24h--, 24 * 60 * 60 * 1000); // Reset after 24h
      }

      // Track API response time
      trackResponseTime(ms: number) {
        this.responseTimes.push(ms);
        if (this.responseTimes.length > 100) {
          this.responseTimes.shift(); // Keep last 100 samples
        }
        this.requestCount++;
      }

      // Track errors
      trackError(error: ErrorLog) {
        this.errorCount++;
        this.recentErrors.push(error);
        if (this.recentErrors.length > 50) {
          this.recentErrors.shift(); // Keep last 50 errors
        }
        this.emit('error', error); // Emit for real-time alerts
      }

      // Track cache performance
      trackCacheHit() {
        this.cacheHits++;
      }

      trackCacheMiss() {
        this.cacheMisses++;
      }

      // Get current metrics
      async getMetrics(): Promise<AppMetrics> {
        const memUsage = process.memoryUsage();
        const totalMemory = require('os').totalmem();

        return {
          uptime: process.uptime(),
          timestamp: new Date().toISOString(),
          activeUsers: this.activeUsers.size,
          totalOrders: this.totalOrders,
          ordersLast24h: this.ordersLast24h,
          avgResponseTime: this.responseTimes.length > 0
            ? this.responseTimes.reduce((a, b) => a + b, 0) / this.responseTimes.length
            : 0,
          errorRate: this.requestCount > 0
            ? (this.errorCount / this.requestCount) * 100
            : 0,
          cacheHitRate: (this.cacheHits + this.cacheMisses) > 0
            ? (this.cacheHits / (this.cacheHits + this.cacheMisses)) * 100
            : 0,
          pwaInstalls: 0, // Tracked via frontend localStorage, fetched separately
          puppeteerSessions: 0, // TODO: integrate with BrowserPool
          diskUsage: await this.getDiskUsage(),
          memory: {
            used: memUsage.heapUsed,
            total: totalMemory,
            percentage: (memUsage.heapUsed / totalMemory) * 100,
          },
        };
      }

      // Get recent errors
      getRecentErrors(limit: number = 20): ErrorLog[] {
        return this.recentErrors.slice(-limit);
      }

      // Get disk usage
      private async getDiskUsage(): Promise<{ used: number; total: number; percentage: number }> {
        try {
          const { execSync } = require('child_process');
          const output = execSync('df -k /').toString().split('\n')[1].split(/\s+/);
          const used = parseInt(output[2]) * 1024;
          const total = parseInt(output[1]) * 1024;
          return {
            used,
            total,
            percentage: (used / total) * 100,
          };
        } catch {
          return { used: 0, total: 0, percentage: 0 };
        }
      }

      // Cleanup old data periodically
      private startCleanupInterval() {
        setInterval(() => {
          // Reset error rate calculation window
          if (this.requestCount > 10000) {
            this.errorCount = Math.floor(this.errorCount / 2);
            this.requestCount = Math.floor(this.requestCount / 2);
          }
        }, 60 * 60 * 1000); // Every hour
      }
    }

    export const metricsService = new MetricsService();
    ```

    Key decisions:
    - In-memory metrics (no external database needed for MVP)
    - EventEmitter for real-time alerts
    - Rolling windows (last 100 response times, last 50 errors, 24h orders)
    - Disk usage via `df` command (lightweight, no dependencies)
    - Memory usage from Node.js process API
  </action>
  <verify>
    - [archibald-web-app/backend/src/metrics-service.ts](archibald-web-app/backend/src/metrics-service.ts) created
    - TypeScript compiles without errors
    - getMetrics() returns complete AppMetrics interface
  </verify>
  <done>
    Metrics collection service created with in-memory tracking and real-time events
  </done>
</task>

<task type="auto">
  <name>Task 2: Add metrics API endpoints</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
    Integrate metrics service into backend, add admin-only endpoints:

    In [archibald-web-app/backend/src/index.ts](archibald-web-app/backend/src/index.ts):

    ```typescript
    import { metricsService } from './metrics-service';

    // Middleware: Track response time
    app.use((req, res, next) => {
      const start = Date.now();
      res.on('finish', () => {
        const duration = Date.now() - start;
        metricsService.trackResponseTime(duration);

        // Track errors (4xx/5xx responses)
        if (res.statusCode >= 400) {
          metricsService.trackError({
            timestamp: new Date().toISOString(),
            level: res.statusCode >= 500 ? 'error' : 'warning',
            message: `${req.method} ${req.path} ${res.statusCode}`,
            endpoint: req.path,
            userId: (req as any).user?.userId,
          });
        }
      });
      next();
    });

    // Admin-only middleware (reuse JWT auth + check admin role)
    const requireAdmin = (req: any, res: any, next: any) => {
      if (!req.user || !req.user.isAdmin) {
        return res.status(403).json({ error: 'Admin access required' });
      }
      next();
    };

    // Admin endpoints
    app.get('/api/admin/metrics', authenticateJWT, requireAdmin, async (req, res) => {
      try {
        const metrics = await metricsService.getMetrics();
        res.json(metrics);
      } catch (error) {
        res.status(500).json({ error: 'Failed to fetch metrics' });
      }
    });

    app.get('/api/admin/errors', authenticateJWT, requireAdmin, (req, res) => {
      const limit = parseInt(req.query.limit as string) || 20;
      const errors = metricsService.getRecentErrors(limit);
      res.json(errors);
    });

    // Track order creation in existing order endpoint
    // In /api/orders/create handler:
    // metricsService.trackOrder();

    // Track user sessions in JWT middleware
    // In authenticateJWT middleware after successful auth:
    // metricsService.trackUserSession(user.userId);
    ```

    Key decisions:
    - Admin-only endpoints (403 for non-admin users)
    - Middleware auto-tracks response times and errors
    - Lightweight integration (minimal code changes)
  </action>
  <verify>
    - Metrics endpoints added to [archibald-web-app/backend/src/index.ts](archibald-web-app/backend/src/index.ts)
    - requireAdmin middleware checks user.isAdmin
    - Response time tracking middleware present
    - TypeScript compiles without errors
  </verify>
  <done>
    Admin metrics API endpoints implemented with automatic tracking middleware
  </done>
</task>

<task type="auto">
  <name>Task 3: Create admin monitoring dashboard React component</name>
  <files>archibald-web-app/frontend/src/pages/AdminMonitoring.tsx</files>
  <action>
    Create monitoring dashboard at [archibald-web-app/frontend/src/pages/AdminMonitoring.tsx](archibald-web-app/frontend/src/pages/AdminMonitoring.tsx):

    ```tsx
    import React, { useEffect, useState } from 'react';
    import { api } from '../api/api';

    interface AppMetrics {
      uptime: number;
      timestamp: string;
      activeUsers: number;
      totalOrders: number;
      ordersLast24h: number;
      avgResponseTime: number;
      errorRate: number;
      cacheHitRate: number;
      diskUsage: { used: number; total: number; percentage: number };
      memory: { used: number; total: number; percentage: number };
    }

    interface ErrorLog {
      timestamp: string;
      level: 'error' | 'warning';
      message: string;
      stack?: string;
      endpoint?: string;
    }

    export function AdminMonitoring() {
      const [metrics, setMetrics] = useState<AppMetrics | null>(null);
      const [errors, setErrors] = useState<ErrorLog[]>([]);
      const [loading, setLoading] = useState(true);

      useEffect(() => {
        fetchData();
        const interval = setInterval(fetchData, 30000); // Refresh every 30s
        return () => clearInterval(interval);
      }, []);

      const fetchData = async () => {
        try {
          const [metricsRes, errorsRes] = await Promise.all([
            api.get('/api/admin/metrics'),
            api.get('/api/admin/errors?limit=10'),
          ]);
          setMetrics(metricsRes.data);
          setErrors(errorsRes.data);
        } catch (error) {
          console.error('Failed to fetch monitoring data:', error);
        } finally {
          setLoading(false);
        }
      };

      if (loading) return <div style={styles.loading}>Loading metrics...</div>;
      if (!metrics) return <div style={styles.error}>Failed to load metrics</div>;

      return (
        <div style={styles.container}>
          <h1 style={styles.title}>Admin Monitoring Dashboard</h1>

          {/* Health Overview */}
          <section style={styles.section}>
            <h2>App Health</h2>
            <div style={styles.grid}>
              <MetricCard label="Uptime" value={formatUptime(metrics.uptime)} />
              <MetricCard label="Active Users" value={metrics.activeUsers} />
              <MetricCard label="Avg Response Time" value={`${metrics.avgResponseTime.toFixed(0)}ms`} />
              <MetricCard label="Error Rate" value={`${metrics.errorRate.toFixed(2)}%`} color={metrics.errorRate > 5 ? 'red' : 'green'} />
            </div>
          </section>

          {/* Performance */}
          <section style={styles.section}>
            <h2>Performance</h2>
            <div style={styles.grid}>
              <MetricCard label="Cache Hit Rate" value={`${metrics.cacheHitRate.toFixed(1)}%`} />
              <MetricCard label="Disk Usage" value={`${(metrics.diskUsage.used / 1024 / 1024 / 1024).toFixed(1)} GB`} subvalue={`${metrics.diskUsage.percentage.toFixed(1)}%`} />
              <MetricCard label="Memory Usage" value={`${(metrics.memory.used / 1024 / 1024).toFixed(0)} MB`} subvalue={`${metrics.memory.percentage.toFixed(1)}%`} />
            </div>
          </section>

          {/* Orders */}
          <section style={styles.section}>
            <h2>Orders</h2>
            <div style={styles.grid}>
              <MetricCard label="Total Orders" value={metrics.totalOrders} />
              <MetricCard label="Orders (Last 24h)" value={metrics.ordersLast24h} />
            </div>
          </section>

          {/* Recent Errors */}
          <section style={styles.section}>
            <h2>Recent Errors</h2>
            {errors.length === 0 ? (
              <div style={styles.noErrors}>No recent errors âœ“</div>
            ) : (
              <div style={styles.errorList}>
                {errors.map((err, i) => (
                  <div key={i} style={{...styles.errorItem, backgroundColor: err.level === 'error' ? '#ffebee' : '#fff3e0'}}>
                    <span style={styles.errorTime}>{new Date(err.timestamp).toLocaleString()}</span>
                    <span style={styles.errorMessage}>{err.message}</span>
                    {err.endpoint && <span style={styles.errorEndpoint}>{err.endpoint}</span>}
                  </div>
                ))}
              </div>
            )}
          </section>
        </div>
      );
    }

    function MetricCard({ label, value, subvalue, color }: any) {
      return (
        <div style={styles.card}>
          <div style={styles.cardLabel}>{label}</div>
          <div style={{...styles.cardValue, color: color || '#333'}}>{value}</div>
          {subvalue && <div style={styles.cardSubvalue}>{subvalue}</div>}
        </div>
      );
    }

    function formatUptime(seconds: number): string {
      const days = Math.floor(seconds / 86400);
      const hours = Math.floor((seconds % 86400) / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      return `${days}d ${hours}h ${mins}m`;
    }

    const styles = {
      container: { padding: '20px', maxWidth: '1200px', margin: '0 auto' },
      title: { fontSize: '28px', marginBottom: '30px' },
      section: { marginBottom: '40px' },
      grid: { display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px' },
      card: { padding: '20px', border: '1px solid #ddd', borderRadius: '8px', backgroundColor: '#fff' },
      cardLabel: { fontSize: '14px', color: '#666', marginBottom: '8px' },
      cardValue: { fontSize: '32px', fontWeight: 'bold' },
      cardSubvalue: { fontSize: '14px', color: '#999', marginTop: '4px' },
      errorList: { display: 'flex', flexDirection: 'column' as const, gap: '10px' },
      errorItem: { padding: '12px', borderRadius: '4px', fontSize: '14px', display: 'flex', gap: '10px', alignItems: 'center' },
      errorTime: { fontSize: '12px', color: '#666', minWidth: '140px' },
      errorMessage: { flex: 1 },
      errorEndpoint: { fontSize: '12px', color: '#999' },
      noErrors: { padding: '20px', textAlign: 'center' as const, color: '#4caf50', fontSize: '16px' },
      loading: { padding: '40px', textAlign: 'center' as const, fontSize: '18px' },
      error: { padding: '40px', textAlign: 'center' as const, fontSize: '18px', color: 'red' },
    };
    ```

    Add route in [archibald-web-app/frontend/src/App.tsx](archibald-web-app/frontend/src/App.tsx):

    ```tsx
    import { AdminMonitoring } from './pages/AdminMonitoring';

    // Inside router configuration
    <Route path="/admin/monitoring" element={<AdminMonitoring />} />
    ```

    Key decisions:
    - Simple, clean UI (no heavy charting libraries for MVP)
    - 30-second auto-refresh (balance freshness vs. server load)
    - Color-coded metrics (red for high error rate)
    - Inline styles (consistency with existing project patterns)
    - Admin-only route (protected by backend 403)
  </action>
  <verify>
    - [archibald-web-app/frontend/src/pages/AdminMonitoring.tsx](archibald-web-app/frontend/src/pages/AdminMonitoring.tsx) created
    - Route added to App.tsx
    - Component fetches /api/admin/metrics and /api/admin/errors
    - Auto-refresh every 30 seconds
    - TypeScript compiles without errors
  </verify>
  <done>
    Admin monitoring dashboard React component created with auto-refresh and error display
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Metrics collection service implemented
- [ ] Admin API endpoints created (/api/admin/metrics, /api/admin/errors)
- [ ] requireAdmin middleware protects endpoints
- [ ] Response time tracking middleware integrated
- [ ] AdminMonitoring React component created
- [ ] Route added at /admin/monitoring
- [ ] Dashboard displays: uptime, active users, response time, error rate, cache hit rate, disk/memory usage, orders, recent errors
- [ ] Auto-refresh every 30 seconds working
</verification>

<success_criteria>

- All tasks completed
- Monitoring dashboard accessible at /admin/monitoring
- Metrics display correctly
- Admin-only access enforced
- No errors in verification checks
</success_criteria>

<output>
After completion, create `.planning/phases/12-deployment-infrastructure/12-04-SUMMARY.md`
</output>
