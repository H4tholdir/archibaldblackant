---
phase: 30-websocket-client-reconnect
plan: 01
type: execute
---

<objective>
Implementare frontend WebSocket client con auto-reconnect, exponential backoff, event handling per draft/pending operations e offline queue.

Purpose: Connettere frontend al WebSocket server (Phase 29) per real-time sync multi-device, sostituendo polling HTTP (15s) con latency <100ms.
Output: WebSocket client service funzionante con reconnection automatica, event handling, offline queue, integration con localStorage JWT.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-websocket-server-infrastructure/29-01-SUMMARY.md
@SYNC-ARCHITECTURE-RESEARCH.md

**From Phase 29 (WebSocket Server):**
- Server endpoint: ws://localhost:3000/ws/realtime (production: wss://...)
- Authentication: JWT in query param (?token=xxx) or Authorization header
- Event types: DRAFT_CREATED, DRAFT_UPDATED, DRAFT_DELETED, DRAFT_CONVERTED, PENDING_CREATED, PENDING_UPDATED, PENDING_DELETED
- Server broadcast pattern: broadcast(userId, event) sends to all user devices
- Ping/pong heartbeat: 30s interval server-side

**Tech stack available:**
- React 19.2.3 (frontend)
- TypeScript strict mode
- localStorage for JWT storage (from Phase 6)
- Browser native WebSocket API
- React hooks (useState, useEffect, useCallback, useRef)

**Established patterns:**
- Custom hooks for reusable logic (useVoiceInput exists)
- Singleton services pattern (backend)
- Structured error handling with toast notifications

**Discovery findings (Level 1 - Quick):**
- **WebSocket reconnection**: Standard pattern with exponential backoff (initial 1s, max 30s, multiplier 2x)
- **Browser WebSocket API**: Native support, no library needed
- **Offline queue**: Array in memory + localStorage persistence for durability
- **Event handling**: Event-driven architecture with callbacks/subscriptions

**Current sync mechanism (to be replaced):**
- Location: UnifiedSyncService (polling every 15s)
- Tombstone pattern (to be eliminated in Phase 33)
- IndexedDB for local storage

**Target architecture:**
- WebSocket client service (singleton or React context)
- Auto-reconnect with exponential backoff
- Event emitter pattern for subscriptions
- Offline queue with automatic replay on reconnect
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebSocket Client Service Hook</name>
  <files>frontend/src/hooks/useWebSocket.ts, frontend/src/types/websocket.ts</files>
  <action>
Create custom React hook useWebSocket() che gestisce:
- WebSocket connection al server endpoint (ws://localhost:3000/ws/realtime in dev, env var per production)
- JWT token da localStorage (chiave "authToken" da Phase 6)
- Connection states: CONNECTING, CONNECTED, DISCONNECTED, RECONNECTING
- Auto-reconnect con exponential backoff (initial: 1000ms, max: 30000ms, multiplier: 2)
- Heartbeat client-side (opzionale, server già fa ping/pong)
- Event subscription pattern: subscribe(eventType, callback) e unsubscribe(eventType, callback)
- Send message method: send(type, payload) con offline queue se disconnesso
- Cleanup on unmount

TypeScript types in types/websocket.ts:
- WebSocketState: "connecting" | "connected" | "disconnected" | "reconnecting"
- WebSocketEvent { type: string, payload: any, timestamp: string }
- WebSocketHookReturn { state: WebSocketState, send: (type, payload) => void, subscribe: (type, callback) => void, unsubscribe: (type, callback) => void }

Implementation details:
- Use useRef per WebSocket instance (persist across renders)
- Use useState per connection state
- Use useEffect per setup/cleanup
- Use useCallback per memoized callbacks
- Reconnect logic: setTimeout con backoff calculation
- Token refresh: se JWT expired, close connection e richiedere re-login

AVOID creating WebSocket on every render (use useRef). AVOID memory leaks (cleanup listeners on unmount). AVOID infinite reconnect loops (max attempts or exponential backoff cap).
  </action>
  <verify>
1. TypeScript compiles without errors: npm run build
2. useWebSocket hook exports correct interface (state, send, subscribe, unsubscribe)
3. Types defined in types/websocket.ts
4. No ESLint warnings for missing dependencies in useEffect
  </verify>
  <done>
- useWebSocket custom hook created with connection management
- Auto-reconnect with exponential backoff implemented
- Event subscription pattern (subscribe/unsubscribe) working
- Send method with offline queue support
- TypeScript strict mode compliant
- Cleanup on unmount prevents memory leaks
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Offline Queue with localStorage Persistence</name>
  <files>frontend/src/services/websocket-queue.ts</files>
  <action>
Create WebSocketQueue service che gestisce:
- In-memory queue: Array<{ type: string, payload: any, timestamp: string, id: string }>
- localStorage persistence: chiave "wsOfflineQueue", sync on every add/remove
- Methods:
  - enqueue(type, payload): void - Add to queue
  - dequeue(): QueueItem | null - Get next item
  - dequeueAll(): QueueItem[] - Get all and clear
  - clear(): void - Clear queue
  - getAll(): QueueItem[] - Read-only access
  - size(): number - Queue length
- Singleton pattern o export const (no class necessaria se stateless)
- Max queue size: 100 items (prevent memory issues)
- Auto-cleanup: remove items older than 24h on load

Integration con useWebSocket:
- When send() called while disconnected → enqueue()
- When connection established → dequeueAll() and replay
- When replay fails → keep in queue for next reconnect

AVOID storing sensitive data in queue (only operation metadata). AVOID unbounded queue growth (max 100 items). AVOID blocking main thread (localStorage ops are sync but fast for small data).
  </action>
  <verify>
1. TypeScript compiles: npm run build
2. WebSocketQueue exports methods: enqueue, dequeue, dequeueAll, clear, getAll, size
3. localStorage persistence verified (manual test: add item, refresh page, item still there)
4. Max queue size enforced (try adding 101 items, verify only 100 kept)
  </verify>
  <done>
- WebSocketQueue service created with localStorage persistence
- Queue methods implemented (enqueue, dequeue, dequeueAll, clear, getAll, size)
- Max size enforcement (100 items)
- Auto-cleanup for items >24h old
- Integration ready for useWebSocket hook
- TypeScript strict mode compliant
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>WebSocket client hook con auto-reconnect, exponential backoff, offline queue e event subscriptions</what-built>
  <how-to-verify>
1. Start backend server: cd archibald-web-app/backend && npm start
2. Start frontend: cd archibald-web-app/frontend && npm run dev
3. Open browser DevTools → Console
4. Create test component:
   ```tsx
   import { useWebSocket } from './hooks/useWebSocket';

   function TestComponent() {
     const { state, send, subscribe } = useWebSocket();

     useEffect(() => {
       const unsubscribe = subscribe('DRAFT_CREATED', (data) => {
         console.log('Draft created:', data);
       });
       return unsubscribe;
     }, [subscribe]);

     return <div>WebSocket State: {state}</div>;
   }
   ```
5. Verify connection state changes: CONNECTING → CONNECTED
6. Test reconnect: Stop backend server, state should become RECONNECTING, restart server, state should become CONNECTED
7. Test offline queue: Disconnect, call send(), verify localStorage has "wsOfflineQueue" with item
8. Verify exponential backoff in console logs (1s, 2s, 4s, 8s, 16s, 30s cap)
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] npm run build succeeds without TypeScript errors
- [ ] Frontend dev server starts without errors
- [ ] useWebSocket hook connects to ws://localhost:3000/ws/realtime
- [ ] Connection state updates correctly (CONNECTING → CONNECTED)
- [ ] Auto-reconnect works when server disconnects
- [ ] Exponential backoff implemented (1s → 2s → 4s → 8s → 16s → 30s max)
- [ ] Offline queue persists to localStorage
- [ ] Event subscription pattern working
- [ ] No memory leaks on unmount
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- useWebSocket hook follows React best practices (no deps warnings)
- WebSocketQueue service handles offline scenarios
- Exponential backoff prevents server overload
- Event subscription pattern ready for Phase 31-32 (draft/pending sync)
- localStorage persistence ensures durability
- TypeScript strict mode compliant
- Phase 30 complete, ready for Phase 31 (Draft Orders Real-Time Sync)
  </success_criteria>

<output>
After completion, create `.planning/phases/30-websocket-client-reconnect/30-01-SUMMARY.md`:

# Phase 30 Plan 01: WebSocket Client & Auto-Reconnect Summary

**Frontend WebSocket client con auto-reconnect, exponential backoff, offline queue e event subscriptions pronto per draft/pending real-time sync**

## Accomplishments

- useWebSocket custom React hook with connection state management
- Auto-reconnect con exponential backoff (1s → 30s max)
- Event subscription pattern (subscribe/unsubscribe callbacks)
- WebSocketQueue service con localStorage persistence
- Offline queue with automatic replay on reconnect
- Max queue size enforcement (100 items)
- Auto-cleanup for stale queue items (>24h)
- Integration con JWT authentication da localStorage

## Files Created/Modified

- `frontend/src/hooks/useWebSocket.ts` - Custom hook for WebSocket management (new)
- `frontend/src/services/websocket-queue.ts` - Offline queue service (new)
- `frontend/src/types/websocket.ts` - TypeScript types for WebSocket (new)

## Decisions Made

- Auto-reconnect backoff: initial 1s, max 30s, multiplier 2x
- Offline queue max size: 100 items (prevent memory issues)
- Queue persistence: localStorage with "wsOfflineQueue" key
- Queue cleanup: auto-remove items >24h old
- Event pattern: subscribe/unsubscribe callback-based
- No external WebSocket library (use browser native API)

## Issues Encountered

[Descrivere problemi incontrati durante execution, o "None"]

## Next Phase Readiness

Ready for Phase 31: Draft Orders Real-Time Sync
- WebSocket client infrastructure pronta
- Event subscription pattern ready for DRAFT_* events
- Offline queue ready for CREATE/UPDATE/DELETE operations
- Auto-reconnect ensures reliability
</output>
