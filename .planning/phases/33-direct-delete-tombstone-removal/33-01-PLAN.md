---
phase: 33-direct-delete-tombstone-removal
plan: 01
type: execute
---

<objective>
Rimuovere completamente sistema tombstones (deleted flag) per drafts e pending orders, implementare direct DELETE in IndexedDB, semplificare codice eliminando ~500 righe di logica tombstone filtering.

Purpose: Semplificare architettura rimuovendo pattern legacy (tombstones), migliorare performance eliminando filtering overhead, ridurre complessità codebase per manutenibilità futura.

Output: Direct DELETE implementato per drafts e pending orders, deleted flag rimosso da schema, tombstone filtering eliminato da hooks e services, codice semplificato ~500 linee in meno.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# WebSocket Real-Time Sync (Phase 29-32)
@.planning/phases/31-draft-orders-realtime-sync/31-01-SUMMARY.md
@.planning/phases/32-pending-orders-realtime-sync/32-01-SUMMARY.md

# Key files
@archibald-web-app/frontend/src/db/schema.ts
@archibald-web-app/frontend/src/hooks/useDraftSync.ts
@archibald-web-app/frontend/src/hooks/usePendingSync.ts
@archibald-web-app/frontend/src/services/draft-realtime.service.ts
@archibald-web-app/frontend/src/services/pending-realtime.service.ts
@archibald-web-app/backend/src/draft-realtime.service.ts
@archibald-web-app/backend/src/pending-realtime.service.ts

**Tech stack available (Phase 29-32):**
- WebSocket server at ws://localhost:3000/ws/realtime with JWT auth
- Frontend useWebSocket() hook con auto-reconnect
- DraftRealtimeService + PendingRealtimeService (backend singletons)
- DraftRealtimeService + PendingRealtimeService (frontend singletons)
- useDraftSync() + usePendingSync() React hooks
- Event-driven subscriptions con cleanup automatico

**Established patterns (Phase 31-32):**
- Server: Singleton service pattern con emit methods
- Client: Event handlers con IndexedDB updates
- React hooks: Real-time subscription lifecycle
- Last-Write-Wins conflict resolution
- Echo prevention via deviceId
- Full object in events (no delta patches)

**Current tombstone implementation:**
- Schema: `deleted?: boolean` in DraftOrder and PendingOrder interfaces
- Backend: REST DELETE endpoints set `deleted: true` instead of actual deletion
- Backend: WebSocket events DRAFT_DELETED/PENDING_DELETED broadcast tombstone
- Frontend: Event handlers write `{ ...order, deleted: true }` to IndexedDB
- Frontend: React hooks filter `!order.deleted` before rendering UI
- Conflict resolution: "Tombstone always wins" logic in LWW comparison

**Tombstone locations (files to modify):**
1. Schema: `frontend/src/db/schema.ts` - Remove `deleted?: boolean` from interfaces
2. Hooks: `useDraftSync.ts`, `usePendingSync.ts` - Remove `.filter((order) => !order.deleted)`
3. Services: `draft-realtime.service.ts`, `pending-realtime.service.ts` - Replace tombstone with `db.delete()`
4. Backend: `backend/src/routes/sync-routes.ts` - DELETE endpoints actual deletion (not tombstone)
5. Backend: `backend/src/draft-realtime.service.ts`, `backend/src/pending-realtime.service.ts` - Event payloads removal

**Constraining decisions:**
- Phase 32-01: Periodic sync eliminated, all real-time via WebSocket
- Phase 31-01: Last-Write-Wins conflict resolution (no longer needs "tombstone always wins")
- Phase 31-01: Echo prevention via deviceId filtering
- Phase 31-01: REST endpoints preserved for HTTP fallback
- Phase 29-01: Connection pool Map<userId, Set<WebSocket>> for multi-device broadcast

**Migration goal:**
- Remove `deleted?: boolean` field from DraftOrder and PendingOrder interfaces
- Replace tombstone write (`db.put({ ...order, deleted: true })`) with direct delete (`db.delete(orderId)`)
- Remove tombstone filtering (`.filter(order => !order.deleted)`) from hooks
- Simplify conflict resolution (remove "tombstone always wins" logic)
- Update backend DELETE endpoints to perform actual database deletion
- Verify backend cascade deletion still works (server-side already implemented)
- Estimated code reduction: ~500 lines (filtering logic, tombstone handling, comments)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend Direct DELETE Implementation</name>
  <files>archibald-web-app/backend/src/routes/sync-routes.ts</files>
  <action>
    Update backend REST DELETE endpoints to perform actual database deletion instead of tombstone marking:

    **1. Update DELETE /api/sync/draft-orders/:id endpoint:**

    Current behavior:
    - Sets `deleted: true` flag on draft order record
    - Keeps record in database (tombstone)

    New behavior:
    - Perform actual SQL DELETE on draft order record
    - Remove record from database completely
    - Still emit DRAFT_DELETED WebSocket event (payload unchanged)

    Implementation:
    ```typescript
    // OLD: UPDATE draft_orders SET deleted = 1 WHERE id = ?
    // NEW: DELETE FROM draft_orders WHERE id = ?
    await db.execute(
      sql`DELETE FROM draft_orders WHERE id = ${id} AND user_id = ${userId}`
    );
    ```

    **2. Update DELETE /api/sync/pending-orders/:id endpoint:**

    Current behavior:
    - Sets `deleted: true` flag on pending order record
    - Keeps record in database (tombstone)

    New behavior:
    - Perform actual SQL DELETE on pending order record
    - Remove record from database completely
    - Still emit PENDING_DELETED WebSocket event (payload unchanged)

    Implementation:
    ```typescript
    // OLD: UPDATE pending_orders SET deleted = 1 WHERE id = ?
    // NEW: DELETE FROM pending_orders WHERE id = ?
    await db.execute(
      sql`DELETE FROM pending_orders WHERE id = ${id} AND user_id = ${userId}`
    );
    ```

    **3. Verify cascade deletion:**
    - Draft deletion should cascade to related pending orders (via originDraftId foreign key)
    - Check if CASCADE DELETE constraint exists in schema
    - If not present, manually delete related pending orders before draft deletion

    **4. WebSocket event payloads:**
    - DRAFT_DELETED payload remains unchanged: `{ draftId, deleted: true, timestamp, deviceId }`
    - PENDING_DELETED payload remains unchanged: `{ pendingOrderId, deleted: true, timestamp, deviceId }`
    - Frontend will interpret these events as direct deletion (Task 2 changes frontend logic)

    **Error handling:**
    - 404 if record doesn't exist (not an error - idempotent deletion)
    - 403 if userId doesn't match (unauthorized deletion attempt)
    - Log successful deletions for audit trail

    **AVOID:**
    - Do NOT modify WebSocket event payload structure (frontend expects same format)
    - Do NOT remove WebSocket event emission (multi-device sync requires it)
    - Do NOT break cascade deletion (draft → pending order relationship)
  </action>
  <verify>
    npm run build in backend succeeds

    Check SQL queries:
    - DELETE statements replace UPDATE statements for tombstone
    - WHERE clauses include userId for security
    - Cascade deletion verified (foreign key constraints or manual deletion)

    Check WebSocket emission:
    - emitDraftDeleted() still called after DELETE
    - emitPendingDeleted() still called after DELETE
    - Event payloads unchanged
  </verify>
  <done>
    - DELETE endpoints perform actual database deletion (not tombstone)
    - SQL DELETE statements replace UPDATE tombstone logic
    - Cascade deletion verified and working
    - WebSocket events still emitted with same payload format
    - Error handling covers 404 (idempotent) and 403 (unauthorized)
    - TypeScript compilation passes
    - No breaking changes to WebSocket event format
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend Direct DELETE & Schema Update</name>
  <files>archibald-web-app/frontend/src/db/schema.ts, archibald-web-app/frontend/src/services/draft-realtime.service.ts, archibald-web-app/frontend/src/services/pending-realtime.service.ts</files>
  <action>
    Update frontend to perform direct IndexedDB deletion and remove deleted flag from schema:

    **1. Update schema.ts:**

    Remove `deleted?: boolean` field from DraftOrder interface:
    ```typescript
    // REMOVE THIS LINE:
    deleted?: boolean; // Tombstone: marked for deletion, pending server DELETE
    ```

    Remove `deleted?: boolean` field from PendingOrder interface:
    ```typescript
    // REMOVE THIS LINE:
    deleted?: boolean; // Tombstone: marked for deletion, pending server DELETE
    ```

    **2. Update draft-realtime.service.ts handleDraftDeleted():**

    Current behavior:
    - Writes tombstone: `db.draftOrders.put({ ...existingDraft, deleted: true })`
    - Keeps record in IndexedDB with deleted flag

    New behavior:
    - Perform direct deletion: `db.draftOrders.delete(data.draftId)`
    - Remove record from IndexedDB completely
    - No tombstone filtering needed

    Implementation:
    ```typescript
    // OLD:
    // await db.draftOrders.put({
    //   ...existingDraft,
    //   deleted: true,
    //   updatedAt: data.timestamp,
    // });

    // NEW:
    await db.draftOrders.delete(data.draftId);
    ```

    **3. Update pending-realtime.service.ts handlePendingDeleted():**

    Current behavior:
    - Writes tombstone: `db.pendingOrders.put({ ...existingOrder, deleted: true })`
    - Keeps record in IndexedDB with deleted flag

    New behavior:
    - Perform direct deletion: `db.pendingOrders.delete(data.pendingOrderId)`
    - Remove record from IndexedDB completely

    Implementation:
    ```typescript
    // OLD:
    // await db.pendingOrders.put({
    //   ...existingOrder,
    //   deleted: true,
    //   updatedAt: data.timestamp,
    // });

    // NEW:
    await db.pendingOrders.delete(data.pendingOrderId);
    ```

    **4. Simplify conflict resolution (remove "tombstone always wins" logic):**

    In handleDraftUpdated() and handlePendingUpdated():
    - Remove special case: `if (data.deleted === true)` → always accept tombstone
    - Keep standard LWW: `if (data.serverUpdatedAt > local.updatedAt)` → accept server version
    - Tombstones no longer exist, so no special handling needed

    **5. Update echo prevention:**
    - Keep existing deviceId filtering (still needed for multi-device sync)
    - Echo prevention unchanged for CREATED/UPDATED events
    - Echo prevention for DELETED events: still filter own deviceId (local deletion already applied)

    **Error handling:**
    - If record doesn't exist during DELETE, ignore (idempotent - may have been deleted locally first)
    - Log all deletions for debugging
    - Notify UI update after deletion (existing notifyUpdate() pattern)

    **AVOID:**
    - Do NOT change WebSocket subscription logic (events still the same)
    - Do NOT modify event payload parsing (backend sends same format)
    - Do NOT remove echo prevention (still needed for multi-device)
  </action>
  <verify>
    npm run build in frontend succeeds
    npm run type-check passes

    Check schema changes:
    - `deleted?: boolean` removed from DraftOrder interface
    - `deleted?: boolean` removed from PendingOrder interface
    - No TypeScript errors from removed field

    Check service changes:
    - `db.draftOrders.delete()` replaces tombstone put
    - `db.pendingOrders.delete()` replaces tombstone put
    - Conflict resolution simplified (no tombstone special case)
    - Echo prevention preserved
  </verify>
  <done>
    - Schema updated: deleted field removed from both interfaces
    - Direct deletion implemented: db.delete() replaces tombstone put
    - Conflict resolution simplified: "tombstone always wins" logic removed
    - Echo prevention preserved for all event types
    - Error handling covers missing records (idempotent deletion)
    - TypeScript compilation passes
    - Type checking passes (no errors from removed deleted field)
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove Tombstone Filtering from React Hooks</name>
  <files>archibald-web-app/frontend/src/hooks/useDraftSync.ts, archibald-web-app/frontend/src/hooks/usePendingSync.ts</files>
  <action>
    Remove tombstone filtering logic from React hooks (no longer needed with direct deletion):

    **1. Update useDraftSync.ts loadDrafts() function:**

    Current logic:
    ```typescript
    const allDrafts = await db.draftOrders.toArray();

    // Filter out deleted drafts (tombstones)
    const activeDrafts = allDrafts.filter((draft) => !draft.deleted);

    // Sort by updatedAt descending
    activeDrafts.sort(...);

    setDrafts(activeDrafts);
    ```

    New logic (simplified):
    ```typescript
    const drafts = await db.draftOrders.toArray();

    // Sort by updatedAt descending (newest first)
    drafts.sort((a, b) => {
      const aTime = new Date(a.updatedAt).getTime();
      const bTime = new Date(b.updatedAt).getTime();
      return bTime - aTime;
    });

    setDrafts(drafts);
    ```

    Remove comment: `// Filter out deleted drafts (tombstones)`
    Remove line: `const activeDrafts = allDrafts.filter((draft) => !draft.deleted);`
    Rename variable: `allDrafts` → `drafts` (no longer need "active" distinction)

    **2. Update usePendingSync.ts loadPendingOrders() function:**

    Current logic:
    ```typescript
    const allOrders = await db.pendingOrders.toArray();

    // Filter out deleted orders (tombstones)
    const activeOrders = allOrders.filter((order) => !order.deleted);

    // Sort by updatedAt descending
    activeOrders.sort(...);

    setPendingOrders(activeOrders);
    ```

    New logic (simplified):
    ```typescript
    const orders = await db.pendingOrders.toArray();

    // Sort by updatedAt descending (newest first)
    orders.sort((a, b) => {
      const aTime = new Date(a.updatedAt).getTime();
      const bTime = new Date(b.updatedAt).getTime();
      return bTime - aTime;
    });

    setPendingOrders(orders);
    ```

    Remove comment: `// Filter out deleted orders (tombstones)`
    Remove line: `const activeOrders = allOrders.filter((order) => !order.deleted);`
    Rename variable: `allOrders` → `orders` (no longer need "active" distinction)

    **3. Update comments:**
    - Remove all references to "tombstone" in comments
    - Remove all references to "active" vs "all" (distinction no longer needed)
    - Update hook documentation to reflect direct deletion behavior

    **Code reduction estimate:**
    - useDraftSync.ts: ~3 lines removed (filter + comment + variable rename simplification)
    - usePendingSync.ts: ~3 lines removed (filter + comment + variable rename simplification)
    - Total: ~6 lines direct removal, ~10 lines simplification (comments, variable names)

    **AVOID:**
    - Do NOT change WebSocket subscription setup (subscriptions unchanged)
    - Do NOT modify refetch() logic (just calls loadDrafts/loadPendingOrders)
    - Do NOT remove sorting (still needed for UI display order)
  </action>
  <verify>
    npm run build succeeds
    npm run type-check passes

    Check hook changes:
    - `.filter(order => !order.deleted)` removed from useDraftSync
    - `.filter(order => !order.deleted)` removed from usePendingSync
    - Variable names simplified (no "active" vs "all" distinction)
    - Comments updated (no "tombstone" references)

    Verify functionality:
    - Hooks still load from IndexedDB
    - Hooks still sort by updatedAt
    - Hooks still subscribe to WebSocket events
    - No TypeScript errors
  </verify>
  <done>
    - Tombstone filtering removed from useDraftSync loadDrafts()
    - Tombstone filtering removed from usePendingSync loadPendingOrders()
    - Variable names simplified (drafts instead of activeDrafts, orders instead of activeOrders)
    - Comments updated (no tombstone/active references)
    - Code simplified by ~16 lines total
    - TypeScript compilation passes
    - Type checking passes
    - WebSocket subscription logic unchanged
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] npm run build succeeds in both backend and frontend
- [ ] npm run type-check passes in frontend
- [ ] Backend DELETE endpoints perform actual database deletion
- [ ] Frontend services use db.delete() instead of tombstone put
- [ ] Schema no longer has deleted field in DraftOrder and PendingOrder
- [ ] Hooks no longer filter tombstones
- [ ] WebSocket events still emitted and received correctly
- [ ] Echo prevention still works (deviceId filtering)
- [ ] LWW conflict resolution simplified (no tombstone special case)
- [ ] Cascade deletion verified (draft → pending order)
- [ ] No TypeScript errors or warnings
- [ ] Code reduction ~16-20 lines verified (grep count before/after)
</verification>

<success_criteria>

- All 3 tasks completed
- Backend performs actual DELETE (not tombstone)
- Frontend performs direct IndexedDB deletion (db.delete())
- deleted field removed from DraftOrder and PendingOrder interfaces
- Tombstone filtering removed from useDraftSync and usePendingSync hooks
- Conflict resolution simplified (no "tombstone always wins" logic)
- WebSocket events still working (emit and subscribe)
- Echo prevention preserved (deviceId filtering)
- Cascade deletion verified and working
- TypeScript strict mode passes without errors
- Code simplified by ~16-20 lines (filtering + comments)
- No breaking changes to WebSocket event format or subscription logic
</success_criteria>

<output>
After completion, create `.planning/phases/33-direct-delete-tombstone-removal/33-01-SUMMARY.md`:

# Phase 33 Plan 01: Direct Delete & Tombstone Removal Summary

**Tombstone pattern eliminato completamente, direct DELETE implementato per drafts e pending orders, codice semplificato ~16-20 linee**

## Accomplishments

- Backend direct DELETE: SQL DELETE statements sostituiscono UPDATE tombstone
- Frontend direct DELETE: db.delete() sostituisce tombstone put
- Schema cleanup: deleted field rimosso da DraftOrder e PendingOrder
- Hooks semplificati: tombstone filtering rimosso da useDraftSync e usePendingSync
- Conflict resolution semplificata: "tombstone always wins" logic eliminata
- WebSocket events preservati: emit/subscribe funzionano identicamente
- Cascade deletion verificata: draft → pending order deletion works

## Files Created/Modified

### Backend
- `backend/src/routes/sync-routes.ts` - DELETE endpoints con actual database deletion (MODIFIED)

### Frontend
- `frontend/src/db/schema.ts` - Rimosso deleted field da interfaces (MODIFIED)
- `frontend/src/services/draft-realtime.service.ts` - Direct db.delete() per DRAFT_DELETED (MODIFIED)
- `frontend/src/services/pending-realtime.service.ts` - Direct db.delete() per PENDING_DELETED (MODIFIED)
- `frontend/src/hooks/useDraftSync.ts` - Rimosso tombstone filtering (MODIFIED)
- `frontend/src/hooks/usePendingSync.ts` - Rimosso tombstone filtering (MODIFIED)

## Decisions Made

- Direct deletion approach: db.delete() instead of soft delete (tombstone)
- WebSocket event payload unchanged: backward compatibility with event format
- Cascade deletion verified: existing foreign key constraints working
- Echo prevention preserved: deviceId filtering still necessary for multi-device
- LWW simplification: removed "tombstone always wins" special case

## Issues Encountered

[Documentare eventuali problemi e risoluzioni]

## Code Reduction Metrics

- Lines removed: ~16-20 total
  - Tombstone filtering: 2 filter lines + 2 comments = 4 lines
  - Variable simplification: 2 lines (activeDrafts → drafts, activeOrders → orders)
  - Conflict resolution: 2 special cases removed = 6 lines
  - Schema + comments: 4 lines
  - Total: 16 lines direct removal, ~4 lines simplification

- Complexity reduction:
  - No more tombstone vs active distinction in hooks
  - No more "tombstone always wins" in conflict resolution
  - No more deleted field in schema (simpler types)
  - Cleaner IndexedDB operations (delete instead of put with flag)

## Next Phase Readiness

Ready for Phase 34: E2E Testing & Multi-Device Validation

**What's ready:**
- WebSocket real-time sync proven for drafts + pending orders
- Direct deletion working (no tombstones to test)
- Simplified codebase easier to test
- All real-time patterns established and stable
- Multi-device sync working with echo prevention

**What Phase 34 needs:**
- E2E test suite with Playwright (multi-device scenarios)
- Test direct deletion across devices
- Validate real-time sync latency <100ms
- Test offline → online scenarios with direct deletion
- Validate cascade deletion in multi-device context
- Performance testing (WebSocket load, IndexedDB operations)

</output>
