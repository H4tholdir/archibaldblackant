# Phase 3 Plan 04: Quantity Validation Against Package Rules

**Type**: tdd
**Dependencies**: 03-02 (DB functions), 03-03 (bot package selection)
**Estimated Complexity**: Medium
**Files Modified**: 2-3

---

## Objective

Implement quantity validation to ensure ordered quantities respect package min/multiple/max rules, preventing the "quantity becomes 0" issue.

**Success Criteria**:
- ✅ Validation function checks qty against min/multiple/max rules
- ✅ Bot validates before submitting order
- ✅ Descriptive error messages suggest correct quantities
- ✅ Unit tests cover all validation scenarios

---

## Tasks

### Task 1: Write Validation Function Tests (TDD) - AUTO

**File**: `archibald-web-app/backend/src/product-db.test.ts`

```typescript
describe('validateQuantity', () => {
  test('returns valid for quantity meeting all rules', () => {
    // Given: Product with minQty=5, multipleQty=5, maxQty=500
    const product = { minQty: 5, multipleQty: 5, maxQty: 500 };

    // When: validateQuantity(product, 10)
    const result = validateQuantity(product, 10);

    // Then: { valid: true }
    expect(result.valid).toBe(true);
    expect(result.errors).toEqual([]);
  });

  test('returns error when quantity < minQty', () => {
    // Given: Product with minQty=5
    const product = { minQty: 5, multipleQty: 1 };

    // When: validateQuantity(product, 3)
    const result = validateQuantity(product, 3);

    // Then: Error about minimum quantity
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Quantity must be at least 5');
  });

  test('returns error when quantity not multiple of multipleQty', () => {
    // Given: Product with multipleQty=5
    const product = { minQty: 1, multipleQty: 5 };

    // When: validateQuantity(product, 7)
    const result = validateQuantity(product, 7);

    // Then: Error about multiple
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Quantity must be a multiple of 5');
  });

  test('returns error when quantity > maxQty', () => {
    // Given: Product with maxQty=100
    const product = { minQty: 1, multipleQty: 1, maxQty: 100 };

    // When: validateQuantity(product, 150)
    const result = validateQuantity(product, 150);

    // Then: Error about maximum
    expect(result.valid).toBe(false);
    expect(result.errors).toContain('Quantity cannot exceed 100');
  });

  test('returns multiple errors when multiple rules violated', () => {
    // Given: Product with minQty=5, multipleQty=5, maxQty=100
    const product = { minQty: 5, multipleQty: 5, maxQty: 100 };

    // When: validateQuantity(product, 2)
    const result = validateQuantity(product, 2);

    // Then: Errors for both min and multiple
    expect(result.valid).toBe(false);
    expect(result.errors).toHaveLength(2);
    expect(result.errors).toContain('Quantity must be at least 5');
    expect(result.errors).toContain('Quantity must be a multiple of 5');
  });

  test('suggests nearest valid quantities', () => {
    // Given: Product with multipleQty=5
    const product = { minQty: 5, multipleQty: 5 };

    // When: validateQuantity(product, 7)
    const result = validateQuantity(product, 7);

    // Then: Suggestions provided
    expect(result.suggestions).toEqual([5, 10]);
  });

  test('handles products without validation rules', () => {
    // Given: Product with no min/multiple/max
    const product = {};

    // When: validateQuantity(product, 7)
    const result = validateQuantity(product, 7);

    // Then: Always valid
    expect(result.valid).toBe(true);
  });

  test('handles edge case: quantity = minQty', () => {
    // Given: Product with minQty=5
    const product = { minQty: 5, multipleQty: 5 };

    // When: validateQuantity(product, 5)
    const result = validateQuantity(product, 5);

    // Then: Valid (boundary case)
    expect(result.valid).toBe(true);
  });

  test('handles edge case: quantity = maxQty', () => {
    // Given: Product with maxQty=100
    const product = { maxQty: 100, multipleQty: 1 };

    // When: validateQuantity(product, 100)
    const result = validateQuantity(product, 100);

    // Then: Valid (boundary case)
    expect(result.valid).toBe(true);
  });
});
```

---

### Task 2: Implement Validation Function - AUTO

**File**: `archibald-web-app/backend/src/product-db.ts`

```typescript
export interface ValidationResult {
  valid: boolean;
  errors: string[];
  suggestions?: number[];
}

/**
 * Validate quantity against product package rules.
 *
 * Rules:
 * - quantity >= minQty (if defined)
 * - quantity % multipleQty === 0 (if defined)
 * - quantity <= maxQty (if defined)
 *
 * @param product - Product with validation rules
 * @param quantity - Quantity to validate
 * @returns Validation result with errors and suggestions
 */
export function validateQuantity(
  product: Pick<Product, 'minQty' | 'multipleQty' | 'maxQty'>,
  quantity: number
): ValidationResult {
  const errors: string[] = [];

  // Check minQty
  if (product.minQty && quantity < product.minQty) {
    errors.push(`Quantity must be at least ${product.minQty}`);
  }

  // Check multipleQty
  if (product.multipleQty && quantity % product.multipleQty !== 0) {
    errors.push(`Quantity must be a multiple of ${product.multipleQty}`);
  }

  // Check maxQty
  if (product.maxQty && quantity > product.maxQty) {
    errors.push(`Quantity cannot exceed ${product.maxQty}`);
  }

  // Generate suggestions if invalid
  let suggestions: number[] | undefined;
  if (errors.length > 0 && product.multipleQty) {
    const minQty = product.minQty || product.multipleQty;
    const maxQty = product.maxQty || minQty * 10; // Reasonable default

    // Suggest nearest multiples
    const lower = Math.floor(quantity / product.multipleQty) * product.multipleQty;
    const higher = Math.ceil(quantity / product.multipleQty) * product.multipleQty;

    suggestions = [
      Math.max(lower, minQty),
      Math.min(higher, maxQty),
    ].filter((v, i, arr) => arr.indexOf(v) === i); // Unique values
  }

  return {
    valid: errors.length === 0,
    errors,
    suggestions,
  };
}
```

**Export in ProductDb class**:

```typescript
export class ProductDb {
  // ... existing methods ...

  validateQuantity(productId: string, quantity: number): ValidationResult {
    const product = this.getProductById(productId);
    if (!product) {
      return {
        valid: false,
        errors: [`Product ${productId} not found`],
      };
    }

    return validateQuantity(product, quantity);
  }
}
```

---

### Task 3: Integrate Validation in Bot - AUTO

**File**: `archibald-web-app/backend/src/archibald-bot.ts`

**Add validation before order submission**:

```typescript
// In createOrder(), BEFORE processing items
for (const item of orderData.items) {
  const selectedVariant = this.productDb.selectPackageVariant(
    item.articleCode,
    item.quantity
  );

  if (!selectedVariant) {
    throw new Error(`Article ${item.articleCode} not found in database`);
  }

  // VALIDATE QUANTITY
  const validation = validateQuantity(selectedVariant, item.quantity);

  if (!validation.valid) {
    const errorMsg = [
      `Invalid quantity for ${item.articleCode}:`,
      ...validation.errors,
    ].join('\n  - ');

    if (validation.suggestions) {
      throw new Error(
        `${errorMsg}\n\nSuggested quantities: ${validation.suggestions.join(', ')}`
      );
    }

    throw new Error(errorMsg);
  }

  logger.debug(`Quantity validation passed for ${item.articleCode}`, {
    quantity: item.quantity,
    minQty: selectedVariant.minQty,
    multipleQty: selectedVariant.multipleQty,
    maxQty: selectedVariant.maxQty,
  });
}
```

---

### Task 4: Add Unit Tests for Bot Validation - AUTO

**File**: `archibald-web-app/backend/src/archibald-bot.test.ts`

```typescript
describe('createOrder validation', () => {
  test('throws error for quantity below minQty', async () => {
    const orderData = {
      customerName: 'Fresis',
      items: [
        {
          articleCode: 'H129FSQ.104.023',
          quantity: 2, // minQty = 5 for selected variant
          price: 0,
        },
      ],
    };

    await expect(bot.createOrder(orderData)).rejects.toThrow(
      'Quantity must be at least'
    );
  });

  test('throws error for quantity not multiple of multipleQty', async () => {
    const orderData = {
      customerName: 'Fresis',
      items: [
        {
          articleCode: 'H129FSQ.104.023',
          quantity: 7, // multipleQty = 5
          price: 0,
        },
      ],
    };

    await expect(bot.createOrder(orderData)).rejects.toThrow(
      'Quantity must be a multiple of'
    );
  });

  test('provides suggestions in error message', async () => {
    const orderData = {
      customerName: 'Fresis',
      items: [
        {
          articleCode: 'H129FSQ.104.023',
          quantity: 7,
          price: 0,
        },
      ],
    };

    await expect(bot.createOrder(orderData)).rejects.toThrow(
      'Suggested quantities: 5, 10'
    );
  });
});
```

---

### Task 5: Run Tests & Verify - AUTO

```bash
npm test -- product-db.test.ts
npm test -- archibald-bot.test.ts
```

**Acceptance Criteria**:
- All validation tests pass
- Bot tests pass (or are skipped if no Archibald connection)
- No TypeScript errors
- No linting errors

---

## Files Changed

- `archibald-web-app/backend/src/product-db.ts` - Add `validateQuantity()` function
- `archibald-web-app/backend/src/archibald-bot.ts` - Add validation before order processing
- `archibald-web-app/backend/src/product-db.test.ts` - Add validation tests
- `archibald-web-app/backend/src/archibald-bot.test.ts` - Add bot validation tests

---

## Dependencies

**Requires**:
- 03-02 (Product interface with min/multiple/max fields)

**Blocks**:
- 03-06 (frontend validation uses same logic)

---

## Acceptance Criteria

- ✅ `validateQuantity()` implemented and tested
- ✅ Bot validates quantities before processing
- ✅ Descriptive error messages with suggestions
- ✅ All unit tests pass
- ✅ Edge cases handled (min, max, exact multiples)
- ✅ No breaking changes

---

## Notes

- Validation happens BEFORE Archibald interaction (fail fast)
- Suggestions help users correct invalid quantities
- Same validation logic can be reused in frontend (03-06)
- Prevents "quantity becomes 0" issue by catching invalid quantities early
