---
phase: 19-products-sync-analysis-optimization
plan: 04
title: Background Sync Scheduler & Monitoring
subsystem: backend, scheduler
complexity: medium
estimated_duration: 60min
tags: [scheduler, background-sync, retry-logic, metrics, monitoring]
---

# Plan 19-04: Background Sync Scheduler & Monitoring

## Objective

Implement 30-minute automatic background sync scheduler with retry logic, metrics endpoint, and admin controls, following Phase 18-04 patterns.

## Execution Context

**Phase 18-04 Proven Patterns:**
- 30-minute interval scheduler with startAutoSync()
- 3-retry exponential backoff (5s, 10s, 20s)
- GET /api/{resource}/sync/metrics endpoint
- Sync history tracking in database
- Admin start/stop controls
- PriorityManager integration (paused during order creation)

**User Requirements:**
- Automatic background sync every 30 minutes
- Retry logic for transient failures
- Monitoring endpoint for admin dashboard
- Same patterns as customer sync (Phase 18-04)

**Key Files:**
- Reference: `.planning/phases/18-customers-sync-analysis-optimization/18-04-PLAN.md`
- Reference: `archibald-web-app/backend/src/customer-sync-service.ts` (auto-sync pattern)
- Target: `archibald-web-app/backend/src/product-sync-service.ts` (add scheduler)
- Target: `archibald-web-app/backend/src/index.ts` (add metrics endpoint)

## Context

**Dependencies:**
- Phase 19-03 complete (manual sync working)
- PriorityManager available (pause/resume pattern)
- ProductSyncService has startAutoSync() stub

**Current State:**
- ProductSyncService already has pause/resume methods (from Plan 19-02)
- Need to implement full scheduler with retry logic
- Need to add metrics tracking

## Tasks

### Task 1: Add Sync History Tracking
**Duration:** 15min

Extend ProductDatabase to track sync sessions.

**Schema Update:**
```sql
-- Sync history table (already exists, verify structure)
CREATE TABLE IF NOT EXISTS sync_sessions (
  id TEXT PRIMARY KEY,
  syncType TEXT NOT NULL,
  startedAt INTEGER NOT NULL,
  completedAt INTEGER,
  status TEXT NOT NULL,
  totalPages INTEGER,
  pagesProcessed INTEGER,
  itemsProcessed INTEGER,
  itemsCreated INTEGER,
  itemsUpdated INTEGER,
  itemsDeleted INTEGER,
  errorMessage TEXT,
  syncMode TEXT NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_sync_sessions_type ON sync_sessions(syncType);
CREATE INDEX IF NOT EXISTS idx_sync_sessions_started ON sync_sessions(startedAt);
```

**ProductDatabase Methods:**
```typescript
/**
 * Create sync session record
 */
createSyncSession(sessionId: string): void {
  const stmt = this.db.prepare(`
    INSERT INTO sync_sessions (
      id, syncType, startedAt, status, syncMode
    ) VALUES (?, ?, ?, ?, ?)
  `);

  stmt.run(
    sessionId,
    'products',
    Date.now(),
    'running',
    'auto'
  );
}

/**
 * Update sync session on completion
 */
completeSyncSession(
  sessionId: string,
  result: {
    status: 'completed' | 'failed';
    productsProcessed: number;
    newProducts: number;
    updatedProducts: number;
    errorMessage?: string;
  }
): void {
  const stmt = this.db.prepare(`
    UPDATE sync_sessions
    SET completedAt = ?,
        status = ?,
        itemsProcessed = ?,
        itemsCreated = ?,
        itemsUpdated = ?,
        errorMessage = ?
    WHERE id = ?
  `);

  stmt.run(
    Date.now(),
    result.status,
    result.productsProcessed,
    result.newProducts,
    result.updatedProducts,
    result.errorMessage || null,
    sessionId
  );
}

/**
 * Get sync history (last N sessions)
 */
getSyncHistory(limit: number = 20): SyncSession[] {
  const stmt = this.db.prepare(`
    SELECT * FROM sync_sessions
    WHERE syncType = 'products'
    ORDER BY startedAt DESC
    LIMIT ?
  `);

  return stmt.all(limit) as SyncSession[];
}

/**
 * Get sync metrics (success rate, avg duration, last sync)
 */
getSyncMetrics(): {
  totalSyncs: number;
  successfulSyncs: number;
  failedSyncs: number;
  successRate: number;
  avgDurationMs: number;
  lastSyncAt: number | null;
  lastSyncStatus: string | null;
} {
  const stats = this.db.prepare(`
    SELECT
      COUNT(*) as totalSyncs,
      SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as successfulSyncs,
      SUM(CASE WHEN status = 'failed' THEN 1 ELSE 0 END) as failedSyncs,
      AVG(CASE WHEN completedAt IS NOT NULL THEN completedAt - startedAt ELSE NULL END) as avgDurationMs,
      MAX(startedAt) as lastSyncAt
    FROM sync_sessions
    WHERE syncType = 'products'
  `).get() as any;

  const lastSync = this.db.prepare(`
    SELECT status FROM sync_sessions
    WHERE syncType = 'products'
    ORDER BY startedAt DESC
    LIMIT 1
  `).get() as any;

  return {
    totalSyncs: stats.totalSyncs || 0,
    successfulSyncs: stats.successfulSyncs || 0,
    failedSyncs: stats.failedSyncs || 0,
    successRate: stats.totalSyncs > 0 ? (stats.successfulSyncs / stats.totalSyncs) * 100 : 0,
    avgDurationMs: stats.avgDurationMs || 0,
    lastSyncAt: stats.lastSyncAt || null,
    lastSyncStatus: lastSync?.status || null,
  };
}
```

**Acceptance Criteria:**
- Sync sessions tracked in database
- Metrics methods return accurate stats
- History queryable for admin dashboard

**Commit:** `feat(19-04): add sync history tracking to ProductDatabase`

---

### Task 2: Enhance ProductSyncService with Retry Logic
**Duration:** 20min

Update `syncProducts()` to track sessions and add retry logic to `startAutoSync()`.

**Implementation:**
```typescript
/**
 * Sync products with session tracking
 */
async syncProducts(
  progressCallback?: (progress: SyncProgress) => void
): Promise<SyncResult> {
  const sessionId = `products-sync-${Date.now()}`;
  const startTime = Date.now();

  // Create session record
  this.db.createSyncSession(sessionId);

  try {
    // ... existing sync logic ...

    const result = {
      productsProcessed: parsedProducts.length,
      newProducts,
      updatedProducts,
      duration: Date.now() - startTime,
    };

    // Update session as completed
    this.db.completeSyncSession(sessionId, {
      status: 'completed',
      productsProcessed: result.productsProcessed,
      newProducts: result.newProducts,
      updatedProducts: result.updatedProducts,
    });

    return result;
  } catch (error) {
    // Update session as failed
    this.db.completeSyncSession(sessionId, {
      status: 'failed',
      productsProcessed: 0,
      newProducts: 0,
      updatedProducts: 0,
      errorMessage: error instanceof Error ? error.message : String(error),
    });

    throw error;
  }
}

/**
 * Start automatic background sync with retry logic
 */
startAutoSync(intervalMinutes: number = 30): void {
  logger.info(`[ProductSyncService] Starting auto-sync every ${intervalMinutes} minutes`);

  // Initial sync after 5s with retry
  setTimeout(() => {
    this.syncWithRetry();
  }, 5000);

  // Recurring sync
  this.syncInterval = setInterval(() => {
    if (!this.paused) {
      this.syncWithRetry();
    }
  }, intervalMinutes * 60 * 1000);
}

/**
 * Sync with exponential backoff retry (3 attempts)
 */
private async syncWithRetry(attempt: number = 1): Promise<void> {
  const maxAttempts = 3;
  const backoffDelays = [5000, 10000, 20000]; // 5s, 10s, 20s

  try {
    await this.syncProducts();
    logger.info('[ProductSyncService] Auto-sync successful', { attempt });
  } catch (error) {
    logger.error('[ProductSyncService] Auto-sync failed', { attempt, error });

    if (attempt < maxAttempts) {
      const delay = backoffDelays[attempt - 1];
      logger.info(`[ProductSyncService] Retrying in ${delay}ms (attempt ${attempt + 1}/${maxAttempts})`);

      await new Promise(resolve => setTimeout(resolve, delay));
      return this.syncWithRetry(attempt + 1);
    } else {
      logger.error('[ProductSyncService] All retry attempts exhausted', {
        attempts: maxAttempts,
        error,
      });

      // Emit event for monitoring/alerts
      this.emit('sync-failure', {
        attempts: maxAttempts,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }
}
```

**Acceptance Criteria:**
- Sync sessions tracked in database
- Retry logic with exponential backoff
- Max 3 attempts before giving up
- Event emitted on final failure
- Logs for debugging

**Commit:** `feat(19-04): add retry logic and session tracking to ProductSyncService`

---

### Task 3: Add Metrics API Endpoint
**Duration:** 10min

Add GET /api/products/sync/metrics endpoint.

**Implementation:**
```typescript
// Get products sync metrics
app.get("/api/products/sync/metrics", jwtMiddleware, async (req: AuthRequest, res) => {
  try {
    const db = ProductDatabase.getInstance();
    const metrics = db.getSyncMetrics();
    const history = db.getSyncHistory(10); // Last 10 syncs

    res.json({
      metrics,
      history,
    });
  } catch (error) {
    logger.error("[API] Failed to get products sync metrics", { error });
    res.status(500).json({
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
});
```

**Acceptance Criteria:**
- GET /api/products/sync/metrics returns metrics and history
- JWT-protected
- Used by admin dashboard (future Phase 25)

**Commit:** `feat(19-04): add GET /api/products/sync/metrics endpoint`

---

### Task 4: Add Admin Start/Stop Controls
**Duration:** 10min

Add POST endpoints to start/stop auto-sync.

**Implementation:**
```typescript
// Start auto-sync scheduler
app.post("/api/products/sync/start", jwtMiddleware, async (req: AuthRequest, res) => {
  try {
    const { intervalMinutes = 30 } = req.body;

    logger.info("[API] Starting products auto-sync", {
      userId: req.user?.userId,
      intervalMinutes,
    });

    const service = ProductSyncService.getInstance();
    service.startAutoSync(intervalMinutes);

    res.json({ success: true, intervalMinutes });
  } catch (error) {
    logger.error("[API] Failed to start products auto-sync", { error });
    res.status(500).json({
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
});

// Stop auto-sync scheduler
app.post("/api/products/sync/stop", jwtMiddleware, async (req: AuthRequest, res) => {
  try {
    logger.info("[API] Stopping products auto-sync", {
      userId: req.user?.userId,
    });

    const service = ProductSyncService.getInstance();
    service.stopAutoSync();

    res.json({ success: true });
  } catch (error) {
    logger.error("[API] Failed to stop products auto-sync", { error });
    res.status(500).json({
      error: error instanceof Error ? error.message : "Unknown error",
    });
  }
});
```

**Acceptance Criteria:**
- POST /api/products/sync/start starts scheduler
- POST /api/products/sync/stop stops scheduler
- JWT-protected
- Logs for audit trail

**Commit:** `feat(19-04): add admin start/stop controls for products auto-sync`

---

### Task 5: Enable Auto-Sync on Backend Startup
**Duration:** 5min

Start auto-sync when backend starts.

**Implementation:**
```typescript
// In archibald-web-app/backend/src/index.ts

// Start background sync services on boot
(async () => {
  logger.info("[Boot] Starting background sync services...");

  // Start products auto-sync (30min interval)
  const productSyncService = ProductSyncService.getInstance();
  productSyncService.startAutoSync(30);

  logger.info("[Boot] Products auto-sync started (30min interval)");
})();
```

**Acceptance Criteria:**
- Auto-sync starts on backend boot
- 30-minute interval
- Initial sync after 5 seconds
- Logs for confirmation

**Commit:** `feat(19-04): enable products auto-sync on backend startup`

---

## Verification

### Manual Testing

**Test 1: Auto-Sync Startup**
```bash
cd archibald-web-app/backend
npm run dev
```

**Expected logs:**
```
[Boot] Starting background sync services...
[ProductSyncService] Starting auto-sync every 30 minutes
[Boot] Products auto-sync started (30min interval)
... 5 seconds later ...
[ProductSyncService] Auto-sync successful (attempt 1)
```

**Test 2: Retry Logic**

Simulate failure (disconnect network) and observe:
```
[ProductSyncService] Auto-sync failed (attempt 1)
[ProductSyncService] Retrying in 5000ms (attempt 2/3)
... 5s later ...
[ProductSyncService] Auto-sync failed (attempt 2)
[ProductSyncService] Retrying in 10000ms (attempt 3/3)
... 10s later ...
[ProductSyncService] Auto-sync failed (attempt 3)
[ProductSyncService] All retry attempts exhausted
```

**Test 3: Metrics Endpoint**
```bash
curl -H "Authorization: Bearer $JWT_TOKEN" http://localhost:3000/api/products/sync/metrics
```

**Expected response:**
```json
{
  "metrics": {
    "totalSyncs": 5,
    "successfulSyncs": 4,
    "failedSyncs": 1,
    "successRate": 80,
    "avgDurationMs": 55000,
    "lastSyncAt": 1705678900000,
    "lastSyncStatus": "completed"
  },
  "history": [
    {
      "id": "products-sync-1705678900000",
      "syncType": "products",
      "startedAt": 1705678900000,
      "completedAt": 1705678955000,
      "status": "completed",
      "itemsProcessed": 4540,
      "itemsCreated": 12,
      "itemsUpdated": 8,
      "syncMode": "auto"
    }
  ]
}
```

**Test 4: Start/Stop Controls**
```bash
# Stop auto-sync
curl -X POST -H "Authorization: Bearer $JWT_TOKEN" http://localhost:3000/api/products/sync/stop

# Start auto-sync with 15min interval
curl -X POST -H "Authorization: Bearer $JWT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"intervalMinutes": 15}' \
  http://localhost:3000/api/products/sync/start
```

## Success Criteria

- [ ] Sync history tracked in database
- [ ] Retry logic with exponential backoff (3 attempts)
- [ ] GET /api/products/sync/metrics endpoint working
- [ ] POST /api/products/sync/start endpoint working
- [ ] POST /api/products/sync/stop endpoint working
- [ ] Auto-sync starts on backend boot
- [ ] PriorityManager integration (pause/resume)
- [ ] Event emitted on final failure
- [ ] All endpoints JWT-protected
- [ ] All commits atomic with proper messages

## Output

**Files Modified:**
- `archibald-web-app/backend/src/product-db.ts` (add sync tracking methods)
- `archibald-web-app/backend/src/product-sync-service.ts` (add retry logic)
- `archibald-web-app/backend/src/index.ts` (add metrics and control endpoints)

**Commits:** 5 atomic commits

**Next:** Plan 19-05 (Comprehensive Testing & Performance Validation)
