---
phase: 19-products-sync-analysis-optimization
plan: 02
title: PDF Download Bot Flow & ProductSyncService Refactor
subsystem: bot, sync
complexity: medium
estimated_duration: 60min
tags: [puppeteer, bot, pdf-download, sync-service, refactor]
---

# Plan 19-02: PDF Download Bot Flow & ProductSyncService Refactor

## Objective

Implement bot method to download products PDF from Archibald and refactor ProductSyncService from HTML scraping to PDF-based sync, following Phase 18-02 patterns.

## Execution Context

**Phase 18-02 Proven Patterns:**
- Bot PDF download method (login ‚Üí navigate ‚Üí click export ‚Üí save to /tmp)
- Replace HTML scraping with PDF-based sync
- Hash-based delta detection (MD5)
- Progress callbacks with Italian messages
- Temp file cleanup on success/error
- BrowserPool integration

**User Requirements:**
- Navigate to: https://4.231.124.90/Archibald/INVENTTABLE_ListView/
- Click button: "Esportare in PDF File"
- Performance target: Total sync <60s for ~4,540 products
- No image downloads (eliminated per user request)

**Key Files:**
- Reference: `archibald-web-app/backend/src/archibald-bot.ts` (downloadCustomersPDF method)
- Reference: `archibald-web-app/backend/src/customer-sync-service.ts` (PDF sync pattern)
- Target: Add downloadProductsPDF to ArchibaldBot
- Target: Refactor ProductSyncService (1,000+ lines ‚Üí ~350 lines)

## Context

**Dependencies:**
- Phase 19-01 complete (PDF parser ready)
- Plan 18-02 complete (customer sync pattern proven)
- BrowserPool available

**Current ProductSyncService:**
@archibald-web-app/backend/src/product-sync-service.ts

Currently uses HTML scraping with ImageDownloader. Needs complete refactor to PDF-based sync.

## Tasks

### Task 1: Add downloadProductsPDF Method to ArchibaldBot
**Duration:** 20min

Add method to `archibald-web-app/backend/src/archibald-bot.ts` following downloadCustomersPDF pattern.

**Implementation:**
```typescript
/**
 * Download products PDF export from Archibald
 * @returns Path to downloaded PDF file in /tmp
 */
async downloadProductsPDF(userId: string = 'system'): Promise<string> {
  const startTime = Date.now();
  const timestamp = Date.now();
  const downloadPath = `/tmp/articoli-${timestamp}-${userId}.pdf`;

  try {
    logger.info('[ArchibaldBot] Downloading products PDF...', { userId, downloadPath });

    // Navigate to products page
    await this.page.goto('https://4.231.124.90/Archibald/INVENTTABLE_ListView/', {
      waitUntil: 'networkidle2',
      timeout: 30000,
    });

    logger.info('[ArchibaldBot] Products page loaded');

    // Configure download behavior
    const client = await this.page.target().createCDPSession();
    await client.send('Page.setDownloadBehavior', {
      behavior: 'allow',
      downloadPath: '/tmp',
    });

    // Click export button (text-based selector for stability)
    const exportButtonSelector = 'text=/Esport.*PDF/i';
    await this.page.waitForSelector(exportButtonSelector, { timeout: 10000 });
    await this.page.click(exportButtonSelector);

    logger.info('[ArchibaldBot] Export button clicked, waiting for download...');

    // Wait for download to complete (15s timeout for large file)
    await new Promise(resolve => setTimeout(resolve, 15000));

    // Verify file exists and has content
    const fs = await import('fs/promises');
    const stats = await fs.stat(downloadPath);

    if (!stats.size) {
      throw new Error('Downloaded PDF is empty');
    }

    const duration = Date.now() - startTime;
    logger.info('[ArchibaldBot] Products PDF downloaded successfully', {
      downloadPath,
      sizeKB: Math.round(stats.size / 1024),
      durationMs: duration,
    });

    return downloadPath;
  } catch (error) {
    const duration = Date.now() - startTime;
    logger.error('[ArchibaldBot] Products PDF download failed', {
      error,
      durationMs: duration,
    });
    throw error;
  }
}
```

**Acceptance Criteria:**
- Navigate to products page
- Click export button with stable text selector
- Download to /tmp with timestamp + userId
- Validate file size > 0
- Return path to downloaded PDF
- Duration logging for performance

**Commit:** `feat(19-02): add downloadProductsPDF method to ArchibaldBot`

---

### Task 2: Backup Old ProductSyncService
**Duration:** 2min

Create backup before major refactor.

**Commands:**
```bash
cd archibald-web-app/backend/src
cp product-sync-service.ts product-sync-service.OLD_HTML_SCRAPING.ts.backup
git add -f product-sync-service.OLD_HTML_SCRAPING.ts.backup
```

**Commit:** `chore(19-02): backup old HTML scraping ProductSyncService`

---

### Task 3: Refactor ProductSyncService to PDF-Based Sync
**Duration:** 30min

Replace HTML scraping logic with PDF-based sync following customer-sync-service.ts pattern.

**New Implementation Structure:**
```typescript
import { EventEmitter } from 'events';
import { ProductDatabase, Product } from './product-db';
import { BrowserPool } from './browser-pool';
import { ArchibaldBot } from './archibald-bot';
import { PDFParserProductsService } from './pdf-parser-products-service';
import { logger } from './logger';
import { createHash } from 'crypto';
import { promises as fs } from 'fs';

export interface SyncProgress {
  stage: 'login' | 'download' | 'parse' | 'update' | 'cleanup';
  message: string;
  productsProcessed?: number;
}

export interface SyncResult {
  productsProcessed: number;
  newProducts: number;
  updatedProducts: number;
  duration: number;
}

export class ProductSyncService extends EventEmitter {
  private static instance: ProductSyncService;
  private db: ProductDatabase;
  private pdfParser: PDFParserProductsService;
  private syncInProgress = false;
  private paused = false;
  private syncInterval: NodeJS.Timeout | null = null;

  private constructor() {
    super();
    this.db = ProductDatabase.getInstance();
    this.pdfParser = PDFParserProductsService.getInstance();
  }

  static getInstance(): ProductSyncService {
    if (!ProductSyncService.instance) {
      ProductSyncService.instance = new ProductSyncService();
    }
    return ProductSyncService.instance;
  }

  /**
   * Pause sync service (for PriorityManager)
   */
  async pause(): Promise<void> {
    logger.info('[ProductSyncService] Pause requested');
    this.paused = true;

    if (this.syncInProgress) {
      logger.info('[ProductSyncService] Waiting for current sync to complete...');
      while (this.syncInProgress) {
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    logger.info('[ProductSyncService] Paused');
  }

  /**
   * Resume sync service
   */
  resume(): void {
    logger.info('[ProductSyncService] Resume requested');
    this.paused = false;
    logger.info('[ProductSyncService] Resumed');
  }

  /**
   * Sync products from Archibald via PDF export
   */
  async syncProducts(
    progressCallback?: (progress: SyncProgress) => void
  ): Promise<SyncResult> {
    const startTime = Date.now();

    if (this.syncInProgress) {
      throw new Error('Sync already in progress');
    }

    this.syncInProgress = true;
    let tempPdfPath: string | null = null;

    try {
      // Stage 1: Login & acquire context
      progressCallback?.({
        stage: 'login',
        message: 'Connessione ad Archibald...',
      });

      const context = await BrowserPool.getInstance().acquireContext(
        'product-sync-service',
        'system'
      );

      const bot = new ArchibaldBot(context.page);

      // Stage 2: Download PDF
      progressCallback?.({
        stage: 'download',
        message: 'Scaricamento PDF articoli...',
      });

      tempPdfPath = await bot.downloadProductsPDF('system');

      // Stage 3: Parse PDF
      progressCallback?.({
        stage: 'parse',
        message: 'Analisi PDF in corso...',
      });

      const parsedProducts = await this.pdfParser.parsePDF(tempPdfPath);

      logger.info(`[ProductSyncService] Parsed ${parsedProducts.length} products from PDF`);

      // Stage 4: Apply delta and update DB
      progressCallback?.({
        stage: 'update',
        message: `Aggiornamento ${parsedProducts.length} articoli...`,
      });

      const { newProducts, updatedProducts } = await this.applyDelta(parsedProducts);

      // Stage 5: Cleanup
      progressCallback?.({
        stage: 'cleanup',
        message: 'Finalizzazione...',
      });

      if (tempPdfPath) {
        await fs.unlink(tempPdfPath);
        logger.info('[ProductSyncService] Temp PDF cleaned up', { tempPdfPath });
      }

      await BrowserPool.getInstance().releaseContext(
        'product-sync-service',
        true // success
      );

      const duration = Date.now() - startTime;

      logger.info('[ProductSyncService] Sync completed', {
        productsProcessed: parsedProducts.length,
        newProducts,
        updatedProducts,
        durationMs: duration,
      });

      return {
        productsProcessed: parsedProducts.length,
        newProducts,
        updatedProducts,
        duration,
      };
    } catch (error) {
      logger.error('[ProductSyncService] Sync failed', { error });

      // Cleanup on error
      if (tempPdfPath) {
        try {
          await fs.unlink(tempPdfPath);
        } catch (cleanupError) {
          logger.error('[ProductSyncService] Cleanup failed', { cleanupError });
        }
      }

      await BrowserPool.getInstance().releaseContext(
        'product-sync-service',
        false // error
      );

      throw error;
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Apply delta: insert new, update changed, skip unchanged
   */
  private async applyDelta(
    parsedProducts: any[]
  ): Promise<{ newProducts: number; updatedProducts: number }> {
    let newProducts = 0;
    let updatedProducts = 0;

    for (const parsed of parsedProducts) {
      const productData = this.mapPDFToProduct(parsed);
      const hash = this.computeHash(productData);

      const existing = this.db.getProductById(productData.id);

      if (!existing) {
        // New product
        this.db.upsertProducts([{ ...productData, hash, lastSync: Date.now() }]);
        newProducts++;
      } else if (existing.hash !== hash) {
        // Changed product
        this.db.upsertProducts([{ ...productData, hash, lastSync: Date.now() }]);
        updatedProducts++;
      }
      // else: unchanged, skip
    }

    logger.info('[ProductSyncService] Delta applied', { newProducts, updatedProducts });

    return { newProducts, updatedProducts };
  }

  /**
   * Map parsed PDF data to Product interface
   */
  private mapPDFToProduct(parsed: any): Omit<Product, 'hash' | 'lastSync'> {
    return {
      id: parsed.id_articolo,
      name: parsed.nome_articolo,
      description: parsed.descrizione,
      groupCode: parsed.gruppo_articolo,
      packageContent: parsed.contenuto_imballaggio,
      searchName: parsed.nome_ricerca,
      priceUnit: parsed.unita_prezzo,
      productGroupId: parsed.id_gruppo_prodotti,
      productGroupDescription: parsed.descrizione_gruppo_articolo,
      minQty: this.parseNumber(parsed.qta_minima),
      multipleQty: this.parseNumber(parsed.qta_multipli),
      maxQty: this.parseNumber(parsed.qta_massima),
      figure: parsed.figura,
      bulkArticleId: parsed.id_blocco_articolo,
      legPackage: parsed.pacco_gamba,
      size: parsed.grandezza,
      configurationId: parsed.id_configurazione,
      createdBy: parsed.creato_da,
      createdDate: parsed.data_creata,
      dataAreaId: parsed.dataareaid,
      defaultQty: parsed.qta_predefinita,
      displayProductNumber: parsed.visualizza_numero_prodotto,
      totalAbsoluteDiscount: parsed.sconto_assoluto_totale,
      productId: parsed.id_prodotto,
      lineDiscount: parsed.sconto_linea,
      modifiedBy: parsed.modificato_da,
      modifiedDatetime: parsed.datetime_modificato,
      orderableArticle: parsed.articolo_ordinabile,
      purchPrice: parsed.purch_price,
      pcsStandardConfigurationId: parsed.pcs_id_configurazione_standard,
      standardQty: parsed.qta_standard,
      stopped: parsed.fermato,
      unitId: parsed.id_unita,
      // Keep existing price/VAT fields (not overwritten by PDF)
      price: undefined,
      priceSource: null,
      priceUpdatedAt: undefined,
      vat: undefined,
      vatSource: null,
      vatUpdatedAt: undefined,
    };
  }

  /**
   * Compute MD5 hash of all product fields for delta detection
   */
  private computeHash(product: Partial<Product>): string {
    const fields = [
      product.id,
      product.name,
      product.description,
      product.groupCode,
      product.packageContent,
      product.searchName,
      product.priceUnit,
      product.productGroupId,
      product.productGroupDescription,
      product.minQty,
      product.multipleQty,
      product.maxQty,
      product.figure,
      product.bulkArticleId,
      product.legPackage,
      product.size,
      product.configurationId,
      product.createdBy,
      product.createdDate,
      product.dataAreaId,
      product.defaultQty,
      product.displayProductNumber,
      product.totalAbsoluteDiscount,
      product.productId,
      product.lineDiscount,
      product.modifiedBy,
      product.modifiedDatetime,
      product.orderableArticle,
      product.purchPrice,
      product.pcsStandardConfigurationId,
      product.standardQty,
      product.stopped,
      product.unitId,
    ].join('|');

    return createHash('md5').update(fields).digest('hex');
  }

  private parseNumber(value: string | undefined): number | undefined {
    if (!value) return undefined;
    const num = parseFloat(value.replace(',', '.'));
    return isNaN(num) ? undefined : num;
  }

  /**
   * Start automatic background sync
   */
  startAutoSync(intervalMinutes: number = 30): void {
    logger.info(`[ProductSyncService] Starting auto-sync every ${intervalMinutes} minutes`);

    // Initial sync after 5s
    setTimeout(() => {
      this.syncProducts().catch(error => {
        logger.error('[ProductSyncService] Initial sync failed', { error });
      });
    }, 5000);

    // Recurring sync
    this.syncInterval = setInterval(() => {
      if (!this.paused) {
        this.syncProducts().catch(error => {
          logger.error('[ProductSyncService] Auto-sync failed', { error });
        });
      }
    }, intervalMinutes * 60 * 1000);
  }

  /**
   * Stop automatic background sync
   */
  stopAutoSync(): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
      logger.info('[ProductSyncService] Auto-sync stopped');
    }
  }
}
```

**Key Changes:**
- Eliminated HTML scraping logic (~700 lines removed)
- Eliminated ImageDownloader dependency
- 5-stage sync flow (login, download, parse, update, cleanup)
- Hash-based delta detection
- Progress callbacks with Italian messages
- BrowserPool integration
- Temp file cleanup

**Acceptance Criteria:**
- Service refactored from ~1,000 lines to ~350 lines
- PDF-based sync replaces HTML scraping
- Hash-based delta detection working
- Progress callbacks emit 5 stages
- Temp file cleanup on success/error
- No image management code

**Commit:** `refactor(19-02): replace HTML scraping with PDF-based sync in ProductSyncService`

---

### Task 4: Create Test Scripts
**Duration:** 8min

Create manual test scripts following Phase 18-02 pattern.

**test-products-pdf-download.ts:**
```typescript
import { BrowserPool } from './browser-pool';
import { ArchibaldBot } from './archibald-bot';
import { logger } from './logger';
import { promises as fs } from 'fs';

async function testProductsPDFDownload() {
  logger.info('=== Products PDF Download Test ===');

  try {
    // Acquire context
    const context = await BrowserPool.getInstance().acquireContext(
      'test-products-download',
      'system'
    );

    const bot = new ArchibaldBot(context.page);

    // Download PDF
    const pdfPath = await bot.downloadProductsPDF('system');
    logger.info(`‚úÖ PDF downloaded: ${pdfPath}`);

    // Check file
    const stats = await fs.stat(pdfPath);
    logger.info(`‚úÖ PDF size: ${Math.round(stats.size / 1024)} KB`);

    // Cleanup
    await fs.unlink(pdfPath);
    logger.info('‚úÖ Temp file cleaned up');

    await BrowserPool.getInstance().releaseContext('test-products-download', true);

    logger.info('üéâ Test passed!');
    process.exit(0);
  } catch (error) {
    logger.error('‚ùå Test failed', { error });
    await BrowserPool.getInstance().releaseContext('test-products-download', false);
    process.exit(1);
  }
}

testProductsPDFDownload();
```

**test-products-full-sync.ts:**
```typescript
import { ProductSyncService } from './product-sync-service';
import { logger } from './logger';

async function testProductsFullSync() {
  logger.info('=== Products Full Sync Test ===');

  const service = ProductSyncService.getInstance();

  try {
    const result = await service.syncProducts((progress) => {
      logger.info(`[Progress] ${progress.stage}: ${progress.message}`);
    });

    logger.info('‚úÖ Sync successful:', result);
    logger.info('üéâ Test passed!');
    process.exit(0);
  } catch (error) {
    logger.error('‚ùå Test failed', { error });
    process.exit(1);
  }
}

testProductsFullSync();
```

**Acceptance Criteria:**
- PDF download test validates bot method
- Full sync test validates complete pipeline
- Tests follow Phase 18-02 pattern
- Exit codes 0/1 for pass/fail

**Commit:** `test(19-02): add manual test scripts for products PDF sync`

---

## Verification

### Manual Checkpoint

**Test 1: PDF Download**
```bash
cd archibald-web-app/backend
npm run build
node dist/test-products-pdf-download.js
```

**Expected:**
- ‚úÖ PDF downloaded to /tmp
- ‚úÖ File size ~2-3 MB
- ‚úÖ Temp file cleaned up
- üéâ Test passed!

**Test 2: Full Sync**
```bash
node dist/test-products-full-sync.js
```

**Expected:**
- [Progress] login: Connessione ad Archibald...
- [Progress] download: Scaricamento PDF articoli...
- [Progress] parse: Analisi PDF in corso...
- [Progress] update: Aggiornamento 4540 articoli...
- [Progress] cleanup: Finalizzazione...
- ‚úÖ Sync successful: { productsProcessed: 4540, newProducts: X, updatedProducts: Y, duration: <60000ms }
- üéâ Test passed!

**If tests fail:**
- Check bot login credentials
- Verify products page URL accessible
- Adjust export button selector if UI changed
- Increase timeouts if network slow

## Success Criteria

- [ ] downloadProductsPDF method added to ArchibaldBot
- [ ] Old ProductSyncService backed up
- [ ] ProductSyncService refactored to PDF-based sync (~350 lines)
- [ ] ImageDownloader dependency removed
- [ ] Hash-based delta detection working
- [ ] Progress callbacks emit 5 stages
- [ ] Test scripts created and documented
- [ ] Performance target <60s for ~4,540 products
- [ ] All commits atomic with proper messages

## Output

**Files Created:**
- `archibald-web-app/backend/src/test-products-pdf-download.ts`
- `archibald-web-app/backend/src/test-products-full-sync.ts`
- `archibald-web-app/backend/src/product-sync-service.OLD_HTML_SCRAPING.ts.backup`

**Files Modified:**
- `archibald-web-app/backend/src/archibald-bot.ts` (+80 lines)
- `archibald-web-app/backend/src/product-sync-service.ts` (replaced 1000+ lines with ~350 lines)

**Commits:** 4 atomic commits

**Next:** Plan 19-03 (Manual Sync UI & API Endpoint)
