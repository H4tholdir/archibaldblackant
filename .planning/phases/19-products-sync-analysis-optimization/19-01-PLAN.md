---
phase: 19-products-sync-analysis-optimization
plan: 01
title: PDF Parser Enhancement & Node.js Integration (Products)
subsystem: integration
complexity: medium
estimated_duration: 60min
tags: [python, pdf-parsing, node-js, products, 8-page-cycle]
---

# Plan 19-01: PDF Parser Enhancement & Node.js Integration (Products)

## Objective

Create Python PDF parser for products with 8-page cycle support (26+ business fields) and Node.js wrapper via child_process, reusing Phase 18 patterns.

## Execution Context

**Phase 18 Proven Patterns:**
- Python PDF parser with 8-page cycle handling
- Node.js wrapper via `child_process.spawn`
- Type-safe TypeScript interfaces matching Python dataclasses
- Health check endpoints for deployment verification

**User Requirements:**
- Extract ALL PDF fields from products (no image management)
- 8-page PDF structure with specific fields per page
- Performance target: Parse ~4,540 products in <18s
- URL: https://4.231.124.90/Archibald/INVENTTABLE_ListView/
- Button: "Esportare in PDF File"

**PDF Field Structure (26+ fields across 8 pages):**
- Pagina 1: ID ARTICOLO, NOME ARTICOLO, DESCRIZIONE
- Pagina 2: GRUPPO ARTICOLO, IMMAGINE (ignore), CONTENUTO DELL'IMBALLAGGIO, NOME DELLA RICERCA
- Pagina 3: UNITÀ DI PREZZO, ID GRUPPO DI PRODOTTI, DESCRIZIONE GRUPPO ARTICOLO, QTÀ MINIMA
- Pagina 4: QTÀ MULTIPLI, QTÀ MASSIMA, FIGURA, ID IN BLOCCO DELL'ARTICOLO, PACCO GAMBA
- Pagina 5: GRANDEZZA, ID DI CONFIGURAZIONE, CREATO DA, DATA CREATA, DATAAREAID
- Pagina 6: QTÀ PREDEFINITA, VISUALIZZA IL NUMERO DI PRODOTTO, SCONTO ASSOLUTO TOTALE, ID
- Pagina 7: SCONTO LINEA, MODIFICATO DA, DATETIME MODIFICATO, ARTICOLO ORDINABILE
- Pagina 8: PURCH PRICE, PCS ID DI CONFIGURAZIONE STANDARD, QTÀ STANDARD, FERMATO, ID UNITÀ

**Key Files:**
- Reference: `scripts/parse-clienti-pdf.py` (Phase 18 pattern)
- Reference: `archibald-web-app/backend/src/pdf-parser-service.ts`
- Target: `scripts/parse-products-pdf.py` (new)
- Target: `archibald-web-app/backend/src/pdf-parser-products-service.ts` (new)

## Context

**Dependencies:**
- Phase 18-01 complete (PDF parser pattern established)
- PyPDF2 library installed
- Python 3.x available

**Database Schema:**
@archibald-web-app/backend/src/product-db.ts

Current Product interface has many fields but needs update:
- Remove image-related fields (imageUrl, imageLocalPath, imageDownloadedAt)
- Add all PDF fields from 8 pages
- Ensure hash field for delta detection

## Tasks

### Task 1: Create Python PDF Parser for Products
**Duration:** 20min

Create `scripts/parse-products-pdf.py` based on `scripts/parse-clienti-pdf.py` pattern.

**Implementation:**
```python
import sys
import json
import re
from PyPDF2 import PdfReader
from typing import List, Dict, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class ParsedProduct:
    # Page 1 fields
    id_articolo: str
    nome_articolo: str
    descrizione: Optional[str] = None

    # Page 2 fields
    gruppo_articolo: Optional[str] = None
    # immagine: skip (user requirement)
    contenuto_imballaggio: Optional[str] = None
    nome_ricerca: Optional[str] = None

    # Page 3 fields
    unita_prezzo: Optional[str] = None
    id_gruppo_prodotti: Optional[str] = None
    descrizione_gruppo_articolo: Optional[str] = None
    qta_minima: Optional[str] = None

    # Page 4 fields
    qta_multipli: Optional[str] = None
    qta_massima: Optional[str] = None
    figura: Optional[str] = None
    id_blocco_articolo: Optional[str] = None
    pacco_gamba: Optional[str] = None

    # Page 5 fields
    grandezza: Optional[str] = None
    id_configurazione: Optional[str] = None
    creato_da: Optional[str] = None
    data_creata: Optional[str] = None
    dataareaid: Optional[str] = None

    # Page 6 fields
    qta_predefinita: Optional[str] = None
    visualizza_numero_prodotto: Optional[str] = None
    sconto_assoluto_totale: Optional[str] = None
    id_prodotto: Optional[str] = None  # duplicate of id_articolo?

    # Page 7 fields
    sconto_linea: Optional[str] = None
    modificato_da: Optional[str] = None
    datetime_modificato: Optional[str] = None
    articolo_ordinabile: Optional[str] = None

    # Page 8 fields
    purch_price: Optional[str] = None
    pcs_id_configurazione_standard: Optional[str] = None
    qta_standard: Optional[str] = None
    fermato: Optional[str] = None
    id_unita: Optional[str] = None

class ProductsPDFParser:
    """Parser for Archibald products PDF export with 8-page cycles"""

    PAGES_PER_CYCLE = 8

    def __init__(self, pdf_path: str):
        self.pdf_path = pdf_path
        self.reader = PdfReader(pdf_path)
        self.total_pages = len(self.reader.pages)

    def parse(self) -> List[ParsedProduct]:
        """Parse all products from PDF"""
        products = []
        num_cycles = self.total_pages // self.PAGES_PER_CYCLE

        for cycle_idx in range(num_cycles):
            base_page = cycle_idx * self.PAGES_PER_CYCLE

            # Parse each page in cycle
            page1 = self._parse_page_1(base_page)
            page2 = self._parse_page_2(base_page + 1)
            page3 = self._parse_page_3(base_page + 2)
            page4 = self._parse_page_4(base_page + 3)
            page5 = self._parse_page_5(base_page + 4)
            page6 = self._parse_page_6(base_page + 5)
            page7 = self._parse_page_7(base_page + 6)
            page8 = self._parse_page_8(base_page + 7)

            # Combine all pages into single product
            product = ParsedProduct(
                **page1,
                **page2,
                **page3,
                **page4,
                **page5,
                **page6,
                **page7,
                **page8
            )

            # Filter garbage records (ID = "0" or empty)
            if product.id_articolo and product.id_articolo.strip() != "0":
                products.append(product)

        return products

    def _parse_page_1(self, page_num: int) -> Dict[str, str]:
        """Parse page 1: ID ARTICOLO, NOME ARTICOLO, DESCRIZIONE"""
        text = self.reader.pages[page_num].extract_text()
        return {
            "id_articolo": self._extract_field(text, "ID ARTICOLO"),
            "nome_articolo": self._extract_field(text, "NOME ARTICOLO"),
            "descrizione": self._extract_field(text, "DESCRIZIONE"),
        }

    def _parse_page_2(self, page_num: int) -> Dict[str, str]:
        """Parse page 2: GRUPPO ARTICOLO, CONTENUTO DELL'IMBALLAGGIO, NOME DELLA RICERCA"""
        text = self.reader.pages[page_num].extract_text()
        return {
            "gruppo_articolo": self._extract_field(text, "GRUPPO ARTICOLO"),
            "contenuto_imballaggio": self._extract_field(text, "CONTENUTO DELL'IMBALLAGGIO"),
            "nome_ricerca": self._extract_field(text, "NOME DELLA RICERCA"),
        }

    # ... similar methods for pages 3-8

    def _extract_field(self, text: str, field_name: str) -> Optional[str]:
        """Extract field value from text after field name"""
        pattern = rf"{re.escape(field_name)}\s*[:\s]*(.*?)(?:\n|$)"
        match = re.search(pattern, text, re.IGNORECASE)
        if match:
            value = match.group(1).strip()
            return value if value else None
        return None

def main():
    if len(sys.argv) < 2:
        print(json.dumps({"error": "Missing PDF path argument"}))
        sys.exit(1)

    pdf_path = sys.argv[1]

    try:
        parser = ProductsPDFParser(pdf_path)
        products = parser.parse()

        # Output as JSON array
        output = [asdict(p) for p in products]
        print(json.dumps(output, ensure_ascii=False, indent=2))

    except FileNotFoundError:
        print(json.dumps({"error": f"PDF file not found: {pdf_path}"}))
        sys.exit(1)
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)

if __name__ == "__main__":
    main()
```

**Acceptance Criteria:**
- Python script parses all 8 pages per product
- Extracts all 26+ fields from PDF
- Filters garbage records (ID = "0")
- Outputs valid JSON array
- Handles ~4,540 products in <18s

**Commit:** `feat(19-01): create Python PDF parser for products with 8-page cycles`

---

### Task 2: Create Node.js Wrapper Service
**Duration:** 15min

Create `archibald-web-app/backend/src/pdf-parser-products-service.ts` following Phase 18 pattern.

**Implementation:**
```typescript
import { spawn } from 'child_process';
import { logger } from './logger';
import path from 'path';

export interface ParsedProduct {
  // Page 1
  id_articolo: string;
  nome_articolo: string;
  descrizione?: string;

  // Page 2
  gruppo_articolo?: string;
  contenuto_imballaggio?: string;
  nome_ricerca?: string;

  // Page 3
  unita_prezzo?: string;
  id_gruppo_prodotti?: string;
  descrizione_gruppo_articolo?: string;
  qta_minima?: string;

  // Page 4
  qta_multipli?: string;
  qta_massima?: string;
  figura?: string;
  id_blocco_articolo?: string;
  pacco_gamba?: string;

  // Page 5
  grandezza?: string;
  id_configurazione?: string;
  creato_da?: string;
  data_creata?: string;
  dataareaid?: string;

  // Page 6
  qta_predefinita?: string;
  visualizza_numero_prodotto?: string;
  sconto_assoluto_totale?: string;
  id_prodotto?: string;

  // Page 7
  sconto_linea?: string;
  modificato_da?: string;
  datetime_modificato?: string;
  articolo_ordinabile?: string;

  // Page 8
  purch_price?: string;
  pcs_id_configurazione_standard?: string;
  qta_standard?: string;
  fermato?: string;
  id_unita?: string;
}

export class PDFParserProductsService {
  private static instance: PDFParserProductsService;
  private parserPath: string;
  private timeout: number = 30000; // 30s for ~4,540 products

  private constructor() {
    this.parserPath = path.join(__dirname, '../../scripts/parse-products-pdf.py');
  }

  static getInstance(): PDFParserProductsService {
    if (!PDFParserProductsService.instance) {
      PDFParserProductsService.instance = new PDFParserProductsService();
    }
    return PDFParserProductsService.instance;
  }

  /**
   * Parse products PDF and return structured data
   */
  async parsePDF(pdfPath: string): Promise<ParsedProduct[]> {
    const startTime = Date.now();

    return new Promise((resolve, reject) => {
      const python = spawn('python3', [this.parserPath, pdfPath], {
        timeout: this.timeout,
        maxBuffer: 20 * 1024 * 1024, // 20MB for ~4,540 products
      });

      let stdout = '';
      let stderr = '';

      python.stdout.on('data', (data) => {
        stdout += data.toString();
      });

      python.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      python.on('close', (code) => {
        const duration = Date.now() - startTime;

        if (code === 0) {
          try {
            const products = JSON.parse(stdout) as ParsedProduct[];
            logger.info(`[PDFParserProductsService] Parsed ${products.length} products in ${duration}ms`);
            resolve(products);
          } catch (error) {
            logger.error('[PDFParserProductsService] JSON parse error', { error, stdout: stdout.slice(0, 500) });
            reject(new Error(`Failed to parse JSON output: ${error}`));
          }
        } else {
          logger.error('[PDFParserProductsService] Python script failed', { code, stderr, duration });
          reject(new Error(`Python script exited with code ${code}: ${stderr}`));
        }
      });

      python.on('error', (error) => {
        logger.error('[PDFParserProductsService] Spawn error', { error });
        reject(new Error(`Failed to spawn Python process: ${error.message}`));
      });
    });
  }

  /**
   * Health check: verify Python and PyPDF2 are available
   */
  async healthCheck(): Promise<{ healthy: boolean; pythonVersion?: string; pyPDF2Available?: boolean; error?: string }> {
    try {
      // Check Python version
      const pythonVersion = await new Promise<string>((resolve, reject) => {
        const python = spawn('python3', ['--version']);
        let output = '';
        python.stdout.on('data', (data) => output += data.toString());
        python.stderr.on('data', (data) => output += data.toString());
        python.on('close', (code) => {
          if (code === 0) resolve(output.trim());
          else reject(new Error(`Python check failed with code ${code}`));
        });
      });

      // Check PyPDF2
      const pyPDF2Check = await new Promise<boolean>((resolve) => {
        const python = spawn('python3', ['-c', 'import PyPDF2; print("OK")']);
        let output = '';
        python.stdout.on('data', (data) => output += data.toString());
        python.on('close', (code) => {
          resolve(code === 0 && output.includes('OK'));
        });
      });

      logger.info('[PDFParserProductsService] Health check passed', { pythonVersion, pyPDF2Available: pyPDF2Check });

      return {
        healthy: pyPDF2Check,
        pythonVersion,
        pyPDF2Available: pyPDF2Check,
      };
    } catch (error) {
      logger.error('[PDFParserProductsService] Health check failed', { error });
      return {
        healthy: false,
        error: error instanceof Error ? error.message : String(error),
      };
    }
  }
}
```

**Acceptance Criteria:**
- Node.js wrapper spawns Python script
- Parses large JSON output (20MB buffer)
- 30s timeout for ~4,540 products
- Type-safe ParsedProduct interface
- Health check endpoint for deployment

**Commit:** `feat(19-01): create Node.js wrapper for products PDF parser`

---

### Task 3: Add Health Check Endpoint
**Duration:** 5min

Add health check route in `archibald-web-app/backend/src/index.ts`.

**Implementation:**
```typescript
import { PDFParserProductsService } from './pdf-parser-products-service';

// ... existing code ...

// Health check for products PDF parser
app.get("/api/health/pdf-parser-products", async (req, res) => {
  try {
    const service = PDFParserProductsService.getInstance();
    const health = await service.healthCheck();

    if (health.healthy) {
      res.status(200).json(health);
    } else {
      res.status(503).json(health); // Service Unavailable
    }
  } catch (error) {
    logger.error("[Health] Products PDF parser check failed", { error });
    res.status(500).json({
      healthy: false,
      error: error instanceof Error ? error.message : String(error)
    });
  }
});
```

**Acceptance Criteria:**
- GET /api/health/pdf-parser-products returns 200/503/500
- Logs Python version and PyPDF2 status
- Matches Phase 18 pattern

**Commit:** `feat(19-01): add health check endpoint for products PDF parser`

---

### Task 4: Update Product Database Schema
**Duration:** 15min

Update `archibald-web-app/backend/src/product-db.ts`:
1. Remove image-related fields
2. Add all PDF fields from 8 pages
3. Ensure hash field exists

**Changes:**
```typescript
export interface Product {
  // ========== CORE FIELDS (Page 1) ==========
  id: string; // ID ARTICOLO
  name: string; // NOME ARTICOLO
  description?: string; // DESCRIZIONE

  // ========== PAGE 2 FIELDS ==========
  groupCode?: string; // GRUPPO ARTICOLO
  packageContent?: string; // CONTENUTO DELL'IMBALLAGGIO
  searchName?: string; // NOME DELLA RICERCA

  // ========== PAGE 3 FIELDS ==========
  priceUnit?: string; // UNITÀ DI PREZZO
  productGroupId?: string; // ID GRUPPO DI PRODOTTI
  productGroupDescription?: string; // DESCRIZIONE GRUPPO ARTICOLO
  minQty?: number; // QTÀ MINIMA

  // ========== PAGE 4 FIELDS ==========
  multipleQty?: number; // QTÀ MULTIPLI
  maxQty?: number; // QTÀ MASSIMA
  figure?: string; // FIGURA
  bulkArticleId?: string; // ID IN BLOCCO DELL'ARTICOLO
  legPackage?: string; // PACCO GAMBA

  // ========== PAGE 5 FIELDS ==========
  size?: string; // GRANDEZZA
  configurationId?: string; // ID DI CONFIGURAZIONE
  createdBy?: string; // CREATO DA
  createdDate?: string; // DATA CREATA
  dataAreaId?: string; // DATAAREAID

  // ========== PAGE 6 FIELDS ==========
  defaultQty?: string; // QTÀ PREDEFINITA
  displayProductNumber?: string; // VISUALIZZA IL NUMERO DI PRODOTTO
  totalAbsoluteDiscount?: string; // SCONTO ASSOLUTO TOTALE
  productId?: string; // ID (duplicate?)

  // ========== PAGE 7 FIELDS ==========
  lineDiscount?: string; // SCONTO LINEA
  modifiedBy?: string; // MODIFICATO DA
  modifiedDatetime?: string; // DATETIME MODIFICATO
  orderableArticle?: string; // ARTICOLO ORDINABILE

  // ========== PAGE 8 FIELDS ==========
  purchPrice?: string; // PURCH PRICE
  pcsStandardConfigurationId?: string; // PCS ID DI CONFIGURAZIONE STANDARD
  standardQty?: string; // QTÀ STANDARD
  stopped?: string; // FERMATO
  unitId?: string; // ID UNITÀ

  // ========== PRICE FIELDS (keep existing) ==========
  price?: number;
  priceSource?: "archibald" | "excel" | null;
  priceUpdatedAt?: number;
  vat?: number;
  vatSource?: "archibald" | "excel" | null;
  vatUpdatedAt?: number;

  // ========== SYSTEM FIELDS ==========
  hash: string; // MD5 hash for delta detection
  lastSync: number; // Unix timestamp
}
```

**Migration SQL:**
```sql
-- Remove image columns
ALTER TABLE products DROP COLUMN imageUrl;
ALTER TABLE products DROP COLUMN imageLocalPath;
ALTER TABLE products DROP COLUMN imageDownloadedAt;

-- Add new PDF fields (pages 4-8)
ALTER TABLE products ADD COLUMN figure TEXT;
ALTER TABLE products ADD COLUMN bulkArticleId TEXT;
ALTER TABLE products ADD COLUMN legPackage TEXT;
ALTER TABLE products ADD COLUMN size TEXT;
ALTER TABLE products ADD COLUMN configurationId TEXT;
ALTER TABLE products ADD COLUMN createdBy TEXT;
ALTER TABLE products ADD COLUMN createdDate TEXT;
ALTER TABLE products ADD COLUMN dataAreaId TEXT;
ALTER TABLE products ADD COLUMN defaultQty TEXT;
ALTER TABLE products ADD COLUMN displayProductNumber TEXT;
ALTER TABLE products ADD COLUMN totalAbsoluteDiscount TEXT;
ALTER TABLE products ADD COLUMN productId TEXT;
ALTER TABLE products ADD COLUMN lineDiscount TEXT;
ALTER TABLE products ADD COLUMN modifiedBy TEXT;
ALTER TABLE products ADD COLUMN modifiedDatetime TEXT;
ALTER TABLE products ADD COLUMN orderableArticle TEXT;
ALTER TABLE products ADD COLUMN purchPrice TEXT;
ALTER TABLE products ADD COLUMN pcsStandardConfigurationId TEXT;
ALTER TABLE products ADD COLUMN standardQty TEXT;
ALTER TABLE products ADD COLUMN stopped TEXT;
ALTER TABLE products ADD COLUMN unitId TEXT;
```

**Acceptance Criteria:**
- Schema includes all 26+ PDF fields
- Image fields removed
- Migration script created for VPS
- Hash field exists for delta detection

**Commit:** `feat(19-01): update product schema with PDF fields, remove images`

---

### Task 5: Create Test Script
**Duration:** 5min

Create `archibald-web-app/backend/src/test-products-pdf-parser.ts`.

**Implementation:**
```typescript
import { PDFParserProductsService } from './pdf-parser-products-service';
import { logger } from './logger';

async function testProductsPDFParser() {
  logger.info('=== Products PDF Parser Test ===');

  const service = PDFParserProductsService.getInstance();

  // 1. Health check
  logger.info('Running health check...');
  const health = await service.healthCheck();
  if (!health.healthy) {
    logger.error('Health check failed', health);
    process.exit(1);
  }
  logger.info('✓ Health check passed', health);

  // 2. Parse PDF
  const pdfPath = process.env.PRODUCTS_PDF_PATH || '/tmp/articoli-test.pdf';
  logger.info(`Parsing PDF: ${pdfPath}`);

  const startTime = Date.now();
  const products = await service.parsePDF(pdfPath);
  const duration = Date.now() - startTime;

  logger.info(`✓ Parsed ${products.length} products in ${duration}ms`);

  // 3. Validate results
  if (products.length < 4000 || products.length > 5000) {
    logger.warn(`Product count unexpected: ${products.length} (expected ~4,540)`);
  }

  // 4. Sample product
  const sample = products[0];
  logger.info('Sample product:', sample);

  // 5. Field coverage check
  const fields = Object.keys(sample);
  logger.info(`Fields per product: ${fields.length}`);

  logger.info('=== Test Complete ===');
}

testProductsPDFParser().catch((error) => {
  logger.error('Test failed', { error });
  process.exit(1);
});
```

**Acceptance Criteria:**
- Test script validates health check
- Parses test PDF
- Verifies product count (~4,540)
- Logs sample product for inspection
- Exit code 0 on success

**Commit:** `test(19-01): add test script for products PDF parser`

---

## Verification

### Manual Checkpoint

**Run test script:**
```bash
cd archibald-web-app/backend
npm run build
PRODUCTS_PDF_PATH=/path/to/test.pdf node dist/test-products-pdf-parser.js
```

**Expected output:**
- ✓ Health check passed (Python + PyPDF2)
- ✓ Parsed ~4,540 products in <18s
- ✓ Sample product shows all 26+ fields
- ✓ No errors

**If tests fail:**
- Verify PDF structure matches 8-page cycles
- Adjust field extraction patterns
- Increase timeout if needed

## Success Criteria

- [ ] Python parser extracts all 26+ fields from 8-page cycles
- [ ] Node.js wrapper handles large JSON output (20MB buffer)
- [ ] Health check endpoint returns 200/503/500
- [ ] Product schema updated with PDF fields, images removed
- [ ] Migration SQL script created
- [ ] Test script validates end-to-end flow
- [ ] ~4,540 products parsed in <18s
- [ ] All commits atomic with proper messages

## Output

**Files Created:**
- `scripts/parse-products-pdf.py` - Python PDF parser
- `archibald-web-app/backend/src/pdf-parser-products-service.ts` - Node wrapper
- `archibald-web-app/backend/src/test-products-pdf-parser.ts` - Test script
- `archibald-web-app/backend/src/migrations/019-products-pdf-fields.sql` - Migration

**Files Modified:**
- `archibald-web-app/backend/src/product-db.ts` - Schema update
- `archibald-web-app/backend/src/index.ts` - Health check endpoint

**Commits:** 5 atomic commits

**Next:** Plan 19-02 (PDF Download Bot Flow)
