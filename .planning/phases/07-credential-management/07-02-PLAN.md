# Phase 7 Plan 2: IndexedDB Credential Store with Encryption

<objective>
Implement secure credential storage using IndexedDB and Web Crypto API encryption.

**Purpose:** Create the foundational credential storage layer with encryption/decryption capabilities. This is the core security implementation that all other Phase 7 features depend on.

**Output:** Fully functional credential storage service with encrypted persistence, ready for UI integration.
</objective>

<execution_context>
@.planning/phases/07-credential-management/07-RESEARCH.md (encryption strategy from Plan 07-01)
@.planning/phases/07-credential-management/07-CONTEXT.md (user vision)
@archibald-web-app/frontend/src/hooks/useAuth.ts (current auth)
@archibald-web-app/frontend/src/api/auth.ts (current auth API)
@~/.claude/get-shit-done/references/tdd.md (TDD patterns)
</execution_context>

<context>
**Current State:**
- JWT stored in localStorage (key: 'archibald_jwt')
- No credential persistence (user enters password every login)
- useAuth hook manages auth state

**Plan 07-01 Output:**
- Encryption strategy: AES-GCM with PBKDF2 key derivation
- IndexedDB schema for encrypted credentials
- Security patterns (salt, IV, key derivation)

**Implementation Goals:**
1. IndexedDB database for credential storage (database name: 'ArchibaldCredentials')
2. Credential encryption/decryption using Web Crypto API
3. Key derivation from PIN using PBKDF2 (100k+ iterations)
4. Secure storage: encrypted credentials + IV + salt per user
5. No plaintext credentials in storage or memory (clear after use)

**Storage Schema (IndexedDB):**
```typescript
interface StoredCredential {
  userId: string;           // Primary key
  encryptedData: ArrayBuffer;  // Encrypted {username, password}
  iv: Uint8Array;          // Initialization Vector (random per encryption)
  salt: Uint8Array;        // Salt for PBKDF2 (random per user)
  createdAt: number;       // Timestamp
  lastUsedAt: number;      // Track usage
}
```

**API Design:**
```typescript
class CredentialStore {
  // Initialize IndexedDB
  async initialize(): Promise<void>

  // Check if credentials exist for user
  async hasCredentials(userId: string): Promise<boolean>

  // Store encrypted credentials (called after "Ricorda credenziali" checkbox)
  async storeCredentials(userId: string, username: string, password: string, pin: string): Promise<void>

  // Retrieve and decrypt credentials (called when unlocking with PIN)
  async getCredentials(userId: string, pin: string): Promise<{username: string; password: string} | null>

  // Delete credentials (called on "Dimentica credenziali" or PIN recovery)
  async deleteCredentials(userId: string): Promise<void>

  // Update last used timestamp
  async touchCredentials(userId: string): Promise<void>
}
```

**Security Requirements:**
- PBKDF2 iterations: 100,000 (balance security vs UX on mobile)
- AES-GCM key length: 256 bits
- Random IV per encryption (crypto.getRandomValues)
- Random salt per user (crypto.getRandomValues)
- Clear sensitive data from memory after use
</context>

<tasks>

<task id="1" type="auto">
<files>
- archibald-web-app/frontend/src/services/credential-store.ts (NEW)
- archibald-web-app/frontend/src/services/credential-store.spec.ts (NEW - TDD)
</files>

<action>
**TDD Step 1: RED - Write failing tests first**

Create test file: `archibald-web-app/frontend/src/services/credential-store.spec.ts`

Test cases:
```typescript
describe('CredentialStore', () => {
  describe('initialize', () => {
    test('creates IndexedDB database successfully', async () => {
      // Test IndexedDB creation
    });
  });

  describe('hasCredentials', () => {
    test('returns false when no credentials stored', async () => {});
    test('returns true when credentials exist for userId', async () => {});
  });

  describe('storeCredentials', () => {
    test('encrypts and stores credentials with valid PIN', async () => {
      // Store, then verify encrypted data exists in IndexedDB
    });

    test('generates unique salt per user', async () => {
      // Store for 2 users, verify different salts
    });

    test('generates unique IV per encryption', async () => {
      // Store twice, verify different IVs
    });
  });

  describe('getCredentials', () => {
    test('decrypts credentials with correct PIN', async () => {
      const store = new CredentialStore();
      await store.storeCredentials('user1', 'testuser', 'testpass', '123456');

      const creds = await store.getCredentials('user1', '123456');
      expect(creds).toEqual({ username: 'testuser', password: 'testpass' });
    });

    test('returns null with incorrect PIN', async () => {
      await store.storeCredentials('user1', 'testuser', 'testpass', '123456');

      const creds = await store.getCredentials('user1', '999999');
      expect(creds).toBeNull();
    });

    test('returns null for non-existent userId', async () => {});
  });

  describe('deleteCredentials', () => {
    test('removes credentials from storage', async () => {
      await store.storeCredentials('user1', 'testuser', 'testpass', '123456');
      await store.deleteCredentials('user1');

      const has = await store.hasCredentials('user1');
      expect(has).toBe(false);
    });
  });
});
```

Run tests: `npm run test:unit` (should FAIL - no implementation yet)
</action>

<verify>
- [ ] Test file created at `archibald-web-app/frontend/src/services/credential-store.spec.ts`
- [ ] Tests cover: initialize, hasCredentials, storeCredentials, getCredentials, deleteCredentials
- [ ] Tests verify security requirements (unique salt, unique IV, correct PIN only)
- [ ] npm run test:unit executed (all tests FAIL as expected in RED phase)
</verify>

<done>
TDD RED phase complete. Tests written and failing. Ready for GREEN phase (implementation).
</done>
</task>

<task id="2" type="auto">
<files>
- archibald-web-app/frontend/src/services/credential-store.ts (NEW)
</files>

<action>
**TDD Step 2: GREEN - Implement to pass tests**

Create implementation file: `archibald-web-app/frontend/src/services/credential-store.ts`

Implementation outline:

```typescript
interface StoredCredential {
  userId: string;
  encryptedData: ArrayBuffer;
  iv: Uint8Array;
  salt: Uint8Array;
  createdAt: number;
  lastUsedAt: number;
}

interface DecryptedCredentials {
  username: string;
  password: string;
}

export class CredentialStore {
  private dbName = 'ArchibaldCredentials';
  private storeName = 'credentials';
  private db: IDBDatabase | null = null;

  async initialize(): Promise<void> {
    // Open IndexedDB, create object store with userId as key
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          db.createObjectStore(this.storeName, { keyPath: 'userId' });
        }
      };
    });
  }

  async hasCredentials(userId: string): Promise<boolean> {
    // Query IndexedDB for userId
    const stored = await this.getStoredCredential(userId);
    return stored !== null;
  }

  async storeCredentials(
    userId: string,
    username: string,
    password: string,
    pin: string
  ): Promise<void> {
    // 1. Generate random salt (16 bytes)
    const salt = crypto.getRandomValues(new Uint8Array(16));

    // 2. Derive key from PIN using PBKDF2
    const key = await this.deriveKeyFromPin(pin, salt);

    // 3. Generate random IV (12 bytes for AES-GCM)
    const iv = crypto.getRandomValues(new Uint8Array(12));

    // 4. Encrypt credentials as JSON
    const plaintext = JSON.stringify({ username, password });
    const encoder = new TextEncoder();
    const data = encoder.encode(plaintext);

    const encryptedData = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv },
      key,
      data
    );

    // 5. Store in IndexedDB
    const stored: StoredCredential = {
      userId,
      encryptedData,
      iv,
      salt,
      createdAt: Date.now(),
      lastUsedAt: Date.now(),
    };

    await this.putStoredCredential(stored);

    // 6. Clear sensitive data from memory
    // (JavaScript GC will handle this, but signal intent)
  }

  async getCredentials(
    userId: string,
    pin: string
  ): Promise<DecryptedCredentials | null> {
    // 1. Fetch from IndexedDB
    const stored = await this.getStoredCredential(userId);
    if (!stored) return null;

    try {
      // 2. Derive key from PIN with stored salt
      const key = await this.deriveKeyFromPin(pin, stored.salt);

      // 3. Decrypt
      const decryptedData = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: stored.iv },
        key,
        stored.encryptedData
      );

      // 4. Parse JSON
      const decoder = new TextDecoder();
      const plaintext = decoder.decode(decryptedData);
      const credentials: DecryptedCredentials = JSON.parse(plaintext);

      // 5. Update lastUsedAt
      await this.touchCredentials(userId);

      return credentials;
    } catch (error) {
      // Decryption failed (wrong PIN or corrupted data)
      return null;
    }
  }

  async deleteCredentials(userId: string): Promise<void> {
    // Remove from IndexedDB
    if (!this.db) throw new Error('CredentialStore not initialized');

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const request = store.delete(userId);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async touchCredentials(userId: string): Promise<void> {
    const stored = await this.getStoredCredential(userId);
    if (stored) {
      stored.lastUsedAt = Date.now();
      await this.putStoredCredential(stored);
    }
  }

  // Private helper: derive encryption key from PIN
  private async deriveKeyFromPin(
    pin: string,
    salt: Uint8Array
  ): Promise<CryptoKey> {
    const encoder = new TextEncoder();
    const pinData = encoder.encode(pin);

    // Import PIN as raw key material
    const keyMaterial = await crypto.subtle.importKey(
      'raw',
      pinData,
      'PBKDF2',
      false,
      ['deriveKey']
    );

    // Derive AES-GCM key using PBKDF2
    const key = await crypto.subtle.deriveKey(
      {
        name: 'PBKDF2',
        salt,
        iterations: 100000, // 100k iterations (security vs UX)
        hash: 'SHA-256',
      },
      keyMaterial,
      { name: 'AES-GCM', length: 256 },
      false, // not extractable
      ['encrypt', 'decrypt']
    );

    return key;
  }

  // Private helper: get stored credential from IndexedDB
  private async getStoredCredential(userId: string): Promise<StoredCredential | null> {
    if (!this.db) throw new Error('CredentialStore not initialized');

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(this.storeName, 'readonly');
      const store = tx.objectStore(this.storeName);
      const request = store.get(userId);

      request.onsuccess = () => resolve(request.result || null);
      request.onerror = () => reject(request.error);
    });
  }

  // Private helper: put stored credential to IndexedDB
  private async putStoredCredential(stored: StoredCredential): Promise<void> {
    if (!this.db) throw new Error('CredentialStore not initialized');

    return new Promise((resolve, reject) => {
      const tx = this.db!.transaction(this.storeName, 'readwrite');
      const store = tx.objectStore(this.storeName);
      const request = store.put(stored);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }
}

// Singleton instance
let instance: CredentialStore | null = null;

export function getCredentialStore(): CredentialStore {
  if (!instance) {
    instance = new CredentialStore();
  }
  return instance;
}
```

Run tests: `npm run test:unit` (should PASS now)
</action>

<verify>
- [ ] Implementation file created at `archibald-web-app/frontend/src/services/credential-store.ts`
- [ ] Class implements all methods: initialize, hasCredentials, storeCredentials, getCredentials, deleteCredentials, touchCredentials
- [ ] Uses Web Crypto API (crypto.subtle) for encryption/decryption
- [ ] PBKDF2 key derivation with 100k iterations
- [ ] Random salt per user, random IV per encryption
- [ ] IndexedDB integration with proper error handling
- [ ] npm run test:unit executed (all tests PASS)
</verify>

<done>
TDD GREEN phase complete. Implementation passes all tests. Credential store fully functional with encryption.
</done>
</task>

<task id="3" type="checkpoint:human-verify">
<files>
- Browser DevTools → Application → IndexedDB
- credential-store.spec.ts test results
</files>

<action>
**Manual Verification Checkpoint**

User should verify:

1. **Run Unit Tests:**
   ```bash
   cd archibald-web-app/frontend
   npm run test:unit -- credential-store.spec.ts
   ```

   ✅ All tests pass (green)

2. **Inspect IndexedDB in Browser DevTools:**
   - Open browser DevTools → Application tab → Storage → IndexedDB
   - Find database: `ArchibaldCredentials`
   - Find object store: `credentials`
   - Add manual test: Open browser console and run:
   ```javascript
   import { getCredentialStore } from './src/services/credential-store';
   const store = getCredentialStore();
   await store.initialize();
   await store.storeCredentials('test-user-id', 'myusername', 'mypassword', '123456');
   console.log('Stored:', await store.hasCredentials('test-user-id')); // true
   console.log('Retrieved:', await store.getCredentials('test-user-id', '123456'));
   // Should show { username: 'myusername', password: 'mypassword' }
   console.log('Wrong PIN:', await store.getCredentials('test-user-id', '999999'));
   // Should show null
   ```

   - Inspect IndexedDB entry:
     - `encryptedData` should be ArrayBuffer (not readable)
     - `iv` should be Uint8Array (12 bytes)
     - `salt` should be Uint8Array (16 bytes)
     - Cannot see plaintext username/password anywhere

3. **Security Verification:**
   - Copy `encryptedData` from IndexedDB
   - Try to decode as string → should be gibberish
   - Verify salt and IV are different for different users
   - Verify credentials decrypt ONLY with correct PIN

4. **Error Handling:**
   - Try `getCredentials` with wrong PIN → should return null (not throw)
   - Try `getCredentials` for non-existent user → should return null
   - Try operations before `initialize()` → should throw clear error

**Expected Outcome:**
✅ All tests pass
✅ IndexedDB shows encrypted data (not readable)
✅ Credentials decrypt only with correct PIN
✅ Error handling works gracefully

User confirms: "verified" or reports issues
</action>

<verify>
User confirms:
- [ ] Unit tests pass
- [ ] IndexedDB contains encrypted credentials (not readable plaintext)
- [ ] Credentials decrypt with correct PIN
- [ ] Wrong PIN returns null (no error)
- [ ] Security requirements met (salt, IV, encrypted data)
</verify>

<done>
Manual verification complete. CredentialStore ready for UI integration in Plan 07-03.
</done>
</task>

</tasks>

<verification>
**Success Criteria:**
- [x] CredentialStore class implemented with all methods
- [x] Web Crypto API used (AES-GCM encryption, PBKDF2 key derivation)
- [x] IndexedDB integration functional
- [x] Unit tests pass (TDD GREEN phase)
- [x] Manual verification confirms encryption works
- [x] Security requirements met:
  - No plaintext credentials in storage
  - Unique salt per user
  - Unique IV per encryption
  - Credentials decrypt only with correct PIN
  - 100k PBKDF2 iterations

**Quality Gates:**
- npm run test:unit passes (all tests green)
- IndexedDB inspection shows encrypted data (not readable)
- Decryption works only with correct PIN
- Error handling graceful (wrong PIN → null, not throw)
</verification>

<success_criteria>
Phase 7 Plan 2 succeeds when:

1. **Implementation Complete:**
   - CredentialStore class exists with all methods
   - Uses Web Crypto API (crypto.subtle) for encryption
   - IndexedDB stores encrypted credentials + IV + salt

2. **Tests Pass:**
   - Unit tests written (TDD RED phase)
   - Implementation passes all tests (TDD GREEN phase)
   - Test coverage: initialize, store, get, delete, hasCredentials

3. **Security Verified:**
   - Manual inspection shows encrypted data in IndexedDB
   - Plaintext credentials NOT visible anywhere
   - Credentials decrypt ONLY with correct PIN
   - Salt and IV unique per user/encryption

4. **Ready for Integration:**
   - API clear and documented (storeCredentials, getCredentials, etc.)
   - Error handling works (wrong PIN → null)
   - Next plan can integrate with useAuth hook

</success_criteria>

<output>
**Deliverables:**
1. `archibald-web-app/frontend/src/services/credential-store.ts` - Encryption service
2. `archibald-web-app/frontend/src/services/credential-store.spec.ts` - Unit tests
3. IndexedDB database 'ArchibaldCredentials' operational
4. Security verified: encrypted storage, PIN-protected access

**Key Decisions:**
- PBKDF2 iterations: 100,000 (balance security vs UX)
- AES-GCM 256-bit encryption
- IndexedDB for persistent storage
- Singleton pattern via getCredentialStore()

**Security Guarantees:**
- No plaintext credentials in storage
- Key never stored (derived from PIN each time)
- Random salt per user, random IV per encryption
- Decryption fails gracefully with wrong PIN

**Ready for:** Plan 07-03 (PIN/biometric unlock UI)
</output>

---

**Phase:** 07-credential-management
**Plan:** 02 of 06
**Type:** Implementation (TDD)
**Estimated Duration:** 60-75 min
