---
phase: 05-websocket-realtime-events
plan: 01
type: execute
---

<objective>
Emit PENDING_CREATED, PENDING_UPDATED, and PENDING_DELETED WebSocket events from pending-orders routes so that all connected devices receive real-time updates when orders are created, modified, or deleted.

Purpose: Enable multi-device sync for pending orders — the most critical real-time feature for agents working across devices.
Output: Pending order CRUD operations broadcast WebSocket events to all connected clients for the same user.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-websocket-realtime-events/05-RESEARCH.md
@.planning/phases/05-websocket-realtime-events/05-CONTEXT.md

# Key files:
@archibald-web-app/backend/src/routes/pending-orders.ts
@archibald-web-app/backend/src/server.ts
@archibald-web-app/backend/src/realtime/websocket-server.ts
@archibald-web-app/backend/src/operations/operation-processor.ts

**Tech stack available:** ws (WebSocket server), Express, PostgreSQL, BullMQ
**Established patterns:** Broadcast injection via deps (see customer-interactive.ts as reference pattern)

**Constraining decisions:**
- [Phase 2]: BroadcastFn type defined as `(userId: string, event: Record<string, unknown>) => void`
- [Phase 3]: broadcast already wired into createApp deps and operation-processor
- [Research]: WebSocketMessage format is `{ type: string, payload: unknown, timestamp: string }` — customer-interactive.ts follows this format

**IMPORTANT format note:** customer-interactive.ts uses `{ type: 'EVENT_NAME', payload: {...}, timestamp }` (WebSocketMessage format). operation-processor.ts uses `{ event: 'EVENT_NAME', jobId, type: operationType, ... }` (flat format). New events in this plan MUST use the WebSocketMessage format `{ type, payload, timestamp }` for consistency with the frontend routing which uses the `type` field.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Inject broadcast into pending-orders router and emit CRUD events</name>
  <files>archibald-web-app/backend/src/routes/pending-orders.ts, archibald-web-app/backend/src/server.ts</files>
  <action>
1. In `routes/pending-orders.ts`:
   - Add `broadcast: (userId: string, msg: { type: string; payload: unknown; timestamp: string }) => void` to `PendingOrdersRouterDeps` type
   - In POST `/` handler (batch upsert): after `res.json(result)`, emit one aggregated event per action type. The upsert returns results with `action` field ('created' or 'updated'). Group by action:
     - For created items: `broadcast(userId, { type: 'PENDING_CREATED', payload: { orderIds: createdIds, count: createdIds.length }, timestamp: new Date().toISOString() })`
     - For updated items: `broadcast(userId, { type: 'PENDING_UPDATED', payload: { orderIds: updatedIds, count: updatedIds.length }, timestamp: new Date().toISOString() })`
   - In DELETE `/:id` handler: after successful delete response, emit: `broadcast(userId, { type: 'PENDING_DELETED', payload: { orderId: req.params.id }, timestamp: new Date().toISOString() })`
   - Emit events AFTER res.json() to ensure DB write is confirmed before notification (never emit before DB confirmation)

2. In `server.ts`:
   - In the `createPendingOrdersRouter({...})` call (~line 198-202), add `broadcast: broadcastFn` to the deps object (broadcastFn is already available in createApp via `deps.broadcast ?? (() => {})`)

Avoid: Emitting one event per order in a batch upsert — this causes event flooding. Use aggregated events with arrays of IDs. The frontend already does refetch on these events (usePendingSync), so the event just needs to signal "something changed", not carry full order data.
  </action>
  <verify>npm run build --prefix archibald-web-app/backend (TypeScript compiles without errors)</verify>
  <done>PendingOrdersRouterDeps includes broadcast, POST emits PENDING_CREATED/UPDATED, DELETE emits PENDING_DELETED, server.ts wires broadcast, build passes</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for pending order event emission</name>
  <files>archibald-web-app/backend/src/routes/pending-orders.spec.ts</files>
  <action>
Add tests to the existing pending-orders spec file (create if not exists). Test:

1. **POST batch upsert emits PENDING_CREATED for new orders**: Mock broadcast, call POST with new orders, verify broadcast called with `{ type: 'PENDING_CREATED', payload: { orderIds: [...], count: N }, timestamp: expect.any(String) }`
2. **POST batch upsert emits PENDING_UPDATED for existing orders**: Mock upsertPendingOrder to return `action: 'updated'`, verify broadcast called with PENDING_UPDATED
3. **DELETE emits PENDING_DELETED**: Call DELETE with valid ID, verify broadcast called with `{ type: 'PENDING_DELETED', payload: { orderId: 'test-id' }, timestamp: expect.any(String) }`
4. **DELETE 404 does NOT emit event**: Call DELETE with non-existent ID, verify broadcast NOT called
5. **Broadcast failure does not affect HTTP response**: Mock broadcast to throw, verify POST still returns 200 (broadcast errors should not break the route — wrap in try/catch if needed)

Use the same test pattern as existing route specs. Mock deps via the factory function.
  </action>
  <verify>npm test --prefix archibald-web-app/backend -- --run pending-orders</verify>
  <done>All 5 test cases pass, broadcast is verified for create/update/delete, error isolation confirmed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix archibald-web-app/backend` succeeds
- [ ] `npm test --prefix archibald-web-app/backend` passes all tests
- [ ] Broadcast called with correct WebSocketMessage format `{ type, payload, timestamp }`
- [ ] Events emitted AFTER res.json() (not before DB confirmation)
- [ ] Batch operations emit aggregated events (not one per order)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript errors
- Pending order CRUD operations emit correct WebSocket events
- Event format consistent with WebSocketMessage `{ type, payload, timestamp }`
</success_criteria>

<output>
After completion, create `.planning/phases/05-websocket-realtime-events/05-01-SUMMARY.md`
</output>
