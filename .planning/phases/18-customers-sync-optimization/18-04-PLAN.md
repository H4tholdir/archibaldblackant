---
phase: 18-customers-sync-optimization
plan: 04
type: execute
---

<objective>
Add API endpoints and UI controls for granular manual sync (full, incremental, single customer).

Purpose: Give users explicit control over sync strategy and enable single-customer refresh for debugging/testing.
Output: Three API endpoints for sync granularity + frontend UI controls with sync mode selection.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/frontend/src/components/SyncButton.tsx

**Tech stack available:**
- Express.js REST API
- JWT authentication
- React 19 with hooks
- Inline styles (Phase 10-06 pattern)

**Existing sync endpoints:**
- POST /api/sync/customers (currently triggers full sync)
- Need to add: /full, /incremental, /:customerId variants

**Frontend sync UI:**
- SyncButton.tsx component for manual sync
- Currently simple button, needs dropdown for mode selection

**New endpoints required:**
1. POST /api/sync/customers/full - Force full sync
2. POST /api/sync/customers/incremental - Force incremental sync
3. POST /api/sync/customers/:customerId - Sync single customer by ID

**UI requirements:**
- Dropdown button with 3 options: "Sync Completo", "Sync Incrementale", "Sync Auto"
- Show sync mode in progress messages
- Display sync statistics (pages scraped, customers updated)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add granular sync API endpoints to backend</name>
  <files>
    archibald-web-app/backend/src/index.ts
  </files>
  <action>
    Add three new sync endpoints for granular control:

    1. POST /api/sync/customers/full (after existing /api/sync/customers endpoint):
    ```typescript
    // Force full customer sync - POST /api/sync/customers/full
    app.post(
      '/api/sync/customers/full',
      authenticateJWT,
      async (req: AuthRequest, res: Response<ApiResponse>) => {
        try {
          logger.info('Force full customer sync requested', { userId: req.userId });

          // Non-blocking: trigger sync in background
          syncService.forceFullSync().catch((error) => {
            logger.error('Error in force full customer sync', { error, userId: req.userId });
          });

          res.json({
            success: true,
            data: null,
            message: 'Sincronizzazione completa clienti avviata in background'
          });
        } catch (error) {
          logger.error('Error starting force full customer sync', { error, userId: req.userId });

          res.status(500).json({
            success: false,
            data: null,
            message: error instanceof Error ? error.message : 'Errore avvio sync completo'
          });
        }
      }
    );
    ```

    2. POST /api/sync/customers/incremental:
    ```typescript
    // Force incremental customer sync - POST /api/sync/customers/incremental
    app.post(
      '/api/sync/customers/incremental',
      authenticateJWT,
      async (req: AuthRequest, res: Response<ApiResponse>) => {
        try {
          logger.info('Force incremental customer sync requested', { userId: req.userId });

          // Non-blocking: trigger sync in background
          syncService.forceIncrementalSync().catch((error) => {
            logger.error('Error in force incremental customer sync', { error, userId: req.userId });
          });

          res.json({
            success: true,
            data: null,
            message: 'Sincronizzazione incrementale clienti avviata (prime 3 pagine)'
          });
        } catch (error) {
          logger.error('Error starting force incremental customer sync', { error, userId: req.userId });

          res.status(500).json({
            success: false,
            data: null,
            message: error instanceof Error ? error.message : 'Errore avvio sync incrementale'
          });
        }
      }
    );
    ```

    3. POST /api/sync/customers/:customerId (single customer refresh):
    ```typescript
    // Sync single customer by ID - POST /api/sync/customers/:customerId
    app.post(
      '/api/sync/customers/:customerId',
      authenticateJWT,
      async (req: AuthRequest, res: Response<ApiResponse>) => {
        try {
          const { customerId } = req.params;

          logger.info('Single customer sync requested', { userId: req.userId, customerId });

          // TODO: Implement syncSingleCustomer method in CustomerSyncService
          // For now, return not implemented
          res.status(501).json({
            success: false,
            data: null,
            message: 'Sync singolo cliente non ancora implementato (Phase 18-05)'
          });
        } catch (error) {
          logger.error('Error syncing single customer', { error, userId: req.userId });

          res.status(500).json({
            success: false,
            data: null,
            message: error instanceof Error ? error.message : 'Errore sync singolo cliente'
          });
        }
      }
    );
    ```

    Note: Single customer sync implementation deferred to Phase 18-05 (requires separate scraping logic).

    Why separate endpoints: RESTful API design, explicit control over sync strategy, easier to monitor/log different sync types.
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Start backend
    2. Test POST /api/sync/customers/full: verify full sync starts
    3. Test POST /api/sync/customers/incremental: verify incremental sync starts
    4. Test POST /api/sync/customers/:customerId: verify 501 Not Implemented response
    5. Check logs show correct sync mode
  </verify>
  <done>
    Three granular sync endpoints added:
    - POST /api/sync/customers/full (force full sync)
    - POST /api/sync/customers/incremental (force incremental, 3 pages)
    - POST /api/sync/customers/:customerId (placeholder, returns 501)
    All endpoints require JWT authentication.
    Non-blocking background sync execution.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update SyncButton component with dropdown mode selection</name>
  <files>
    archibald-web-app/frontend/src/components/SyncButton.tsx
  </files>
  <action>
    Update SyncButton.tsx to support sync mode selection dropdown:

    1. Add state for dropdown visibility and selected mode:
    ```typescript
    const [dropdownOpen, setDropdownOpen] = useState(false);
    const [selectedMode, setSelectedMode] = useState<'auto' | 'full' | 'incremental'>('auto');
    ```

    2. Replace simple button with dropdown button group:
    ```typescript
    return (
      <div style={{ position: 'relative', display: 'inline-block' }}>
        {/* Main sync button */}
        <button
          onClick={handleSync}
          disabled={syncing}
          style={{
            padding: '10px 20px',
            background: syncing ? '#95a5a6' : '#3498db',
            color: 'white',
            border: 'none',
            borderRadius: '5px 0 0 5px',
            cursor: syncing ? 'not-allowed' : 'pointer',
            fontSize: '14px',
            fontWeight: 'bold'
          }}
        >
          {syncing ? `Sincronizzazione ${syncType}...` : `Sincronizza ${syncType}`}
        </button>

        {/* Dropdown toggle */}
        <button
          onClick={() => setDropdownOpen(!dropdownOpen)}
          disabled={syncing}
          style={{
            padding: '10px',
            background: syncing ? '#95a5a6' : '#2980b9',
            color: 'white',
            border: 'none',
            borderLeft: '1px solid white',
            borderRadius: '0 5px 5px 0',
            cursor: syncing ? 'not-allowed' : 'pointer',
            fontSize: '14px'
          }}
        >
          â–¼
        </button>

        {/* Dropdown menu */}
        {dropdownOpen && !syncing && (
          <div style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            background: 'white',
            border: '1px solid #ddd',
            borderRadius: '5px',
            marginTop: '5px',
            boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
            zIndex: 1000,
            minWidth: '200px'
          }}>
            <button
              onClick={() => {
                setSelectedMode('auto');
                setDropdownOpen(false);
              }}
              style={{
                display: 'block',
                width: '100%',
                padding: '10px 15px',
                background: selectedMode === 'auto' ? '#ecf0f1' : 'white',
                border: 'none',
                textAlign: 'left',
                cursor: 'pointer',
                fontSize: '14px',
                borderRadius: '5px 5px 0 0'
              }}
            >
              ðŸ¤– Auto (consigliato)
            </button>
            <button
              onClick={() => {
                setSelectedMode('full');
                setDropdownOpen(false);
              }}
              style={{
                display: 'block',
                width: '100%',
                padding: '10px 15px',
                background: selectedMode === 'full' ? '#ecf0f1' : 'white',
                border: 'none',
                borderTop: '1px solid #ddd',
                textAlign: 'left',
                cursor: 'pointer',
                fontSize: '14px'
              }}
            >
              ðŸ”„ Sync Completo
            </button>
            <button
              onClick={() => {
                setSelectedMode('incremental');
                setDropdownOpen(false);
              }}
              style={{
                display: 'block',
                width: '100%',
                padding: '10px 15px',
                background: selectedMode === 'incremental' ? '#ecf0f1' : 'white',
                border: 'none',
                borderTop: '1px solid #ddd',
                textAlign: 'left',
                cursor: 'pointer',
                fontSize: '14px',
                borderRadius: '0 0 5px 5px'
              }}
            >
              âš¡ Sync Incrementale (veloce)
            </button>
          </div>
        )}
      </div>
    );
    ```

    3. Update handleSync to use selected mode:
    ```typescript
    const handleSync = async () => {
      setSyncing(true);

      try {
        const token = localStorage.getItem('authToken');
        if (!token) {
          throw new Error('Token non trovato');
        }

        // Determine endpoint based on selected mode
        const endpoint = selectedMode === 'full'
          ? 'http://localhost:3000/api/sync/customers/full'
          : selectedMode === 'incremental'
          ? 'http://localhost:3000/api/sync/customers/incremental'
          : 'http://localhost:3000/api/sync/customers'; // Auto mode uses existing endpoint

        const response = await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${token}`,
            'Content-Type': 'application/json'
          }
        });

        if (!response.ok) {
          throw new Error('Errore sincronizzazione');
        }

        const data = await response.json();
        console.log('Sync started:', data.message);
      } catch (error) {
        console.error('Errore sync:', error);
      } finally {
        setSyncing(false);
      }
    };
    ```

    Why dropdown UI: Banking app pattern (Intesa/UniCredit), explicit control without cluttering UI, educates users on sync modes.
  </action>
  <verify>
    npm run typecheck in frontend directory passes

    Manual check:
    1. Start frontend dev server
    2. Navigate to page with SyncButton
    3. Click dropdown toggle: verify menu opens with 3 options
    4. Select each mode: verify selected mode highlights
    5. Click main button: verify correct endpoint called based on mode
    6. Check dropdown closes after selection
  </verify>
  <done>
    SyncButton updated with dropdown mode selection.
    Three modes: Auto (default), Full, Incremental.
    Dropdown menu with inline styles (Phase 10-06 pattern).
    handleSync calls correct endpoint based on selectedMode.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add sync progress message with mode indicator</name>
  <files>
    archibald-web-app/frontend/src/components/SyncBanner.tsx
  </files>
  <action>
    Update SyncBanner (or create if doesn't exist) to show sync mode in progress message:

    If SyncBanner exists, update progress display:
    ```typescript
    // Add mode to progress message
    {progress.status === 'syncing' && (
      <div style={{ padding: '15px', background: '#3498db', color: 'white', textAlign: 'center' }}>
        Sincronizzazione clienti in corso...
        <br />
        <small>
          ModalitÃ : {progress.message.includes('incrementale') ? 'Incrementale (veloce)' : 'Completa'}
          {' | '}
          Pagina {progress.currentPage} di {progress.totalPages}
          {' | '}
          Clienti: {progress.customersProcessed}
        </small>
      </div>
    )}
    ```

    If SyncBanner doesn't exist or this is not relevant, skip this task or add mode display elsewhere (e.g., SyncButton label).

    Why mode indicator: User feedback on sync strategy, transparency on what operation is running, educational value.
  </action>
  <verify>
    npm run typecheck in frontend directory passes

    Manual check:
    1. Trigger full sync: verify "ModalitÃ : Completa" appears in progress
    2. Trigger incremental sync: verify "ModalitÃ : Incrementale (veloce)" appears
    3. Check progress updates show correct page counts
  </verify>
  <done>
    Sync progress message updated with mode indicator.
    Shows "Completa" or "Incrementale (veloce)" based on sync type.
    Progress details include pages and customers processed.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes in backend and frontend directories
- [ ] Three granular sync endpoints added to backend
- [ ] POST /api/sync/customers/full triggers full sync
- [ ] POST /api/sync/customers/incremental triggers incremental sync
- [ ] POST /api/sync/customers/:customerId returns 501 (not implemented)
- [ ] SyncButton component updated with dropdown mode selection
- [ ] Dropdown menu functional with 3 modes (Auto, Full, Incremental)
- [ ] handleSync calls correct endpoint based on selected mode
- [ ] Sync progress shows mode indicator
- [ ] No TypeScript errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Three granular sync API endpoints functional
- Frontend dropdown UI for sync mode selection
- Auto mode (default), Full mode, Incremental mode selectable
- Sync progress displays mode indicator
- Users have explicit control over sync strategy
- Single customer endpoint placeholder (501 Not Implemented)
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/18-customers-sync-optimization/18-04-SUMMARY.md`:

# Phase 18 Plan 04: Manual Sync Granularity Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `archibald-web-app/backend/src/index.ts` - Description
- `archibald-web-app/frontend/src/components/SyncButton.tsx` - Description
- `archibald-web-app/frontend/src/components/SyncBanner.tsx` - Description (if modified)

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 18-05-PLAN.md (Sync Optimization & Checkpoint)
</output>
