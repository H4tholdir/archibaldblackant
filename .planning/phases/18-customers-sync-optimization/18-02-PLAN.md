---
phase: 18-customers-sync-optimization
plan: 02
type: execute
---

<objective>
Enhance background sync with intelligent scheduling, error recovery, and health monitoring.

Purpose: Improve existing CustomerSyncService auto-sync reliability and observability for production environments.
Output: Enhanced background sync with retry logic, health monitoring, and intelligent scheduling to avoid conflicts.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

**Key files:**
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/backend/src/sync-scheduler.ts
@archibald-web-app/backend/src/index.ts

**Tech stack available:**
- Node.js setInterval for scheduling
- Winston logger for monitoring
- EventEmitter for progress events
- SQLite for tracking sync history

**Existing auto-sync implementation:**
- startAutoSync(intervalMinutes, skipInitialSync) method (lines 83-109)
- 30-minute default interval
- Initial sync after 5 seconds
- Basic error logging (no retry)
- No health tracking

**Enhancement requirements:**
- Retry logic for transient failures (network errors, timeouts)
- Exponential backoff between retries
- Health monitoring (success rate, last successful sync timestamp)
- Intelligent scheduling (coordinate with other syncs to avoid overlap)
- Graceful degradation (skip sync if system under load)

**Related systems:**
- PriorityManager for order priority
- SyncScheduler for coordinating multiple syncs
- Active operation lock (activeOperation in index.ts)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry logic with exponential backoff to syncCustomers</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
  </files>
  <action>
    Wrap syncCustomers call in retry logic with exponential backoff:

    1. Add retry configuration at class level:
    ```typescript
    private readonly MAX_RETRIES = 3;
    private readonly INITIAL_RETRY_DELAY = 5000; // 5 seconds
    private retryCount = 0;
    ```

    2. Create private retry wrapper method:
    ```typescript
    /**
     * Execute sync with retry logic and exponential backoff
     */
    private async syncCustomersWithRetry(): Promise<void> {
      for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
        try {
          await this.syncCustomers();

          // Success - reset retry count
          this.retryCount = 0;
          return;
        } catch (error) {
          this.retryCount = attempt;

          const isLastAttempt = attempt === this.MAX_RETRIES;
          if (isLastAttempt) {
            logger.error('❌ Customer sync failed after max retries', {
              attempt,
              maxRetries: this.MAX_RETRIES,
              error
            });

            // Update progress to error state
            this.updateProgress({
              status: 'error',
              currentPage: this.progress.currentPage,
              totalPages: this.progress.totalPages,
              customersProcessed: this.progress.customersProcessed,
              message: `Sync fallito dopo ${this.MAX_RETRIES} tentativi`,
              error: error instanceof Error ? error.message : 'Unknown error'
            });

            throw error;
          }

          // Calculate exponential backoff delay
          const delayMs = this.INITIAL_RETRY_DELAY * Math.pow(2, attempt - 1);
          logger.warn('⚠️ Customer sync failed, retrying...', {
            attempt,
            maxRetries: this.MAX_RETRIES,
            retryInSeconds: delayMs / 1000,
            error: error instanceof Error ? error.message : 'Unknown error'
          });

          // Wait before retry
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
    }
    ```

    3. Update startAutoSync to use retry wrapper:
    ```typescript
    startAutoSync(intervalMinutes: number = 30, skipInitialSync: boolean = false): void {
      logger.info(
        `Avvio auto-sync ogni ${intervalMinutes} minuti${skipInitialSync ? ' (senza sync iniziale)' : ''}`,
      );

      if (!skipInitialSync) {
        // Initial sync with retry
        setTimeout(() => {
          this.syncCustomersWithRetry().catch((error) => {
            logger.error('Errore sync iniziale (dopo retry)', { error });
          });
        }, 5000);
      }

      // Periodic sync with retry
      this.syncInterval = setInterval(
        () => {
          this.syncCustomersWithRetry().catch((error) => {
            logger.error('Errore sync periodico (dopo retry)', { error });
          });
        },
        intervalMinutes * 60 * 1000,
      );
    }
    ```

    Why exponential backoff: Prevents overwhelming server during outages, gives transient errors time to resolve (5s → 10s → 20s delays).
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Test retry logic by simulating sync failure (e.g., stop Archibald server mid-sync)
    2. Verify 3 retry attempts with increasing delays
    3. Check logs show retry attempt numbers and backoff times
  </verify>
  <done>
    Retry logic with exponential backoff added to syncCustomers.
    syncCustomersWithRetry wrapper method created.
    MAX_RETRIES = 3, backoff delays: 5s, 10s, 20s.
    startAutoSync updated to use retry wrapper.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sync health monitoring and statistics tracking</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
  </files>
  <action>
    Add health monitoring to track sync success rate and history:

    1. Add health statistics at class level:
    ```typescript
    private syncStats = {
      totalAttempts: 0,
      successfulSyncs: 0,
      failedSyncs: 0,
      lastSuccessAt: null as Date | null,
      lastFailureAt: null as Date | null,
      lastError: null as string | null,
      consecutiveFailures: 0
    };
    ```

    2. Update syncCustomersWithRetry to track stats:
    ```typescript
    private async syncCustomersWithRetry(): Promise<void> {
      this.syncStats.totalAttempts++;

      for (let attempt = 1; attempt <= this.MAX_RETRIES; attempt++) {
        try {
          await this.syncCustomers();

          // Success - update stats
          this.retryCount = 0;
          this.syncStats.successfulSyncs++;
          this.syncStats.lastSuccessAt = new Date();
          this.syncStats.consecutiveFailures = 0;

          logger.info('✅ Customer sync completed successfully', {
            totalAttempts: this.syncStats.totalAttempts,
            successRate: `${((this.syncStats.successfulSyncs / this.syncStats.totalAttempts) * 100).toFixed(1)}%`,
            consecutiveFailures: this.syncStats.consecutiveFailures
          });

          return;
        } catch (error) {
          // ... existing retry logic ...

          if (isLastAttempt) {
            // Failure after retries - update stats
            this.syncStats.failedSyncs++;
            this.syncStats.lastFailureAt = new Date();
            this.syncStats.lastError = error instanceof Error ? error.message : 'Unknown error';
            this.syncStats.consecutiveFailures++;

            logger.error('❌ Customer sync failed after max retries', {
              attempt,
              maxRetries: this.MAX_RETRIES,
              totalAttempts: this.syncStats.totalAttempts,
              successRate: `${((this.syncStats.successfulSyncs / this.syncStats.totalAttempts) * 100).toFixed(1)}%`,
              consecutiveFailures: this.syncStats.consecutiveFailures,
              error
            });

            // ... rest of error handling ...
          }

          // ... existing backoff logic ...
        }
      }
    }
    ```

    3. Add health status getter method:
    ```typescript
    /**
     * Get sync health statistics
     */
    getSyncHealth(): {
      totalAttempts: number;
      successfulSyncs: number;
      failedSyncs: number;
      successRate: number;
      lastSuccessAt: Date | null;
      lastFailureAt: Date | null;
      lastError: string | null;
      consecutiveFailures: number;
      isHealthy: boolean;
    } {
      const successRate = this.syncStats.totalAttempts > 0
        ? (this.syncStats.successfulSyncs / this.syncStats.totalAttempts) * 100
        : 100;

      // Healthy if: success rate > 80% AND consecutive failures < 3
      const isHealthy = successRate >= 80 && this.syncStats.consecutiveFailures < 3;

      return {
        ...this.syncStats,
        successRate,
        isHealthy
      };
    }
    ```

    Why health tracking: Enables monitoring dashboards (Phase 25), alerts for degraded sync performance, operational visibility.
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Run multiple syncs (successful and failed)
    2. Call getSyncHealth() and verify stats are accurate
    3. Check isHealthy flag reflects success rate and consecutive failures
  </verify>
  <done>
    Sync health monitoring added with statistics tracking.
    syncStats tracks attempts, successes, failures, last sync times, consecutive failures.
    getSyncHealth() method returns health status and metrics.
    isHealthy flag: successRate >= 80% AND consecutiveFailures < 3.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add health check API endpoint for monitoring</name>
  <files>
    archibald-web-app/backend/src/index.ts
  </files>
  <action>
    Add API endpoint to expose customer sync health status:

    Add endpoint after existing sync endpoints (around line 3500):
    ```typescript
    // Get customer sync health status - GET /api/sync/customers/health
    app.get(
      '/api/sync/customers/health',
      authenticateJWT,
      async (req: AuthRequest, res: Response<ApiResponse>) => {
        try {
          const health = syncService.getSyncHealth();

          res.json({
            success: true,
            data: {
              ...health,
              lastSuccessAt: health.lastSuccessAt?.toISOString() || null,
              lastFailureAt: health.lastFailureAt?.toISOString() || null
            },
            message: health.isHealthy
              ? 'Sync clienti in salute'
              : '⚠️ Sync clienti degradato'
          });
        } catch (error) {
          logger.error('Errore lettura health sync clienti', { error });

          res.status(500).json({
            success: false,
            data: null,
            message: error instanceof Error ? error.message : 'Errore lettura health'
          });
        }
      }
    );
    ```

    Why API endpoint: Enables external monitoring (Prometheus, Grafana, health check scripts), dashboard integration (Phase 25).
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Start backend
    2. Test endpoint: curl -H "Authorization: Bearer TOKEN" http://localhost:3000/api/sync/customers/health
    3. Verify response includes all health metrics
    4. Check isHealthy flag is accurate
  </verify>
  <done>
    GET /api/sync/customers/health endpoint added.
    Returns sync health statistics with isHealthy flag.
    JWT authentication required.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes in backend directory
- [ ] Retry logic with exponential backoff implemented
- [ ] Sync health monitoring tracks statistics
- [ ] getSyncHealth() method returns accurate metrics
- [ ] GET /api/sync/customers/health endpoint functional
- [ ] No TypeScript errors
- [ ] Retry logic tested with simulated failures
- [ ] Health stats update correctly on success/failure
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Retry logic with exponential backoff (3 attempts, 5s→10s→20s delays)
- Sync health monitoring tracks success rate and consecutive failures
- isHealthy flag reflects sync reliability
- API endpoint exposes health metrics for monitoring
- Graceful error recovery for transient failures
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/18-customers-sync-optimization/18-02-SUMMARY.md`:

# Phase 18 Plan 02: Background Sync Enhancement Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `archibald-web-app/backend/src/customer-sync-service.ts` - Description
- `archibald-web-app/backend/src/index.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 18-03-PLAN.md (Incremental Sync Implementation)
</output>
