---
phase: 18-customers-sync-optimization
plan: 05
type: execute
---

<objective>
Apply identified performance optimizations and verify all sync modes with comprehensive checkpoint.

Purpose: Implement optimization recommendations from 18-01 analysis and validate complete customer sync functionality.
Output: Optimized sync performance (target: 30-40% faster), all sync modes functional, comprehensive verification checkpoint.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-customers-sync-optimization/ANALYSIS.md

**Key files:**
@archibald-web-app/backend/src/customer-sync-service.ts
@archibald-web-app/backend/src/archibald-bot.ts

**Tech stack available:**
- Puppeteer for browser automation
- Winston logger for performance tracking

**Optimizations identified (from 18-01 ANALYSIS.md)**:
1. Remove/optimize filter clearing (if unnecessary) - potential -2.5s
2. Replace networkidle2 with specific selectors - potential -5-10s
3. Reduce explicit setTimeout delays - potential -10-15s
4. Batch customer data extraction - potential -3-5s

**Performance baseline (from 18-01)**:
- Total duration: ~59.2s
- Target optimized: ~35-42s (30-40% improvement)

**Sync modes to verify**:
- Full sync (all pages)
- Incremental sync (first 3 pages)
- Auto sync (intelligent mode selection)
- Background sync with retry logic
- Health monitoring and statistics
</context>

<tasks>

<task type="auto">
  <name>Task 1: Optimize page navigation waits (replace networkidle2 with specific selectors)</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
  </files>
  <action>
    Replace networkidle2 wait conditions with faster specific selector waits:

    1. Initial navigation to customer list (line ~223):
    ```typescript
    // BEFORE:
    await page.goto(`${config.archibald.url}/CUSTTABLE_ListView_Agent/`, {
      waitUntil: 'networkidle2',
      timeout: 60000,
    });

    // AFTER:
    await page.goto(`${config.archibald.url}/CUSTTABLE_ListView_Agent/`, {
      waitUntil: 'domcontentloaded', // Faster than networkidle2
      timeout: 60000,
    });
    await page.waitForSelector('table tbody tr', { timeout: 10000 }); // Explicit wait for content
    ```

    2. Page navigation after filter clearing (line ~252):
    ```typescript
    // AFTER filter clearing, wait for table rows instead of fixed delay
    // BEFORE:
    await new Promise((resolve) => setTimeout(resolve, 2000));
    await page.waitForSelector("table tbody tr", { timeout: 10000 });

    // AFTER:
    await page.waitForSelector("table tbody tr", { timeout: 10000 }); // Remove setTimeout, trust selector wait
    ```

    3. After clicking pagination (inside loop):
    ```typescript
    // BEFORE (if exists):
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // AFTER:
    await page.waitForSelector('table tbody tr', { visible: true, timeout: 10000 });
    ```

    Why domcontentloaded: Faster than networkidle2 (waits for DOM, not all network activity), combined with explicit selector waits ensures reliability without over-waiting.
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Run full sync with optimization
    2. Verify sync still completes successfully
    3. Check logs for performance improvement in navigation phase
    4. Ensure no "Target closed" or "Frame detached" errors
  </verify>
  <done>
    Page navigation optimized: networkidle2 → domcontentloaded + explicit selectors.
    Explicit setTimeout delays after navigation removed.
    Selector waits ensure page load without over-waiting.
    TypeScript compilation passes.
    Navigation phase estimated -7-12s improvement.
  </done>
</task>

<task type="auto">
  <name>Task 2: Optimize or remove filter clearing if unnecessary</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
  </files>
  <action>
    Evaluate filter clearing necessity and optimize:

    1. Check if filter clearing is necessary (lines 234-253):
       - If filters are never applied during sync, remove entire section
       - If filters persist across browser sessions, keep but optimize

    2. If keeping filter clearing, optimize with faster logic:
    ```typescript
    // BEFORE: Multiple setTimeout delays totaling ~2.5s
    // ...existing filter clearing code...

    // AFTER: Single optimized check + clear
    logger.info('Verifica filtri di ricerca...');
    const hasActiveFilters = await page.evaluate(() => {
      const searchInputs = Array.from(document.querySelectorAll('input[type="text"]'));
      return searchInputs.some(input => (input as HTMLInputElement).value.trim().length > 0);
    });

    if (hasActiveFilters) {
      logger.info('Pulizia filtri attivi...');
      await page.evaluate(() => {
        const searchInputs = Array.from(document.querySelectorAll('input[type="text"]'));
        for (const input of searchInputs) {
          const inputEl = input as HTMLInputElement;
          if (inputEl.value.trim().length > 0) {
            inputEl.value = '';
            inputEl.dispatchEvent(new Event('input', { bubbles: true }));
          }
        }
      });
      await page.waitForSelector('table tbody tr', { timeout: 10000 }); // Wait for refresh
    } else {
      logger.info('Nessun filtro attivo, skip pulizia');
    }
    ```

    3. If filter clearing is completely unnecessary (no filters ever applied):
       - Comment out entire filter clearing section (lines 234-253)
       - Add comment explaining why skipped

    Why conditional clearing: Only clears if filters actually exist, saves 2-5s when filters not present (majority of cases).
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Run sync without filters: verify skip message in logs
    2. Apply filter manually, run sync: verify filter cleared
    3. Check performance logs for time saved
  </verify>
  <done>
    Filter clearing optimized with conditional check.
    Only clears if active filters detected.
    Reduces unnecessary waits when no filters present.
    TypeScript compilation passes.
    Estimated -1-2.5s improvement when filters not active.
  </done>
</task>

<task type="auto">
  <name>Task 3: Reduce explicit setTimeout delays with dynamic waits</name>
  <files>
    archibald-web-app/backend/src/customer-sync-service.ts
  </files>
  <action>
    Replace remaining explicit setTimeout calls with dynamic waitForSelector:

    1. After page load wait (line ~232):
    ```typescript
    // BEFORE:
    await new Promise((resolve) => setTimeout(resolve, 3000)); // Wait for "Loading..." to disappear

    // AFTER:
    // Check if loading indicator exists, wait for it to disappear
    try {
      await page.waitForFunction(
        () => !document.body.textContent?.includes('Loading...'),
        { timeout: 5000 }
      );
    } catch (error) {
      // Timeout OK - page likely already loaded
      logger.debug('No loading indicator found or already cleared');
    }
    ```

    2. After filter clearing (already handled in Task 2)

    3. After page positioning (line ~307):
    ```typescript
    // BEFORE:
    await new Promise((resolve) => setTimeout(resolve, 2000));

    // AFTER:
    await page.waitForSelector('table tbody tr', { visible: true, timeout: 5000 });
    ```

    4. Review entire file for other setTimeout calls and replace with dynamic waits where possible

    Why dynamic waits: Adapts to actual page load speed, faster on fast networks, more reliable on slow networks, no arbitrary delays.
  </action>
  <verify>
    npm run typecheck in backend directory passes

    Manual check:
    1. Run sync and check for remaining setTimeout in logs
    2. Verify all page transitions work reliably
    3. Test on slow network (DevTools throttling): ensure dynamic waits still work
    4. Check performance logs for cumulative time savings
  </verify>
  <done>
    Explicit setTimeout delays replaced with dynamic waitForSelector/waitForFunction.
    Page load detection uses waitForFunction (no "Loading..." text).
    All transitions use explicit selector waits.
    TypeScript compilation passes.
    Estimated -8-12s improvement from removing arbitrary delays.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete customer sync optimization with all modes functional</what-built>
  <how-to-verify>
    1. Start backend: cd archibald-web-app/backend && npm run dev
    2. Start frontend: cd archibald-web-app/frontend && npm run dev

    **Test 1: Full Sync Performance**
    3. Trigger full sync via frontend dropdown: "Sync Completo"
    4. Monitor backend logs for [PERF] timing entries
    5. Verify completion time: Target 35-42s (baseline was ~59s)
    6. Check logs confirm:
       - Login phase: <10s
       - Navigation phase: <3s
       - Filter clearing: <1s (or skipped if no filters)
       - Scraping phase: <30s
    7. Verify all customers synced successfully (check customer count)

    **Test 2: Incremental Sync Performance**
    8. Wait 1 minute, trigger incremental sync: "Sync Incrementale (veloce)"
    9. Verify logs show "Modalità: incremental"
    10. Verify only first 3 pages scraped
    11. Check completion time: Target 8-12s (3 pages only)
    12. Confirm checkpoint manager marks incremental sync

    **Test 3: Auto Mode (Intelligent Selection)**
    13. Immediately trigger auto sync: "Auto (consigliato)"
    14. Verify logs show incremental mode (last full sync < 7 days)
    15. Wait 8 days (or manually set lastFullSyncAt to 8 days ago in DB)
    16. Trigger auto sync again
    17. Verify logs show full mode (last full sync > 7 days)

    **Test 4: Retry Logic and Health Monitoring**
    18. Simulate failure: stop Archibald server mid-sync
    19. Trigger full sync
    20. Verify logs show 3 retry attempts with exponential backoff (5s, 10s, 20s)
    21. Verify error state in progress after 3 failed attempts
    22. Check health endpoint: GET /api/sync/customers/health
    23. Verify health shows failedSyncs++, isHealthy = false

    **Test 5: Background Auto-Sync**
    24. Restart backend with auto-sync enabled
    25. Verify initial sync runs after 5 seconds
    26. Wait 30 minutes (or adjust interval for testing)
    27. Verify periodic sync runs automatically
    28. Check logs show auto mode selection (full vs incremental)

    **Test 6: Frontend Dropdown UI**
    29. Navigate to page with SyncButton
    30. Click dropdown toggle (▼ button)
    31. Verify 3 options appear: Auto, Sync Completo, Sync Incrementale
    32. Select "Sync Completo": verify full sync starts
    33. Check progress banner shows "Modalità: Completa"
    34. Select "Sync Incrementale": verify incremental sync starts
    35. Check progress banner shows "Modalità: Incrementale (veloce)"

    **Test 7: Performance Baseline Comparison**
    36. Review performance logs from full sync
    37. Calculate total improvement: (baseline 59.2s - optimized time) / 59.2s
    38. Verify improvement >= 30% (target: 35-42s = 29-41% improvement)

    **Success Criteria:**
    - Full sync completes in 35-42s (30-40% improvement)
    - Incremental sync completes in 8-12s (80-85% faster)
    - Auto mode intelligently selects full/incremental based on 7-day threshold
    - Retry logic handles transient failures (3 attempts with backoff)
    - Health monitoring tracks success rate and consecutive failures
    - Health API endpoint returns accurate statistics
    - Frontend dropdown UI functional with 3 modes
    - Progress messages show sync mode
    - All customers synced correctly (data integrity maintained)
    - No errors or crashes during any sync mode
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run typecheck` passes in backend directory
- [ ] Page navigation optimized (networkidle2 → domcontentloaded + selectors)
- [ ] Filter clearing optimized (conditional check, skip if no filters)
- [ ] Explicit setTimeout delays replaced with dynamic waits
- [ ] No TypeScript errors
- [ ] Full sync performance improved by 30-40%
- [ ] All sync modes functional (full, incremental, auto, background, manual)
- [ ] User verification approved (comprehensive checkpoint passed)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Performance optimizations applied:
  - Navigation waits optimized (-7-12s)
  - Filter clearing conditional (-1-2.5s)
  - setTimeout replaced with dynamic waits (-8-12s)
- Full sync target: 35-42s (30-40% improvement from 59.2s baseline)
- Incremental sync: 8-12s (only 3 pages)
- Auto mode intelligently selects sync strategy
- Retry logic with exponential backoff (3 attempts)
- Health monitoring functional
- All sync modes verified by user
- Data integrity maintained
- No errors or warnings introduced
  </success_criteria>

<output>
After completion, create `.planning/phases/18-customers-sync-optimization/18-05-SUMMARY.md`:

# Phase 18 Plan 05: Sync Optimization & Checkpoint Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Files Created/Modified

- `archibald-web-app/backend/src/customer-sync-service.ts` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Performance Results

| Metric | Baseline (18-01) | Optimized | Improvement |
|--------|-----------------|-----------|-------------|
| Full sync | 59.2s | [ACTUAL]s | [X]% |
| Incremental sync | N/A | [ACTUAL]s | N/A (new feature) |
| Login phase | 8.5s | [ACTUAL]s | [X]% |
| Navigation phase | 3.2s | [ACTUAL]s | [X]% |
| Filter clearing | 2.5s | [ACTUAL]s | [X]% |
| Scraping phase | 45.0s | [ACTUAL]s | [X]% |

## Next Step

Phase 18 complete. Ready for Phase 19 (Products Sync Analysis & Optimization).
</output>
