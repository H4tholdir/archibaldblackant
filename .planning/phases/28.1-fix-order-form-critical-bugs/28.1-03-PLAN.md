---
phase: 28.1-fix-order-form-critical-bugs
plan: 03
type: execute
---

<objective>
Fix white screen crash when clicking "Aggiungi articolo" after selecting article and customer.

Purpose: Prevent app crashes during order creation - users must be able to add items to their order without the app crashing.
Output: Stable form submission with proper error handling, no white screens, clear user feedback on errors.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.1-fix-order-form-critical-bugs/28.1-CONTEXT.md
@archibald-web-app/frontend/src/components/OrderForm.tsx
@archibald-web-app/frontend/src/services/draft-service.ts
@archibald-web-app/frontend/src/services/cache-service.ts

**Root Cause Analysis (from CONTEXT.md):**
5 potential crash points identified:

1. **handleAddItem (820-877)**: NaN in package constraints validation
2. **IndexedDB operations**: QuotaExceededError or InvalidStateError
3. **Cache staleness check (1005)**: Unhandled promise rejection in isCacheStale()
4. **Invalid draftData structure (1018-1034)**: Empty customerId/items array
5. **Pricing calculation (999)**: Exception before try-catch block

**Key Decisions:**
- Phase 08-07: Comprehensive debug logging in OrderForm
- Phase 08-01: Graceful degradation if IndexedDB unavailable
- Phase 14-01: Pattern A: Filter undefined fields before IndexedDB bulkPut

**Critical**: Need error boundaries and try-catch blocks to prevent white screens
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add error boundary and comprehensive try-catch blocks</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx</files>
  <action>
Wrap critical operations in try-catch blocks to prevent crashes:

1. **Wrap handleAddItem (lines 820-877)** in try-catch:
   ```typescript
   const handleAddItem = () => {
     try {
       // Validate basic inputs
       if (!newItem.articleCode || newItem.quantity <= 0) {
         alert("Inserisci nome prodotto e quantit√†");
         return;
       }

       // Validate package constraints with NaN check
       if (packageConstraints) {
         const multiple = packageConstraints.multipleQty;

         // Check for NaN before using modulo
         if (!multiple || isNaN(multiple) || !isFinite(multiple)) {
           console.error('[OrderForm] Invalid package multipleQty:', multiple);
           alert('Errore: configurazione package non valida. Riprova.');
           return;
         }

         // Safe to use modulo now
         if (newItem.quantity % multiple !== 0) {
           alert(
             `La quantit√† deve essere un multiplo di ${multiple}. ` +
               `Quantit√† suggerite: ${Math.floor(newItem.quantity / multiple) * multiple}, ` +
               `${Math.ceil(newItem.quantity / multiple) * multiple}`,
           );
           return;
         }

         // ... rest of validation
       }

       // Validate newItem structure before adding to array
       if (!newItem || typeof newItem !== 'object') {
         console.error('[OrderForm] Invalid newItem structure:', newItem);
         alert('Errore: dati articolo non validi');
         return;
       }

       // Add to draft
       setDraftItems((prev) => [...prev, { ...newItem }]);

       // Clear form for next item
       setNewItem({
         articleCode: "",
         productName: "",
         description: "",
         quantity: 1,
         price: 0,
         discount: 0,
       });
       setProductSearch("");
       setPackageConstraints(null);

       // Clear voice-populated indicators
       setVoicePopulatedFields({
         customer: false,
         article: false,
         quantity: false,
       });

     } catch (error) {
       console.error('[OrderForm] Error in handleAddItem:', error);
       alert(`Errore durante l'aggiunta dell'articolo: ${error instanceof Error ? error.message : 'Errore sconosciuto'}`);
     }
   };
   ```

2. **Wrap handleConfirmOrder (lines 997-1012)** in try-catch:
   ```typescript
   const handleConfirmOrder = async () => {
     try {
       // Validate pricing
       if (pricingError) {
         alert(pricingError);
         return;
       }

       // Check if cache is stale with error handling
       let isStale = false;
       try {
         isStale = await cacheService.isCacheStale();
       } catch (cacheError) {
         console.warn('[OrderForm] Cache staleness check failed:', cacheError);
         // Continue without cache check - better than blocking user
       }

       if (isStale) {
         setShowStaleWarning(true);
         return;
       }

       // Proceed with order submission
       await submitOrder();

     } catch (error) {
       console.error('[OrderForm] Error in handleConfirmOrder:', error);
       alert(`Errore durante la conferma ordine: ${error instanceof Error ? error.message : 'Errore sconosciuto'}`);
     }
   };
   ```

3. **Wrap submitOrder (lines 1015-1077)** in try-catch (already has one, but improve it):
   ```typescript
   const submitOrder = async () => {
     setLoading(true);
     try {
       // Validate required fields
       if (!customerId || !customerName) {
         alert('Errore: cliente non selezionato. Seleziona un cliente prima di procedere.');
         return;
       }

       if (draftItems.length === 0) {
         alert('Errore: nessun articolo nell\'ordine. Aggiungi almeno un articolo.');
         return;
       }

       const draftData = {
         customerId,
         customerName,
         items: draftItems.map((item) => ({
           articleCode: item.articleCode,
           productName: item.productName,
           description: item.description,
           quantity: item.quantity,
           price: item.price,
           discount: item.discount,
         })),
         discountPercent:
           calculatedDiscount > 0 ? calculatedDiscount : undefined,
         targetTotalWithVAT: targetTotalWithVAT
           ? parseFloat(targetTotalWithVAT)
           : undefined,
       };

       let draft;
       if (editingDraftId) {
         draft = updateDraftOrder(editingDraftId, draftData);
         if (!draft) {
           throw new Error("Bozza non trovata");
         }
       } else {
         draft = saveDraftOrder(draftData);
       }

       console.log("[OrderForm] Draft saved with ID:", draft.id);

       // Clear old draft from IndexedDB with error handling
       try {
         await draftService.clearDraft();
       } catch (dbError) {
         console.warn('[OrderForm] Failed to clear old draft:', dbError);
         // Non-blocking - continue anyway
       }

       // Clear form
       setDraftItems([]);
       setShowConfirmModal(false);
       setCustomerId("");
       setCustomerName("");
       setCustomerSearch("");
       setTargetTotalWithVAT("");
       setEditingDraftId(null);

       // Show success message
       const message = editingDraftId
         ? "‚úÖ Bozza aggiornata!\n\nLe modifiche sono state salvate. Puoi continuare con un nuovo ordine o cliccare 'Fine' per uscire."
         : '‚úÖ Bozza salvata!\n\nPuoi continuare con un nuovo ordine o cliccare "Fine" per tornare alle bozze.';
       alert(message);

     } catch (error) {
       console.error("[OrderForm] Error saving draft:", error);

       // User-friendly error messages
       let errorMessage = 'Errore durante il salvataggio della bozza';
       if (error instanceof Error) {
         if (error.message.includes('QuotaExceededError')) {
           errorMessage = 'Spazio insufficiente sul dispositivo. Svuota la cache o libera spazio.';
         } else if (error.message.includes('InvalidStateError')) {
           errorMessage = 'Errore database. Prova a ricaricare la pagina.';
         } else {
           errorMessage = `${errorMessage}: ${error.message}`;
         }
       }

       alert(errorMessage);
     } finally {
       setLoading(false);
     }
   };
   ```

CRITICAL: Do NOT change business logic, only add error handling.
AVOID modifying state management - only wrap in try-catch.
  </action>
  <verify>
1. npm run build succeeds
2. No TypeScript errors
3. Code compiles without warnings
4. All try-catch blocks properly placed
  </verify>
  <done>All critical functions wrapped in try-catch, error handling added, user-friendly error messages, build passes</done>
</task>

<task type="auto">
  <name>Task 2: Add React Error Boundary component</name>
  <files>archibald-web-app/frontend/src/components/ErrorBoundary.tsx, archibald-web-app/frontend/src/App.tsx</files>
  <action>
Create a React Error Boundary to catch rendering errors:

1. **Create ErrorBoundary.tsx**:
   ```typescript
   import React, { Component, ErrorInfo, ReactNode } from 'react';

   interface Props {
     children: ReactNode;
   }

   interface State {
     hasError: boolean;
     error: Error | null;
   }

   class ErrorBoundary extends Component<Props, State> {
     constructor(props: Props) {
       super(props);
       this.state = {
         hasError: false,
         error: null,
       };
     }

     static getDerivedStateFromError(error: Error): State {
       return {
         hasError: true,
         error,
       };
     }

     componentDidCatch(error: Error, errorInfo: ErrorInfo) {
       console.error('[ErrorBoundary] Caught error:', error, errorInfo);
     }

     handleReset = () => {
       this.setState({ hasError: false, error: null });
       // Reload page to reset app state
       window.location.reload();
     };

     render() {
       if (this.state.hasError) {
         return (
           <div style={{
             padding: '40px',
             textAlign: 'center',
             fontFamily: 'system-ui, -apple-system, sans-serif',
           }}>
             <h1 style={{ color: '#c62828', marginBottom: '20px' }}>
               ‚ö†Ô∏è Errore Applicazione
             </h1>
             <p style={{ marginBottom: '10px', color: '#666' }}>
               Si √® verificato un errore imprevisto.
             </p>
             <p style={{ marginBottom: '30px', color: '#666', fontSize: '14px' }}>
               {this.state.error?.message || 'Errore sconosciuto'}
             </p>
             <button
               onClick={this.handleReset}
               style={{
                 padding: '12px 24px',
                 fontSize: '16px',
                 backgroundColor: '#1976d2',
                 color: 'white',
                 border: 'none',
                 borderRadius: '4px',
                 cursor: 'pointer',
               }}
             >
               üîÑ Ricarica Applicazione
             </button>
           </div>
         );
       }

       return this.props.children;
     }
   }

   export default ErrorBoundary;
   ```

2. **Wrap OrderForm in ErrorBoundary in App.tsx** (or AppRouter.tsx):
   - Find where OrderForm is rendered
   - Wrap it: `<ErrorBoundary><OrderForm /></ErrorBoundary>`
   - This catches any rendering errors and shows user-friendly message instead of white screen

This prevents white screens by catching React rendering errors.
  </action>
  <verify>
1. ErrorBoundary.tsx file created
2. OrderForm wrapped in ErrorBoundary in routing
3. npm run build succeeds
4. No TypeScript errors
  </verify>
  <done>Error Boundary created and wrapping OrderForm, rendering errors will show friendly message instead of white screen</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Comprehensive error handling and Error Boundary to prevent white screen crashes</what-built>
  <how-to-verify>
1. Run: `cd archibald-web-app/frontend && npm run dev`
2. Visit: http://localhost:5173
3. Navigate to order creation form

**Test Case 1: Valid order creation (happy path)**
   a. Select a customer
   b. Select a product
   c. Click "Aggiungi articolo"
   d. **EXPECTED**: Article added to draft list, no crash
   e. **EXPECTED**: Form clears for next item
   f. Click "Fine" or "üöÄ Create Order"
   g. **EXPECTED**: Confirmation modal appears
   h. Confirm order
   i. **EXPECTED**: Success message, no white screen

**Test Case 2: Invalid package quantity**
   a. Select product with package constraints (e.g., 5-pack)
   b. Enter invalid quantity (e.g., 7 for 5-pack)
   c. Click "Aggiungi articolo"
   d. **EXPECTED**: Alert with suggested quantities, no crash

**Test Case 3: Missing customer**
   a. Do NOT select a customer
   b. Select product and quantity
   c. Add to draft
   d. Click "üöÄ Create Order"
   e. Confirm in modal
   f. **EXPECTED**: Error message "cliente non selezionato", no crash

**Test Case 4: Empty order**
   a. Select customer
   b. Do NOT add any articles
   c. Click "üöÄ Create Order" (if button is enabled)
   d. **EXPECTED**: Error message "nessun articolo nell'ordine", no crash

**Test Case 5: Browser storage full simulation** (optional)
   a. Open DevTools ‚Üí Application ‚Üí Storage
   b. Try to simulate QuotaExceededError if possible
   c. **EXPECTED**: User-friendly error about storage, no white screen

5. Check browser console:
   - Errors should be logged with [OrderForm] prefix
   - Should see stack traces for debugging
   - Should NOT see unhandled promise rejections
   - Should NOT see white screen at any point

6. Reload page and confirm:
   - App recovers normally
   - No persisted error state
  </how-to-verify>
  <resume-signal>Type "approved" if all test cases pass and no white screens occur, or describe which test case crashes</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] No white screen when adding articles
- [ ] No white screen on order submission
- [ ] Error messages are user-friendly
- [ ] Console shows detailed error logs for debugging
- [ ] Error Boundary catches rendering errors
- [ ] All validation errors show alerts instead of crashing
- [ ] Build succeeds without warnings
</verification>

<success_criteria>
- All tasks completed
- White screen bug eliminated
- Comprehensive error handling in place
- User sees friendly error messages instead of crashes
- Error Boundary prevents React rendering crashes
- App remains stable under all test scenarios
- IndexedDB errors handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-fix-order-form-critical-bugs/28.1-03-SUMMARY.md`:

# Phase 28.1 Plan 03: Fix White Screen Crash - Summary

**White screen crashes eliminated - comprehensive error handling prevents app crashes during order creation**

## Accomplishments

- Added try-catch blocks to all critical functions (handleAddItem, handleConfirmOrder, submitOrder)
- Created React Error Boundary component to catch rendering errors
- Added NaN validation for package constraints before modulo operations
- Added user-friendly error messages for all failure scenarios
- Added error handling for IndexedDB operations (QuotaExceededError, InvalidStateError)
- Implemented graceful degradation for cache staleness check failures
- Validated required fields (customerId, draftItems) before submission

## Files Created

- `archibald-web-app/frontend/src/components/ErrorBoundary.tsx` - React Error Boundary for rendering errors

## Files Modified

- `archibald-web-app/frontend/src/components/OrderForm.tsx` - Added comprehensive error handling to handleAddItem, handleConfirmOrder, submitOrder
- `archibald-web-app/frontend/src/App.tsx` - Wrapped OrderForm in ErrorBoundary

## Root Causes

Multiple potential crash points identified and fixed:
1. NaN in package constraints causing modulo operation to fail
2. Unhandled promise rejections in cache staleness check
3. Missing validation for empty customerId or draftItems
4. IndexedDB operations throwing without proper error handling
5. React rendering errors showing white screen instead of error message

## Fixes Applied

1. **NaN Validation**: Check multipleQty is valid number before modulo
2. **Promise Error Handling**: Wrapped isCacheStale() in try-catch with graceful fallback
3. **Required Field Validation**: Check customerId and draftItems.length before submission
4. **IndexedDB Error Handling**: Catch QuotaExceededError and InvalidStateError with user-friendly messages
5. **Error Boundary**: Catch React rendering errors and show recovery UI

## Issues Encountered

[Document any issues during testing, or "None"]

## Testing Results

- ‚úÖ Valid order creation works without crashes
- ‚úÖ Invalid package quantities show alert, no crash
- ‚úÖ Missing customer shows error, no crash
- ‚úÖ Empty order shows error, no crash
- ‚úÖ IndexedDB errors handled gracefully
- ‚úÖ Error Boundary catches rendering errors
- ‚úÖ No white screens in any scenario
- ‚úÖ User-friendly error messages displayed

## Next Step

Ready for 28.1-04-PLAN.md (Comprehensive Testing & Regression)
</output>
