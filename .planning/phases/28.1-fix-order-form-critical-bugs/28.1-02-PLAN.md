---
phase: 28.1-fix-order-form-critical-bugs
plan: 02
type: execute
---

<objective>
Fix product filtering bug where typing article code (e.g., "h129fsq.104.023") returns no results.

Purpose: Enable users to search and select products by article code - critical for order creation workflow.
Output: Working product search that filters by article code, showing matching products in dropdown.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.1-fix-order-form-critical-bugs/28.1-CONTEXT.md
@archibald-web-app/frontend/src/components/OrderForm.tsx
@archibald-web-app/frontend/src/services/cache-service.ts

**Root Cause Analysis (from CONTEXT.md):**
- Lines 691-711: filteredProducts uses product.article field for filtering
- If product.article is undefined/null, filter returns false (no match)
- Lines 635-643: Products mapped from cache with `article: p.article`
- If cache has products without article field, mapping preserves undefined
- Lines 650-661: API fallback may also return products without article field

**Key Decisions:**
- Phase 08-03: Dexie startsWithIgnoreCase() for indexed search, fallback contains() search
- Phase 08-03: Compound indexes on name/article fields for <100ms performance
- Phase 08-01: Dexie.js for IndexedDB abstraction

**Critical Files:**
- cache-service.ts (lines 70-130): searchProducts() method with article field logic
- OrderForm.tsx (lines 623-678): Product loading from cache/API
- OrderForm.tsx (lines 691-711): filteredProducts useMemo with article filtering
</context>

<tasks>

<task type="auto">
  <name>Task 1: Investigate IndexedDB schema and product data structure</name>
  <files>archibald-web-app/frontend/src/db/schema.ts, archibald-web-app/frontend/src/services/cache-service.ts</files>
  <action>
Add diagnostic logging to understand product data structure:

1. In cache-service.ts searchProducts() method (around line 95-102):
   ```typescript
   const products = await db.products
     .where("name")
     .startsWithIgnoreCase(query)
     .or("article")
     .startsWithIgnoreCase(query)
     .limit(limit)
     .toArray();

   // Add diagnostic logging
   console.log('[CacheService] searchProducts query:', query);
   console.log('[CacheService] Found products:', products.length);
   if (products.length > 0) {
     console.log('[CacheService] Sample product:', {
       id: products[0].id,
       name: products[0].name,
       article: products[0].article, // Check if this exists
       hasArticle: 'article' in products[0] && products[0].article !== undefined
     });
   }
   ```

2. In OrderForm.tsx product loading (around line 635-643):
   ```typescript
   const mappedProducts = cachedProducts.map((p) => {
     console.log('[Products] Mapping product:', {
       id: p.id,
       name: p.name,
       article: p.article,
       hasArticle: 'article' in p && p.article !== undefined
     });
     return {
       id: p.id,
       name: p.name,
       article: p.article, // Check what value this has
       description: p.description,
       groupCode: undefined,
       price: p.price,
       packageContent: p.variants[0]?.packageContent,
     };
   });
   ```

3. In filteredProducts useMemo (line 691-711):
   ```typescript
   console.log('[Filter] Computing filteredProducts', {
     productsLength: products.length,
     productSearch,
     firstProductArticle: products[0]?.article, // Check first product
     timestamp: Date.now()
   });
   ```

This will show us if the article field exists and has data.
  </action>
  <verify>
1. Open browser console
2. Load order form page
3. Check logs showing product data structure
4. Confirm whether products have article field populated
5. Try typing "h129" in product search and check filtered results in logs
  </verify>
  <done>Diagnostic logs show whether article field exists and is populated in products</done>
</task>

<task type="auto">
  <name>Task 2: Fix article field population from cache and API</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx, archibald-web-app/backend/src/routes/products.ts</files>
  <action>
Based on diagnostic findings, apply the appropriate fix:

**Fix A: If article field missing from cache (most likely)**

1. Check db/schema.ts products table definition - ensure article field is defined
2. If article field exists in schema but products don't have it, trigger a product sync:
   - Products may need to be re-synced from Archibald
   - The sync should populate the article field from PDF data (Phase 19 work)

3. Add fallback in OrderForm.tsx (lines 635-643):
   ```typescript
   const mappedProducts = cachedProducts.map((p) => ({
     id: p.id,
     name: p.name,
     article: p.article || p.id, // Fallback to ID if article missing
     description: p.description,
     groupCode: undefined,
     price: p.price,
     packageContent: p.variants[0]?.packageContent,
   }));
   ```

**Fix B: If API fallback doesn't return article field**

1. Check backend routes/products.ts GET /api/products endpoint
2. Ensure response includes article field in product objects
3. If missing, add it to the SELECT query or response mapping

**Fix C: If filtering logic is broken**

1. Update filteredProducts logic (lines 701-709) to handle undefined article:
   ```typescript
   return (
     (product.name && product.name.toLowerCase().includes(searchLower)) ||
     (product.article && product.article.toLowerCase().includes(searchLower)) ||
     (product.id && product.id.toLowerCase().includes(searchLower)) ||
     (product.description && product.description.toLowerCase().includes(searchLower))
   );
   ```
   Already has null-check, so this should work if article field exists.

**Most likely fix**: Article field needs to be populated in IndexedDB. If products were synced before Phase 19 (which extracts article from PDF), they won't have this field. Solution: Re-sync products or add migration to populate article from id.

DO NOT remove diagnostic logs yet.
AVOID changing product sync logic - that's Phase 19's responsibility.
  </action>
  <verify>
1. Check if article field is now populated
2. npm run dev
3. Type article code in product search (e.g., "h129fsq")
4. Verify dropdown shows matching products
5. Check console logs confirm article field present
  </verify>
  <done>Article field is populated, product search by article code returns results</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Fixed product article field population and filtering logic</what-built>
  <how-to-verify>
1. Run: `cd archibald-web-app/frontend && npm run dev`
2. Visit: http://localhost:5173
3. Navigate to order creation form
4. Test product filtering by article code:
   a. Click on "Nome Articolo" input field
   b. Type a partial article code: "h129"
   c. **EXPECTED**: Dropdown appears with matching products
   d. **EXPECTED**: Products with article codes starting with "h129" are shown
   e. Try full article code: "h129fsq.104.023"
   f. **EXPECTED**: Specific product appears if it exists
5. Test product filtering by name:
   a. Clear input field
   b. Type a product name (e.g., "vite")
   c. **EXPECTED**: Products with "vite" in name appear
6. Test edge cases:
   - Dots in article codes (XX.XX.XXX.XXX format)
   - Mixed case (H129 vs h129)
   - Partial codes (first few characters)
7. Check browser console:
   - Confirm article field is present in product objects
   - Confirm filteredProducts has correct length
   - Should NOT see errors
8. Select a product and verify:
   - Product details populate correctly
   - Price shows if available
   - Package content shows
  </how-to-verify>
  <resume-signal>Type "approved" if product filtering works correctly, or describe specific article codes that don't work</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Clean up diagnostic logging and add error handling</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx, archibald-web-app/frontend/src/services/cache-service.ts</files>
  <action>
1. Remove diagnostic console.log statements added in Task 1 from:
   - cache-service.ts searchProducts()
   - OrderForm.tsx product loading
   - OrderForm.tsx filteredProducts useMemo

2. Keep existing production logs:
   - "[Products] Loaded from cache:" (line 632)
   - "[Products] Set products state:" (line 646)
   - "[Products] onClick - products.length:" (lines 2131-2137)

3. Add defensive error handling for missing article field:
   ```typescript
   // In filteredProducts useMemo, ensure safe access
   const filteredProducts = useMemo(() => {
     if (!productSearch) return products;

     const searchLower = productSearch.toLowerCase();
     return products.filter((product) => {
       try {
         return (
           (product.name && product.name.toLowerCase().includes(searchLower)) ||
           (product.article && product.article.toLowerCase().includes(searchLower)) ||
           (product.id && product.id.toLowerCase().includes(searchLower)) ||
           (product.description && product.description.toLowerCase().includes(searchLower))
         );
       } catch (error) {
         console.error('[Products] Filter error for product:', product.id, error);
         return false;
       }
     });
   }, [products, productSearch]);
   ```

This ensures filtering never crashes even if data structure is unexpected.
  </action>
  <verify>
1. Search for diagnostic console.log statements - confirm removed
2. npm run build succeeds
3. No TypeScript errors
4. Error handling in place for unexpected data
  </verify>
  <done>Diagnostic logs removed, error handling added, build passes</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Products can be filtered by article code
- [ ] Typing partial article code shows matching products
- [ ] Full article code (e.g., h129fsq.104.023) returns correct product
- [ ] Article field is populated in product data
- [ ] No console errors during filtering
- [ ] Build succeeds without warnings
- [ ] Diagnostic logs cleaned up
</verification>

<success_criteria>
- All tasks completed
- User can search products by article code successfully
- Dropdown shows matching products for article code searches
- Edge cases handled (dots, mixed case, partial codes)
- Error handling prevents crashes with unexpected data
- Code is production-ready
</success_criteria>

<output>
After completion, create `.planning/phases/28.1-fix-order-form-critical-bugs/28.1-02-SUMMARY.md`:

# Phase 28.1 Plan 02: Fix Product Filtering Bug - Summary

**Product search by article code restored - users can now filter products by article codes**

## Accomplishments

- Identified article field population issue in IndexedDB products
- Fixed article field mapping from cache/API
- Added error handling for filtering to prevent crashes
- Verified article code search works with dots, mixed case, partial codes
- Product dropdown now shows matching products for article code searches

## Files Modified

- `archibald-web-app/frontend/src/components/OrderForm.tsx` - Fixed article field mapping, added error handling
- `archibald-web-app/frontend/src/services/cache-service.ts` - [if modified]
- `archibald-web-app/backend/src/routes/products.ts` - [if modified]

## Root Cause

Article field was not populated in IndexedDB products. Products synced before Phase 19 (PDF-based sync with article extraction) lacked the article field, causing filter logic to return no results when searching by article code.

## Fix Applied

[Document specific fix - e.g., "Added fallback to use product ID when article missing" or "Triggered product re-sync to populate article field" or "Fixed API to include article in response"]

## Issues Encountered

[Document any issues, or "None"]

## Testing Results

- ✅ Search by article code "h129fsq.104.023" returns correct product
- ✅ Partial article code "h129" shows all matching products
- ✅ Dots in article codes handled correctly (XX.XX.XXX.XXX format)
- ✅ Case-insensitive search works
- ✅ No console errors

## Next Step

Ready for 28.1-03-PLAN.md (Fix White Screen Crash)
</output>
