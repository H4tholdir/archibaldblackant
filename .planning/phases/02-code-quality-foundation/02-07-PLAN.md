---
phase: 02-code-quality-foundation
plan: 07
type: tdd
---

<objective>
Add comprehensive unit tests for database layer using TDD approach.

Purpose: Establish test coverage for critical data access layer, verify CRUD operations work correctly.
Output: Full unit test suite for CustomerDatabase and ProductDatabase classes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-code-quality-foundation/02-06-SUMMARY.md
@.planning/codebase/TESTING.md
@src/customer-db.ts
@src/product-db.ts

**Tech stack:**
- Vitest configured and ready
- better-sqlite3 for SQLite
- TypeScript with strict types

**From previous plans:**
- Vitest framework setup complete
- Database layer fully typed
- Ready for TDD implementation

**Testing approach:**
- Unit tests for database operations
- Use in-memory SQLite for speed (:memory:)
- Test CRUD operations, edge cases, error handling
</context>

<feature>
  <name>CustomerDatabase Unit Tests</name>
  <files>src/customer-db.ts, src/customer-db.test.ts</files>
  <behavior>
CustomerDatabase class operations:
- insertCustomers(customers[]) → inserts multiple customers
- getAllCustomers() → returns all customers
- searchCustomers(query) → returns filtered customers
- clearAll() → removes all customers
- getCount() → returns customer count

Test cases:
- Insert customers → customers retrievable
- Search by name → correct subset returned
- Search case-insensitive → finds matches
- Empty search → returns all
- Clear → count becomes 0
- Duplicate insert → handles gracefully (upsert or error)
  </behavior>
  <implementation>
RED: Write failing tests for all CustomerDatabase operations
GREEN: Tests should pass (CustomerDatabase already implemented)
REFACTOR: Clean up test code, extract test data factories if needed

Test structure:
```typescript
describe('CustomerDatabase', () => {
  let db: CustomerDatabase;

  beforeEach(() => {
    db = new CustomerDatabase(':memory:'); // Fresh DB each test
  });

  afterEach(() => {
    db.close();
  });

  it('should insert and retrieve customers', () => { ... });
  it('should search customers by name', () => { ... });
  it('should handle empty search', () => { ... });
  // ... more tests
});
```
  </implementation>
</feature>

<feature>
  <name>ProductDatabase Unit Tests</name>
  <files>src/product-db.ts, src/product-db.test.ts</files>
  <behavior>
ProductDatabase class operations:
- insertProducts(products[]) → inserts multiple products
- getAllProducts() → returns all products
- searchProducts(query) → returns filtered products
- getProductByCode(code) → returns specific product
- insertPrices(prices[]) → inserts price list
- getPriceForArticle(articleCode) → returns price
- clearAll() → removes all data

Test cases:
- Insert products → products retrievable
- Search by article code → correct matches
- Get product by code → returns correct product
- Get product by code (not found) → returns null
- Insert prices → prices retrievable
- Get price for article → correct price returned
- Get price (not found) → returns null
- Clear → counts become 0
  </behavior>
  <implementation>
RED: Write failing tests for all ProductDatabase operations
GREEN: Tests should pass (ProductDatabase already implemented)
REFACTOR: Extract common test setup, create product/price factories

Test structure:
```typescript
describe('ProductDatabase', () => {
  let db: ProductDatabase;

  beforeEach(() => {
    db = new ProductDatabase(':memory:');
  });

  afterEach(() => {
    db.close();
  });

  describe('product operations', () => {
    it('should insert and retrieve products', () => { ... });
    it('should search products by code', () => { ... });
    it('should get product by code', () => { ... });
  });

  describe('price operations', () => {
    it('should insert and retrieve prices', () => { ... });
    it('should get price for article', () => { ... });
  });
});
```
  </implementation>
</feature>

<verification>
- [ ] All CustomerDatabase tests pass
- [ ] All ProductDatabase tests pass
- [ ] npm test shows green
- [ ] Test coverage for database layer established
</verification>

<success_criteria>
- RED phase: Failing tests written and committed
- GREEN phase: Implementation passes tests
- REFACTOR phase: Tests cleaned up (if needed)
- All 2-3 commits present (test, feat, optional refactor)
- Database operations fully tested
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-quality-foundation/02-07-SUMMARY.md`:

# Phase 2 Plan 07: Unit Tests for Database Layer

**Database layer fully tested - [X] unit tests covering CRUD operations**

## Accomplishments

### RED - Failing Tests
- Wrote failing tests for CustomerDatabase
- Wrote failing tests for ProductDatabase
- [Why tests failed initially, if implementation bugs found]

### GREEN - Passing Implementation
- All CustomerDatabase tests pass
- All ProductDatabase tests pass
- [Any implementation fixes needed]

### REFACTOR - Cleanup
- [Test code improvements, or "None needed"]
- [Test factories extracted, or "Tests remain simple"]

## Commits
- `test(02-07): add failing tests for database layer`
- `feat(02-07): [any implementation fixes, or "tests pass"]`
- `refactor(02-07): [cleanup if done]`

## Files Created/Modified

- `src/customer-db.test.ts` - Full test suite
- `src/product-db.test.ts` - Full test suite
- `src/customer-db.ts` - [any fixes]
- `src/product-db.ts` - [any fixes]

## Decisions Made

[Document any decisions about test structure, mocking strategy, or in-memory DB]

## Issues Encountered

[Document any problems and resolutions, or "None"]

## Next Step

Ready for 02-08-PLAN.md (Integration Tests for Sync Services)
</output>
