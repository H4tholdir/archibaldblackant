---
phase: 02-code-quality-foundation
plan: 05
type: execute
---

<objective>
Remove remaining type any from sync services and archibald-bot.

Purpose: Complete strict typing migration across all backend code.
Output: Zero type any in production code, full TypeScript type safety achieved.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-code-quality-foundation/02-04-SUMMARY.md
@src/customer-sync-service.ts
@src/product-sync-service.ts
@src/price-sync-service.ts
@src/archibald-bot.ts

**From previous plans:**
- Database layer fully typed (0 type any)
- Types available in types.ts and schemas.ts

**Remaining work:**
- Sync services likely have any for Puppeteer page interactions
- archibald-bot.ts has complex automation with dynamic selectors
- Final cleanup across all services
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove type any from sync services</name>
  <files>src/customer-sync-service.ts, src/product-sync-service.ts, src/price-sync-service.ts</files>
  <action>
For each sync service:
- Identify all `: any` occurrences
- Replace with proper types:
  - Puppeteer ElementHandle types from 'puppeteer'
  - Page, Browser types where needed
  - Database result types (Customer[], Product[], etc.)
  - Use unknown for truly dynamic scraped data, then narrow with type guards
- Add explicit return types to all methods
- Use type assertions only when necessary (e.g., after validation)

Example patterns:
- `const element: any` → `const element: ElementHandle<Element> | null`
- `function parse(data: any)` → `function parse(data: unknown): ParsedResult`
- `const result: any` → `const result: Customer[]`

DO NOT change business logic or scraping logic, only strengthen types.
  </action>
  <verify>grep ": any" src/*-sync-service.ts returns empty</verify>
  <done>No type any in sync services, all operations properly typed</done>
</task>

<task type="auto">
  <name>Task 2: Remove type any from archibald-bot.ts</name>
  <files>src/archibald-bot.ts</files>
  <action>
Replace type any in archibald-bot.ts:
- Puppeteer types: Page, Browser, ElementHandle, Frame
- Selector results: ElementHandle<Element> | null
- Navigation results: HTTPResponse | null
- Dynamic DOM queries: use unknown then type guards
- Error objects: Error or unknown in catch blocks
- Configuration: explicit config object types

This file is complex - use unknown for scraped data, then narrow:
```typescript
const rawValue: unknown = await element.evaluate(el => el.textContent);
if (typeof rawValue === 'string') {
  // Now safely use rawValue as string
}
```

Add explicit return types to all methods.
DO NOT change automation logic, selectors, or navigation flow.
  </action>
  <verify>grep ": any" src/archibald-bot.ts --exclude="*.backup*" returns empty</verify>
  <done>No type any in archibald-bot.ts (excluding backups), full typing achieved</done>
</task>

<task type="auto">
  <name>Task 3: Final type any verification across all backend code</name>
  <files>N/A</files>
  <action>
Run comprehensive verification:
1. Count type any: `grep -r ": any" src/ --exclude="*.backup*" --exclude="scripts/" | wc -l` (target: 0)
2. List any remaining: `grep -r ": any" src/ --exclude="*.backup*" --exclude="scripts/"`
3. TypeScript strict compilation: `npx tsc --noEmit` (must pass)
4. Verify no implicit any errors: check tsconfig.json has `noImplicitAny: true`

If any `: any` remains in production code (src/, excluding backups and test scripts):
- Document why it's necessary, or
- Replace with proper type

Success: 0 type any in production code, TypeScript strict passes.
  </action>
  <verify>grep shows 0 type any in src/ (excluding backups/scripts), npx tsc --noEmit passes</verify>
  <done>Zero type any in backend, full type safety achieved, TypeScript strict verified</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] No type any in customer-sync-service.ts
- [ ] No type any in product-sync-service.ts
- [ ] No type any in price-sync-service.ts
- [ ] No type any in archibald-bot.ts (excluding backups)
- [ ] TypeScript compilation passes
- [ ] Grep shows 0 type any in production code
</verification>

<success_criteria>
- All 3 tasks completed
- Zero type any in all production code
- TypeScript strict mode passes
- Full type safety achieved
- No functionality regressions
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-quality-foundation/02-05-SUMMARY.md`:

# Phase 2 Plan 05: Remove type any in Services & Bot

**TypeScript strict typing complete - zero type any in production code**

## Accomplishments

- Removed type any from all sync services
- Removed type any from archibald-bot.ts
- Final verification confirms 0 type any
- Full TypeScript type safety achieved
- Puppeteer operations properly typed

## Files Created/Modified

- `src/customer-sync-service.ts` - Full typing
- `src/product-sync-service.ts` - Full typing
- `src/price-sync-service.ts` - Full typing
- `src/archibald-bot.ts` - Full typing

## Decisions Made

[Document any decisions about unknown vs any, type guards, or type assertions]

## Issues Encountered

[Document any problems and resolutions, or "None"]

## Next Step

Ready for 02-06-PLAN.md (Remove Dead Code)
</output>
