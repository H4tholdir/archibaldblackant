---
phase: 06-multi-user-authentication
plan: 01
type: execute
---

<objective>
Research Puppeteer multi-session patterns and design per-user session architecture.

Purpose: Choose the right multi-user browser session strategy before implementation to avoid costly refactoring later. Decision between BrowserContext pooling vs on-demand creation affects performance, memory usage, and code complexity.

Output: Architecture decision document with chosen approach, database schema design, and API flow design ready for implementation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/ARCHITECTURE.md
@.planning/codebase/STACK.md
@archibald-web-app/backend/src/session-manager.ts
@archibald-web-app/backend/src/browser-pool.ts
@archibald-web-app/backend/src/archibald-bot.ts

**Current Architecture:**
- SessionManager: Single-user cookie caching (24h TTL)
- BrowserPool: Shared browser instances (min=1, max=3)
- ArchibaldBot: Single global session

**Tech Available:**
- Puppeteer 22.0.0 with BrowserContext API
- SQLite (better-sqlite3 12.5.0) for user database
- JWT libraries (jsonwebtoken or jose)

**Established Patterns:**
- Singleton pattern for service managers
- EventEmitter for lifecycle events
- Resource pool pattern for browser management

**Constraint:**
- Must maintain session isolation between users (security critical)
- Must handle concurrent orders from multiple users
- Backend does NOT store Archibald credentials (session-per-request model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research Puppeteer multi-user session patterns</name>
  <files>.planning/phases/06-multi-user-authentication/06-01-RESEARCH.md</files>
  <action>
    Research and document Puppeteer multi-session approaches:

    1. **BrowserContext API**: Read Puppeteer docs on Browser.createBrowserContext() vs separate Browser instances
    2. **Cookie isolation**: Verify BrowserContexts provide complete cookie isolation
    3. **Performance trade-offs**: Document memory/CPU impact of multiple BrowserContexts vs multiple Browsers
    4. **Session persistence**: How to cache cookies per-user with BrowserContexts

    Create RESEARCH.md documenting:
    - Option A: BrowserContext pooling (one Browser, N contexts, cookie cache per userId)
    - Option B: On-demand BrowserContext creation (create/destroy on each login/logout)
    - Option C: Separate Browser per user (heavy, highest isolation)

    For each option document: pros, cons, memory impact, performance impact, code complexity.

    DO NOT implement code yet - this is pure research.
  </action>
  <verify>cat .planning/phases/06-multi-user-authentication/06-01-RESEARCH.md shows 3 options with pros/cons</verify>
  <done>RESEARCH.md created with detailed comparison of 3 multi-user session approaches</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <decision>Select multi-user browser session architecture</decision>
  <context>
    We need to choose how to manage browser sessions for multiple users. This is a foundational decision that affects all subsequent plans in Phase 6.

    Based on research in Task 1, we have 3 options with different trade-offs.
  </context>
  <options>
    <option id="browsercontext-pooling">
      <name>BrowserContext Pooling (Recommended)</name>
      <pros>
        - Best memory efficiency (one Browser, multiple contexts)
        - Fast context creation (~100ms vs ~3s for Browser)
        - Complete cookie isolation between users
        - Can reuse contexts after logout (clear cookies)
        - Fits existing BrowserPool pattern
      </pros>
      <cons>
        - More complex pool management (track userId → context mapping)
        - Requires refactoring existing BrowserPool
        - Potential memory leak if contexts not properly cleaned
      </cons>
    </option>
    <option id="on-demand-creation">
      <name>On-Demand BrowserContext Creation</name>
      <pros>
        - Simplest implementation (create on login, destroy on logout)
        - No pool management needed
        - Guaranteed clean state per login
      </pros>
      <cons>
        - Slower login (create context every time)
        - No session persistence between logins
        - Higher resource usage if many users login/logout frequently
      </cons>
    </option>
    <option id="separate-browser">
      <name>Separate Browser Per User</name>
      <pros>
        - Maximum isolation (separate processes)
        - Easiest to debug per-user issues
      </pros>
      <cons>
        - Very heavy memory usage (~100-150MB per Browser)
        - Slow initialization (~3-5s per login)
        - Does not scale beyond 5-10 concurrent users
        - Overkill for our use case
      </cons>
    </option>
  </options>
  <resume-signal>Select: browsercontext-pooling, on-demand-creation, or separate-browser</resume-signal>
</task>

<task type="auto">
  <name>Task 3: Design database schema and API flow</name>
  <files>.planning/phases/06-multi-user-authentication/06-01-ARCHITECTURE.md</files>
  <action>
    Based on the chosen architecture from Task 2, design:

    **1. Database Schema** (SQLite):
    ```sql
    CREATE TABLE users (
      id TEXT PRIMARY KEY,  -- UUID
      username TEXT UNIQUE NOT NULL,  -- Archibald username
      fullName TEXT NOT NULL,
      whitelisted INTEGER NOT NULL DEFAULT 1,  -- 1 = authorized, 0 = blocked
      createdAt INTEGER NOT NULL,
      lastLoginAt INTEGER,
      CONSTRAINT unique_username UNIQUE (username)
    );
    ```

    **2. SessionCache Schema** (per chosen architecture):
    - If BrowserContext pooling: userId → contextId → cookies mapping
    - If on-demand: userId → temporary cookies (cleared on logout)

    **3. API Flow** (document in ARCHITECTURE.md):
    - POST /api/auth/login: Validate username in whitelist → test Puppeteer login → return JWT
    - POST /api/auth/logout: Clear user session → close BrowserContext
    - GET /api/auth/me: Verify JWT → return user info
    - Protected routes: JWT middleware extracts userId, passes to services

    **4. JWT Structure**:
    ```json
    {
      "userId": "uuid",
      "username": "mario.rossi",
      "iat": timestamp,
      "exp": timestamp + 8h
    }
    ```

    Include sequence diagrams for:
    - Login flow (frontend → backend → Puppeteer → JWT)
    - Order creation flow (JWT → userId → user's BrowserContext → Archibald)
    - Logout flow (JWT → cleanup user session)

    Use jose library instead of jsonwebtoken (better ESM support, no CommonJS issues).
  </action>
  <verify>cat .planning/phases/06-multi-user-authentication/06-01-ARCHITECTURE.md shows complete schema + API flow + sequence diagrams</verify>
  <done>ARCHITECTURE.md created with database schema, session cache design, API flow, JWT structure, and sequence diagrams</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] RESEARCH.md exists with 3 options documented
- [ ] Architecture decision made and recorded
- [ ] ARCHITECTURE.md exists with schema, API flow, diagrams
- [ ] No code written (research and design phase only)
</verification>

<success_criteria>

- All tasks completed
- Architecture decision documented
- Database schema designed (users table)
- Session cache strategy defined based on chosen architecture
- API endpoints designed (login, logout, me, JWT middleware)
- JWT structure defined (using jose library)
- Sequence diagrams created for main flows
- Ready for Plan 06-02 (User Database & Whitelist Backend)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-multi-user-authentication/06-01-SUMMARY.md`:

# Phase 6 Plan 1: Research & Architecture Design Summary

**Multi-user session architecture chosen and documented**

## Accomplishments

- Researched 3 Puppeteer multi-session patterns (BrowserContext pooling, on-demand, separate Browser)
- Architecture decision: [chosen option from checkpoint]
- Database schema designed (users table with whitelist)
- Session cache strategy defined for chosen architecture
- API flow designed (login, logout, me endpoints + JWT middleware)
- JWT structure defined (8h expiry, jose library)
- Sequence diagrams created for login, order creation, logout flows

## Files Created

- `.planning/phases/06-multi-user-authentication/06-01-RESEARCH.md` - Multi-session research
- `.planning/phases/06-multi-user-authentication/06-01-ARCHITECTURE.md` - Full architecture design

## Decisions Made

- **Session Architecture**: [BrowserContext pooling / on-demand / separate Browser]
- **JWT Library**: jose (better ESM support than jsonwebtoken)
- **Session Duration**: 8 hours JWT expiry
- **Cookie Cache**: [per chosen architecture - userId mapping strategy]

## Issues Encountered

None (design phase only)

## Next Step

Ready for Plan 06-02: User Database & Whitelist Backend implementation
</output>
