---
phase: 06-multi-user-authentication
plan: 03
type: execute
---

<objective>
Implement authentication backend with JWT and Puppeteer login validation.

Purpose: Enable user login with Archibald credentials, validate via actual Puppeteer login test, return JWT token for authenticated sessions.

Output: Working POST /api/auth/login endpoint that validates credentials against Archibald, POST /api/auth/logout endpoint, JWT middleware for protected routes, JWT-based authentication system ready for frontend integration.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-multi-user-authentication/06-01-ARCHITECTURE.md
@.planning/phases/06-multi-user-authentication/06-02-SUMMARY.md
@archibald-web-app/backend/src/user-db.ts
@archibald-web-app/backend/src/archibald-bot.ts
@archibald-web-app/backend/src/session-manager.ts

**Architecture from Plan 06-01:**
- JWT structure: { userId, username, iat, exp } (8h expiry)
- Library choice: jose (better ESM support)
- Login flow: Check whitelist → Test Puppeteer login → Return JWT
- Backend does NOT store credentials

**From Plan 06-02:**
- UserDatabase.getUserByUsername(username) available
- UserDatabase.updateLastLogin(userId) available
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install jose and create JWT utilities</name>
  <files>archibald-web-app/backend/package.json, archibald-web-app/backend/src/auth-utils.ts</files>
  <action>
    1. Install jose library:
    ```bash
    cd archibald-web-app/backend && npm install jose
    ```

    2. Create `backend/src/auth-utils.ts`:
    ```typescript
    import * as jose from 'jose';
    import { logger } from './logger';

    const JWT_SECRET = new TextEncoder().encode(
      process.env.JWT_SECRET || 'dev-secret-key-change-in-production'
    );
    const JWT_ALGORITHM = 'HS256';
    const JWT_EXPIRY = '8h';

    export interface JWTPayload {
      userId: string;
      username: string;
    }

    export async function generateJWT(payload: JWTPayload): Promise<string> {
      const jwt = await new jose.SignJWT({ ...payload })
        .setProtectedHeader({ alg: JWT_ALGORITHM })
        .setIssuedAt()
        .setExpirationTime(JWT_EXPIRY)
        .sign(JWT_SECRET);
      return jwt;
    }

    export async function verifyJWT(token: string): Promise<JWTPayload | null> {
      try {
        const { payload } = await jose.jwtVerify(token, JWT_SECRET);
        return {
          userId: payload.userId as string,
          username: payload.username as string,
        };
      } catch (error) {
        logger.warn('JWT verification failed', { error });
        return null;
      }
    }
    ```

    Add JWT_SECRET to `backend/.env.example`:
    ```
    JWT_SECRET=your-secret-key-here
    ```

    DO NOT commit actual JWT_SECRET to .env - document this as security requirement.
  </action>
  <verify>npm run build succeeds, auth-utils.ts exports generateJWT and verifyJWT functions</verify>
  <done>jose installed, auth-utils.ts created with JWT generation and verification</done>
</task>

<task type="auto">
  <name>Task 2: Create POST /api/auth/login endpoint</name>
  <files>archibald-web-app/backend/src/index.ts, archibald-web-app/backend/src/schemas.ts</files>
  <action>
    Add login endpoint to `backend/src/index.ts`:

    ```typescript
    app.post("/api/auth/login", async (req, res) => {
      try {
        // 1. Validate request
        const result = loginSchema.safeParse(req.body);
        if (!result.success) {
          return res.status(400).json({
            success: false,
            error: "Invalid request format"
          });
        }

        const { username, password } = result.data;

        // 2. Check user exists and is whitelisted
        const userDb = UserDatabase.getInstance();
        const user = userDb.getUserByUsername(username);

        if (!user) {
          logger.warn(`Login attempt for non-existent user: ${username}`);
          return res.status(401).json({
            success: false,
            error: "Invalid credentials or user not authorized"
          });
        }

        if (!user.whitelisted) {
          logger.warn(`Login attempt for non-whitelisted user: ${username}`);
          return res.status(403).json({
            success: false,
            error: "User not authorized"
          });
        }

        // 3. Test login with Puppeteer
        logger.info(`Testing Archibald login for user: ${username}`);
        const bot = new ArchibaldBot();

        try {
          await bot.initialize();

          // Override bot's credentials with user's credentials
          // DO NOT save these credentials anywhere - use only for this login test
          const loginSuccess = await bot.loginWithCredentials(username, password);

          if (!loginSuccess) {
            await bot.close();
            logger.warn(`Archibald login failed for user: ${username}`);
            return res.status(401).json({
              success: false,
              error: "Invalid Archibald credentials"
            });
          }

          // Close bot after successful validation (don't keep session for security)
          await bot.close();

        } catch (error) {
          await bot.close().catch(() => {});
          logger.error(`Error during Puppeteer login test`, { error, username });
          return res.status(500).json({
            success: false,
            error: "Login service unavailable"
          });
        }

        // 4. Update lastLogin timestamp
        userDb.updateLastLogin(user.id);

        // 5. Generate JWT
        const token = await generateJWT({
          userId: user.id,
          username: user.username
        });

        logger.info(`Login successful for user: ${username}`);
        res.json({
          success: true,
          token,
          user: {
            id: user.id,
            username: user.username,
            fullName: user.fullName,
          }
        });

      } catch (error) {
        logger.error("Login error", { error });
        res.status(500).json({ success: false, error: "Internal server error" });
      }
    });
    ```

    Add Zod schema to `schemas.ts`:
    ```typescript
    export const loginSchema = z.object({
      username: z.string().min(1),
      password: z.string().min(1),
    });
    ```

    Add `loginWithCredentials(username, password)` method to ArchibaldBot class (if not exists):
    - Navigate to Archibald login page
    - Fill username and password fields
    - Submit form
    - Check if login succeeded (no error message, dashboard visible)
    - Return boolean success/failure

    CRITICAL: DO NOT store password anywhere. Use only for immediate validation, then discard.
  </action>
  <verify>
    curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"username":"test","password":"wrong"}' returns 401
    curl -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"username":"test","password":"correct"}' returns 200 with JWT token
  </verify>
  <done>POST /api/auth/login endpoint working, validates whitelist + Archibald credentials, returns JWT on success</done>
</task>

<task type="auto">
  <name>Task 3: Create JWT middleware and logout endpoint</name>
  <files>archibald-web-app/backend/src/middleware/auth.ts, archibald-web-app/backend/src/index.ts</files>
  <action>
    1. Create `backend/src/middleware/auth.ts`:
    ```typescript
    import { Request, Response, NextFunction } from 'express';
    import { verifyJWT } from '../auth-utils';
    import { logger } from '../logger';

    export interface AuthRequest extends Request {
      user?: {
        userId: string;
        username: string;
      };
    }

    export async function authenticateJWT(
      req: AuthRequest,
      res: Response,
      next: NextFunction
    ) {
      const authHeader = req.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        return res.status(401).json({ error: 'No token provided' });
      }

      const token = authHeader.split(' ')[1];
      const payload = await verifyJWT(token);

      if (!payload) {
        return res.status(401).json({ error: 'Invalid or expired token' });
      }

      req.user = payload;
      next();
    }
    ```

    2. Add logout endpoint to `backend/src/index.ts`:
    ```typescript
    app.post("/api/auth/logout", authenticateJWT, async (req: AuthRequest, res) => {
      // For now, logout is client-side (remove JWT from localStorage)
      // When we implement per-user BrowserContexts (Plan 06-05),
      // we'll close the user's context here
      logger.info(`User logged out: ${req.user?.username}`);
      res.json({ success: true });
    });
    ```

    3. Add GET /api/auth/me endpoint for profile:
    ```typescript
    app.get("/api/auth/me", authenticateJWT, async (req: AuthRequest, res) => {
      const userDb = UserDatabase.getInstance();
      const user = userDb.getUserById(req.user!.userId);

      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      res.json({
        success: true,
        user: {
          id: user.id,
          username: user.username,
          fullName: user.fullName,
          whitelisted: user.whitelisted,
          lastLoginAt: user.lastLoginAt,
        }
      });
    });
    ```

    Update POST /api/orders/create to use authenticateJWT middleware (will be used in Plan 06-06).
  </action>
  <verify>
    curl -X GET http://localhost:3000/api/auth/me -H "Authorization: Bearer invalid-token" returns 401
    curl -X GET http://localhost:3000/api/auth/me -H "Authorization: Bearer {valid-token}" returns 200 with user data
    curl -X POST http://localhost:3000/api/auth/logout -H "Authorization: Bearer {valid-token}" returns 200
  </verify>
  <done>JWT middleware created, /api/auth/logout and /api/auth/me endpoints working, authentication layer ready</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] jose installed and imported
- [ ] auth-utils.ts exports generateJWT and verifyJWT
- [ ] POST /api/auth/login validates whitelist + Puppeteer credentials
- [ ] Login returns JWT token on success, 401 on invalid credentials, 403 on non-whitelisted
- [ ] JWT middleware authenticateJWT protects routes
- [ ] POST /api/auth/logout works
- [ ] GET /api/auth/me returns user profile
- [ ] No credentials stored in database or logs
</verification>

<success_criteria>

- All tasks completed
- JWT authentication system functional
- Login validates Archibald credentials via Puppeteer
- JWT middleware protects routes
- Logout and profile endpoints working
- No passwords stored anywhere (security requirement met)
- Ready for Plan 06-04 (Login UI & Frontend Auth State)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-multi-user-authentication/06-03-SUMMARY.md`:

# Phase 6 Plan 3: Authentication Backend & JWT Summary

**JWT-based authentication with Puppeteer credential validation operational**

## Accomplishments

- Installed jose library and created JWT utilities (generate, verify)
- Implemented POST /api/auth/login with whitelist check + Puppeteer validation
- Created JWT middleware (authenticateJWT) for protected routes
- Built POST /api/auth/logout and GET /api/auth/me endpoints
- Added loginWithCredentials() method to ArchibaldBot

## Files Created/Modified

- `archibald-web-app/backend/src/auth-utils.ts` - JWT generation/verification
- `archibald-web-app/backend/src/middleware/auth.ts` - JWT middleware
- `archibald-web-app/backend/src/index.ts` - Added auth endpoints (login, logout, me)
- `archibald-web-app/backend/src/schemas.ts` - Added loginSchema
- `archibald-web-app/backend/src/archibald-bot.ts` - Added loginWithCredentials method
- `archibald-web-app/backend/.env.example` - Added JWT_SECRET

## Decisions Made

- JWT library: jose (better ESM support)
- JWT expiry: 8 hours
- Login validation: Actual Puppeteer login test (not password hash comparison)
- No credential storage: Passwords used only for immediate validation, then discarded
- JWT format: { userId, username, iat, exp }

## Issues Encountered

None

## Next Step

Ready for Plan 06-04: Login UI & Frontend Auth State implementation
</output>
