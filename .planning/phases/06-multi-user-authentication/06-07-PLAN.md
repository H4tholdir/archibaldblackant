---
phase: 06-multi-user-authentication
plan: 07
type: execute
---

<objective>
Implement session cleanup, add logout integration, and test complete multi-user scenarios.

Purpose: Ensure proper cleanup of user sessions on logout, verify session isolation, test concurrent multi-user scenarios to confirm Phase 6 is production-ready.

Output: Logout properly closes user's BrowserContext, session expiry logic functional, comprehensive testing of multi-user flows complete, documentation updated, Phase 6 complete and ready for production.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-multi-user-authentication/06-06-SUMMARY.md
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/browser-pool.ts

**From Plan 06-05:**
- BrowserPool.closeUserContext(userId) available
- SessionCacheManager.clearSession(userId) available

**From Plan 06-03:**
- POST /api/auth/logout endpoint exists but doesn't cleanup session yet
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement session cleanup on logout</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
    Update POST /api/auth/logout to cleanup user's BrowserContext:

    ```typescript
    app.post("/api/auth/logout", authenticateJWT, async (req: AuthRequest, res) => {
      const userId = req.user!.userId;
      const username = req.user!.username;

      try {
        // Close user's BrowserContext and clear cached session
        const pool = BrowserPool.getInstance();
        await pool.closeUserContext(userId);

        logger.info(`User ${username} logged out, session cleaned up`, { userId });

        res.json({ success: true });
      } catch (error) {
        logger.error(`Error during logout cleanup for user ${username}`, {
          error,
          userId,
        });
        // Even if cleanup fails, return success to client
        // (client will discard JWT anyway)
        res.json({ success: true });
      }
    });
    ```

    This ensures:
    - User's BrowserContext is closed (frees memory)
    - Cached cookies are cleared from .cache/
    - Next login will create fresh session
  </action>
  <verify>
    curl -X POST http://localhost:3000/api/auth/logout -H "Authorization: Bearer {token}" returns 200
    Check backend logs show "session cleaned up"
    Check .cache/session-{userId}.json is deleted
  </verify>
  <done>Logout endpoint cleanup implemented, closes BrowserContext and clears cache</done>
</task>

<task type="auto">
  <name>Task 2: Add session expiry background job</name>
  <files>archibald-web-app/backend/src/session-cleanup-job.ts, archibald-web-app/backend/src/index.ts</files>
  <action>
    Create `backend/src/session-cleanup-job.ts`:

    ```typescript
    import { SessionCacheManager } from './session-cache-manager';
    import { BrowserPool } from './browser-pool';
    import { logger } from './logger';
    import fs from 'fs';
    import path from 'path';

    /**
     * Background job to cleanup expired sessions
     * Runs every 1 hour
     */
    export class SessionCleanupJob {
      private intervalId: NodeJS.Timeout | null = null;
      private readonly CLEANUP_INTERVAL_MS = 60 * 60 * 1000; // 1 hour

      start(): void {
        logger.info('Starting session cleanup job (runs every 1 hour)');

        this.intervalId = setInterval(() => {
          this.cleanup();
        }, this.CLEANUP_INTERVAL_MS);

        // Run immediately on start
        this.cleanup();
      }

      stop(): void {
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
          logger.info('Session cleanup job stopped');
        }
      }

      private async cleanup(): Promise<void> {
        try {
          logger.info('Running session cleanup job...');

          const cacheDir = path.join(__dirname, '..', '.cache');
          if (!fs.existsSync(cacheDir)) {
            return;
          }

          const files = fs.readdirSync(cacheDir).filter(f => f.startsWith('session-'));
          let expiredCount = 0;

          for (const file of files) {
            const filePath = path.join(cacheDir, file);
            try {
              const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));

              if (Date.now() > data.expiresAt) {
                // Session expired
                const userId = data.userId;
                fs.unlinkSync(filePath);

                // Close BrowserContext if still open
                const pool = BrowserPool.getInstance();
                await pool.closeUserContext(userId);

                expiredCount++;
                logger.info(`Cleaned up expired session for user ${userId}`);
              }
            } catch (error) {
              logger.warn(`Error cleaning up session file ${file}`, { error });
              // Delete corrupted file
              fs.unlinkSync(filePath);
            }
          }

          logger.info(`Session cleanup complete`, {
            totalSessions: files.length,
            expiredSessions: expiredCount,
          });

        } catch (error) {
          logger.error('Error in session cleanup job', { error });
        }
      }
    }
    ```

    Add to `backend/src/index.ts` server startup:
    ```typescript
    import { SessionCleanupJob } from './session-cleanup-job';

    // After server starts
    const sessionCleanup = new SessionCleanupJob();
    sessionCleanup.start();

    // In SIGINT handler
    process.on('SIGINT', async () => {
      logger.info("SIGINT ricevuto, shutdown graceful...");
      sessionCleanup.stop();
      // ... existing shutdown code
    });
    ```

    This ensures expired sessions are automatically cleaned up even if user doesn't logout.
  </action>
  <verify>npm run build succeeds, SessionCleanupJob starts on server startup</verify>
  <done>Session expiry background job implemented, cleans up expired sessions every hour</done>
</task>

<task type="auto">
  <name>Task 3: Create multi-user test script</name>
  <files>archibald-web-app/backend/src/scripts/test-multi-user.ts</files>
  <action>
    Create comprehensive test script `backend/src/scripts/test-multi-user.ts`:

    ```typescript
    import { BrowserPool } from '../browser-pool';
    import { SessionCacheManager } from '../session-cache-manager';
    import { ArchibaldBot } from '../archibald-bot';
    import { logger } from '../logger';

    /**
     * Test multi-user session isolation
     * Verifies that different users have completely isolated sessions
     */
    async function testMultiUserSessions() {
      logger.info('=== Multi-User Session Test ===');

      const userIds = ['user-1', 'user-2', 'user-3'];
      const pool = BrowserPool.getInstance();

      try {
        // Test 1: Acquire contexts for multiple users
        logger.info('Test 1: Acquiring contexts for 3 users...');
        const contexts = await Promise.all(
          userIds.map(userId => pool.acquireContext(userId))
        );
        logger.info('✓ All 3 contexts acquired');

        // Test 2: Verify separate pages with different sessions
        logger.info('Test 2: Creating pages for each user...');
        const pages = await Promise.all(
          contexts.map(context => context.newPage())
        );

        for (let i = 0; i < pages.length; i++) {
          const cookies = await pages[i].cookies();
          logger.info(`User ${userIds[i]} has ${cookies.length} cookies`);
        }

        // Test 3: Close pages
        await Promise.all(pages.map(page => page.close()));
        logger.info('✓ All pages closed');

        // Test 4: Release contexts
        for (let i = 0; i < userIds.length; i++) {
          await pool.releaseContext(userIds[i], contexts[i], true);
        }
        logger.info('✓ All contexts released');

        // Test 5: Re-acquire contexts (should reuse from pool)
        logger.info('Test 5: Re-acquiring contexts (should reuse)...');
        const stats1 = pool.getStats();
        logger.info(`Stats before re-acquire: ${JSON.stringify(stats1)}`);

        const context1Again = await pool.acquireContext(userIds[0]);
        const stats2 = pool.getStats();
        logger.info(`Stats after re-acquire: ${JSON.stringify(stats2)}`);
        logger.info('✓ Context reused successfully');

        // Test 6: Close user context (logout simulation)
        logger.info('Test 6: Closing user context (logout)...');
        await pool.closeUserContext(userIds[0]);
        const stats3 = pool.getStats();
        logger.info(`Stats after close: ${JSON.stringify(stats3)}`);
        logger.info('✓ User context closed');

        // Test 7: Verify session cache files
        logger.info('Test 7: Checking session cache files...');
        const sessionCache = SessionCacheManager.getInstance();
        for (const userId of userIds.slice(1)) {  // user-1 was closed
          const hasSession = await sessionCache.hasValidSession(userId);
          logger.info(`User ${userId} has cached session: ${hasSession}`);
        }
        logger.info('✓ Session cache verification complete');

        logger.info('\n=== All tests passed! ===');

      } catch (error) {
        logger.error('Test failed', { error });
      } finally {
        await pool.shutdown();
      }
    }

    testMultiUserSessions().catch(console.error);
    ```

    Add npm script:
    ```json
    "test:multi-user": "tsx src/scripts/test-multi-user.ts"
    ```

    Run the test to verify multi-user isolation.
  </action>
  <verify>npm run test:multi-user completes successfully, all tests pass</verify>
  <done>Multi-user test script created, verifies session isolation and context management</done>
</task>

<task type="auto">
  <name>Task 4: Update documentation</name>
  <files>.planning/codebase/ARCHITECTURE.md, archibald-web-app/README.md</files>
  <action>
    Update ARCHITECTURE.md with multi-user architecture:

    Add section:
    ```markdown
    ## Multi-User Authentication (Phase 6)

    ### Architecture
    - **Authentication**: JWT-based (8h expiry, jose library)
    - **User Database**: SQLite users.db (id, username, fullName, whitelisted)
    - **Session Management**: Per-user BrowserContext with cookie isolation
    - **Session Cache**: File-based (.cache/session-{userId}.json, 24h TTL)

    ### Components
    - **UserDatabase**: Singleton managing users.db, whitelist CRUD
    - **SessionCacheManager**: Per-user cookie persistence
    - **BrowserPool**: Manages per-user BrowserContexts (one Browser, N contexts)
    - **JWT Middleware**: authenticateJWT extracts userId from token

    ### Flow
    1. Login: POST /api/auth/login validates whitelist + Puppeteer test → returns JWT
    2. Order: POST /api/orders/create requires JWT → extracts userId → uses user's BrowserContext
    3. Logout: POST /api/auth/logout → closes BrowserContext → clears cache

    ### Security
    - Passwords NEVER stored (used only for immediate Puppeteer validation)
    - Complete session isolation via BrowserContext API
    - JWT_SECRET in environment variable (not committed)
    - Whitelist prevents unauthorized access
    ```

    Update README.md:
    ```markdown
    ## Multi-User Support

    The system supports multiple users with individual Archibald sessions:

    1. **Login**: Each user logs in with their own Archibald credentials
    2. **Sessions**: Separate BrowserContext per user (complete cookie isolation)
    3. **Orders**: Orders created under the logged-in user's account in Archibald
    4. **Whitelist**: Only authorized users can login (managed via admin API)

    ### Environment Variables
    ```
    JWT_SECRET=your-secret-key-here  # Required for JWT token signing
    ```

    ### Admin Endpoints
    - POST /api/admin/users - Create new user
    - GET /api/admin/users - List all users
    - PATCH /api/admin/users/:id/whitelist - Update whitelist status
    - DELETE /api/admin/users/:id - Delete user
    ```
  </action>
  <verify>Documentation files updated with multi-user architecture details</verify>
  <done>ARCHITECTURE.md and README.md updated with Phase 6 multi-user documentation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete multi-user authentication system with per-user sessions</what-built>
  <how-to-verify>
    1. Start backend: cd archibald-web-app/backend && npm run dev
    2. Start frontend: cd archibald-web-app/frontend && npm run dev
    3. **Test 1 - Single user login/logout:**
       - Visit http://localhost:5173
       - Login as user 1 (test credentials from seed)
       - Create an order
       - Check backend logs show correct username
       - Logout
       - Verify returned to login screen
    4. **Test 2 - Multi-user simulation:**
       - Open browser window 1, login as user 1
       - Open browser window 2 (incognito), login as user 2
       - Create order in window 1 (should use user 1's session)
       - Create order in window 2 (should use user 2's session)
       - Check backend logs show different usernames
       - Check .cache/ directory has 2 session files
    5. **Test 3 - Session persistence:**
       - Login as user 1
       - Refresh page
       - Should stay logged in (JWT from localStorage)
       - Backend should reuse cached session (check logs)
    6. **Test 4 - Session cleanup:**
       - Login as user 1
       - Logout
       - Check .cache/ directory (session file should be deleted)
       - Check backend logs show "session cleaned up"
    7. **Test 5 - Run test script:**
       - npm run test:multi-user
       - Should complete with all tests passed
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 6, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] Logout closes BrowserContext and clears cache
- [ ] Session cleanup job runs every hour
- [ ] Multi-user test script passes all tests
- [ ] Documentation updated with Phase 6 details
- [ ] Manual multi-user testing approved at checkpoint
- [ ] Phase 6 complete and production-ready
</verification>

<success_criteria>

- All tasks completed
- Session cleanup on logout functional
- Background expiry job operational
- Multi-user isolation verified
- Documentation updated
- Comprehensive testing completed
- User manual testing approved
- Phase 6: Multi-User Authentication COMPLETE ✅
  </success_criteria>

<output>
After completion, create `.planning/phases/06-multi-user-authentication/06-07-SUMMARY.md`:

# Phase 6 Plan 7: Session Cleanup & Testing Summary

**Phase 6 Multi-User Authentication Complete and Production-Ready**

## Accomplishments

- Implemented session cleanup on logout (closes BrowserContext, clears cache)
- Created background session expiry job (runs every hour)
- Built comprehensive multi-user test script
- Updated ARCHITECTURE.md and README.md with Phase 6 documentation
- Verified multi-user isolation with manual testing
- Confirmed all 7 plans complete

## Files Created/Modified

- `archibald-web-app/backend/src/index.ts` - Enhanced logout endpoint with cleanup
- `archibald-web-app/backend/src/session-cleanup-job.ts` - Background expiry job
- `archibald-web-app/backend/src/scripts/test-multi-user.ts` - Multi-user test script
- `.planning/codebase/ARCHITECTURE.md` - Added Phase 6 architecture section
- `archibald-web-app/README.md` - Added multi-user support documentation

## Decisions Made

- Cleanup timing: Immediate on logout + hourly background job
- Test coverage: Unit (test script) + manual (checkpoint)
- Documentation: Updated both technical (ARCHITECTURE.md) and user-facing (README.md)

## Issues Encountered

None

## Phase 6 Complete

All 7 plans executed successfully:
1. ✅ Research & Architecture Design
2. ✅ User Database & Whitelist Backend
3. ✅ Authentication Backend & JWT
4. ✅ Login UI & Frontend Auth State
5. ✅ Refactor BrowserPool for Multi-User Sessions
6. ✅ Integrate User Sessions in Order Flow
7. ✅ Session Cleanup & Testing

**Phase 6: Multi-User Authentication** is now **COMPLETE** and ready for production.

## Next Phase

Ready for Phase 7: Credential Management (secure storage of Archibald credentials on device)
</output>
