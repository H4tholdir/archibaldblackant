---
phase: 06-multi-user-authentication
plan: 05
type: execute
---

<objective>
Refactor BrowserPool to support per-user BrowserContext sessions with cookie isolation.

Purpose: Enable multiple users to have independent Archibald sessions, ensuring orders are created under the correct user account with complete session isolation.

Output: Multi-user BrowserPool supporting per-user BrowserContexts, SessionCacheManager for per-user cookie persistence, ArchibaldBot userId parameter, complete session isolation verified.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-multi-user-authentication/06-01-ARCHITECTURE.md
@.planning/phases/06-multi-user-authentication/06-04-SUMMARY.md
@archibald-web-app/backend/src/browser-pool.ts
@archibald-web-app/backend/src/session-manager.ts
@archibald-web-app/backend/src/archibald-bot.ts

**Architecture Decision from Plan 06-01:**
[Will be populated with chosen architecture - BrowserContext pooling recommended]

**Current Architecture:**
- BrowserPool: Shared browser instances (single-user)
- SessionManager: Single global cookie cache
- ArchibaldBot: No userId parameter

**Goal:**
- BrowserPool: Per-user BrowserContexts with userId mapping
- SessionCacheManager: Per-user cookie cache (userId → cookies)
- ArchibaldBot: Accept userId parameter, use user's context
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SessionCacheManager for per-user cookie persistence</name>
  <files>archibald-web-app/backend/src/session-cache-manager.ts, archibald-web-app/backend/.cache/</files>
  <action>
    Create `backend/src/session-cache-manager.ts`:

    ```typescript
    import fs from 'fs';
    import path from 'path';
    import { Protocol } from 'puppeteer';
    import { logger } from './logger';

    export interface UserSessionData {
      userId: string;
      cookies: Protocol.Network.Cookie[];
      timestamp: number;
      expiresAt: number;
    }

    /**
     * Manages per-user session cookie caching
     * Replaces single-user SessionManager with multi-user support
     */
    export class SessionCacheManager {
      private static instance: SessionCacheManager;
      private cacheDir: string;
      private readonly SESSION_DURATION_MS = 24 * 60 * 60 * 1000; // 24h

      private constructor() {
        this.cacheDir = path.join(__dirname, '..', '.cache');
        if (!fs.existsSync(this.cacheDir)) {
          fs.mkdirSync(this.cacheDir, { recursive: true });
        }
      }

      static getInstance(): SessionCacheManager {
        if (!SessionCacheManager.instance) {
          SessionCacheManager.instance = new SessionCacheManager();
        }
        return SessionCacheManager.instance;
      }

      private getSessionFilePath(userId: string): string {
        return path.join(this.cacheDir, `session-${userId}.json`);
      }

      /**
       * Save user's session cookies
       */
      async saveSession(userId: string, cookies: Protocol.Network.Cookie[]): Promise<void> {
        const sessionData: UserSessionData = {
          userId,
          cookies,
          timestamp: Date.now(),
          expiresAt: Date.now() + this.SESSION_DURATION_MS,
        };

        try {
          const filePath = this.getSessionFilePath(userId);
          fs.writeFileSync(filePath, JSON.stringify(sessionData, null, 2));
          logger.info(`Session saved for user ${userId}`, {
            cookieCount: cookies.length,
            expiresIn: '24h',
          });
        } catch (error) {
          logger.error(`Error saving session for user ${userId}`, { error });
        }
      }

      /**
       * Load user's session cookies if valid
       */
      async loadSession(userId: string): Promise<Protocol.Network.Cookie[] | null> {
        const filePath = this.getSessionFilePath(userId);

        if (!fs.existsSync(filePath)) {
          logger.debug(`No cached session for user ${userId}`);
          return null;
        }

        try {
          const data = fs.readFileSync(filePath, 'utf-8');
          const sessionData: UserSessionData = JSON.parse(data);

          // Verify session is still valid
          if (Date.now() > sessionData.expiresAt) {
            logger.info(`Session expired for user ${userId}`);
            this.clearSession(userId);
            return null;
          }

          const remainingHours = Math.round(
            (sessionData.expiresAt - Date.now()) / (60 * 60 * 1000)
          );
          logger.info(`Loaded cached session for user ${userId}`, {
            cookieCount: sessionData.cookies.length,
            expiresIn: `${remainingHours}h`,
          });

          return sessionData.cookies;
        } catch (error) {
          logger.error(`Error loading session for user ${userId}`, { error });
          this.clearSession(userId);
          return null;
        }
      }

      /**
       * Clear user's session cache
       */
      clearSession(userId: string): void {
        const filePath = this.getSessionFilePath(userId);
        if (fs.existsSync(filePath)) {
          fs.unlinkSync(filePath);
          logger.info(`Session cleared for user ${userId}`);
        }
      }

      /**
       * Check if user has valid cached session
       */
      async hasValidSession(userId: string): Promise<boolean> {
        const cookies = await this.loadSession(userId);
        return cookies !== null && cookies.length > 0;
      }

      /**
       * Clear all cached sessions (for maintenance)
       */
      clearAllSessions(): void {
        const files = fs.readdirSync(this.cacheDir).filter(f => f.startsWith('session-'));
        files.forEach(file => {
          fs.unlinkSync(path.join(this.cacheDir, file));
        });
        logger.info(`Cleared ${files.length} cached sessions`);
      }
    }
    ```

    Create `.cache/` directory (gitignored):
    Add to backend/.gitignore:
    ```
    .cache/
    ```
  </action>
  <verify>npm run build succeeds, SessionCacheManager exports all methods, .cache/ directory created</verify>
  <done>SessionCacheManager created with per-user cookie caching, .cache/ directory initialized</done>
</task>

<task type="auto">
  <name>Task 2: Refactor BrowserPool for per-user BrowserContexts</name>
  <files>archibald-web-app/backend/src/browser-pool.ts</files>
  <action>
    Refactor `backend/src/browser-pool.ts` to support multi-user sessions:

    **Key changes:**
    1. Add `userContexts: Map<string, BrowserContext>` to track userId → context mapping
    2. Add `acquire(userId: string): Promise<BrowserContext>` - returns user's context or creates new one
    3. Add `release(userId: string, context: BrowserContext, success: boolean)` - cleanup or keep context
    4. Add `closeUserContext(userId: string)` - close user's context on logout
    5. Keep single shared `Browser` instance
    6. Use SessionCacheManager for per-user cookie persistence

    **New structure:**
    ```typescript
    export class BrowserPool {
      private static instance: BrowserPool;
      private browser: Browser | null = null;
      private userContexts: Map<string, BrowserContext> = new Map();
      private sessionCache: SessionCacheManager;

      async initialize(): Promise<void> {
        if (this.browser) return;

        this.browser = await puppeteer.launch({
          headless: true,
          args: ['--no-sandbox', '--disable-setuid-sandbox'],
        });

        logger.info('Browser launched for multi-user contexts');
      }

      /**
       * Acquire BrowserContext for userId
       * Reuses existing context if available, creates new if not
       */
      async acquireContext(userId: string): Promise<BrowserContext> {
        await this.initialize();

        // Return existing context if available
        if (this.userContexts.has(userId)) {
          const context = this.userContexts.get(userId)!;
          logger.debug(`Reusing context for user ${userId}`);
          return context;
        }

        // Create new context for user
        logger.info(`Creating new BrowserContext for user ${userId}`);
        const context = await this.browser!.createBrowserContext();

        // Try to load cached cookies
        const cookies = await this.sessionCache.loadSession(userId);
        if (cookies && cookies.length > 0) {
          const page = await context.newPage();
          await page.setCookie(...cookies);
          await page.close();
          logger.info(`Restored cached session for user ${userId}`);
        }

        this.userContexts.set(userId, context);
        return context;
      }

      /**
       * Release user's context after operation
       * If success, keep context for reuse; if failure, close it
       */
      async releaseContext(
        userId: string,
        context: BrowserContext,
        success: boolean
      ): Promise<void> {
        if (!success) {
          logger.warn(`Closing context for user ${userId} after error`);
          await this.closeUserContext(userId);
          return;
        }

        // Save cookies for future reuse
        try {
          const pages = await context.pages();
          if (pages.length > 0) {
            const cookies = await pages[0].cookies();
            await this.sessionCache.saveSession(userId, cookies);
          }
        } catch (error) {
          logger.error(`Error saving cookies for user ${userId}`, { error });
        }

        // Keep context in pool for reuse
        logger.debug(`Context released for user ${userId}, keeping for reuse`);
      }

      /**
       * Close user's context (on logout)
       */
      async closeUserContext(userId: string): Promise<void> {
        const context = this.userContexts.get(userId);
        if (context) {
          await context.close();
          this.userContexts.delete(userId);
          this.sessionCache.clearSession(userId);
          logger.info(`Context closed and session cleared for user ${userId}`);
        }
      }

      /**
       * Shutdown: close all contexts and browser
       */
      async shutdown(): Promise<void> {
        logger.info('Shutting down BrowserPool...');

        for (const [userId, context] of this.userContexts) {
          await context.close();
          logger.debug(`Closed context for user ${userId}`);
        }

        this.userContexts.clear();

        if (this.browser) {
          await this.browser.close();
          this.browser = null;
        }

        logger.info('BrowserPool shutdown complete');
      }

      getStats() {
        return {
          activeContexts: this.userContexts.size,
          browserRunning: this.browser !== null,
        };
      }
    }
    ```

    CRITICAL: Ensure complete cookie isolation - BrowserContexts must NOT share cookies.
    Test with multiple users creating orders simultaneously.
  </action>
  <verify>npm run build succeeds, BrowserPool exports acquireContext/releaseContext/closeUserContext</verify>
  <done>BrowserPool refactored for multi-user BrowserContexts with per-user cookie isolation</done>
</task>

<task type="auto">
  <name>Task 3: Update ArchibaldBot to use userId and BrowserContext</name>
  <files>archibald-web-app/backend/src/archibald-bot.ts</files>
  <action>
    Refactor `backend/src/archibald-bot.ts` to accept userId and use BrowserContext:

    **Key changes:**
    1. Constructor accepts optional `userId: string`
    2. If userId provided, use `BrowserPool.acquireContext(userId)` instead of old browser creation
    3. `login()` saves cookies to SessionCacheManager for userId
    4. `close()` releases context back to pool with `BrowserPool.releaseContext(userId, context, success)`
    5. Remove old Browser management (if userId mode)

    **Updated constructor:**
    ```typescript
    export class ArchibaldBot {
      private browser: Browser | null = null;
      private context: BrowserContext | null = null;
      public page: Page | null = null;
      private userId: string | null = null;

      constructor(userId?: string) {
        this.userId = userId || null;
      }

      async initialize(): Promise<void> {
        if (this.userId) {
          // Multi-user mode: acquire context from pool
          const pool = BrowserPool.getInstance();
          this.context = await pool.acquireContext(this.userId);
          this.page = await this.context.newPage();
          logger.info(`Initialized bot for user ${this.userId}`);
        } else {
          // Legacy single-user mode (for backwards compatibility)
          this.browser = await puppeteer.launch({ ... });
          this.page = await this.browser.newPage();
          logger.info('Initialized bot in legacy single-user mode');
        }

        // Configure page...
      }

      async close(): Promise<void> {
        if (this.page) {
          await this.page.close();
          this.page = null;
        }

        if (this.userId && this.context) {
          // Multi-user mode: release context to pool
          const pool = BrowserPool.getInstance();
          await pool.releaseContext(this.userId, this.context, true);
          this.context = null;
        } else if (this.browser) {
          // Legacy mode: close browser
          await this.browser.close();
          this.browser = null;
        }
      }

      async login(): Promise<void> {
        // Existing login logic...
        // After successful login, save cookies if userId mode
        if (this.userId && this.page) {
          const cookies = await this.page.cookies();
          const sessionCache = SessionCacheManager.getInstance();
          await sessionCache.saveSession(this.userId, cookies);
        }
      }
    }
    ```

    IMPORTANT: Keep backwards compatibility with old single-user mode (no userId) for existing code.
    New code should always pass userId.
  </action>
  <verify>npm run build succeeds, ArchibaldBot constructor accepts optional userId parameter</verify>
  <done>ArchibaldBot refactored to support per-user BrowserContexts via userId parameter</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run build succeeds
- [ ] SessionCacheManager creates per-user cache files in .cache/
- [ ] BrowserPool creates separate BrowserContexts per userId
- [ ] BrowserPool reuses contexts for same user
- [ ] ArchibaldBot accepts userId parameter
- [ ] Cookie isolation verified (different users = different cookies)
- [ ] Backwards compatibility maintained (no userId = legacy mode)
</verification>

<success_criteria>

- All tasks completed
- SessionCacheManager operational with per-user caching
- BrowserPool refactored for multi-user BrowserContexts
- ArchibaldBot updated to use userId and contexts
- Complete session isolation between users verified
- Backwards compatibility maintained
- Ready for Plan 06-06 (Integrate User Sessions in Order Flow)
  </success_criteria>

<output>
After completion, create `.planning/phases/06-multi-user-authentication/06-05-SUMMARY.md`:

# Phase 6 Plan 5: Refactor BrowserPool for Multi-User Sessions Summary

**Multi-user browser session management with per-user BrowserContexts operational**

## Accomplishments

- Created SessionCacheManager for per-user cookie caching (.cache/ directory)
- Refactored BrowserPool to manage per-user BrowserContexts (userId → context mapping)
- Updated ArchibaldBot to accept userId parameter and use BrowserContexts
- Verified complete session isolation between users
- Maintained backwards compatibility with legacy single-user mode

## Files Created/Modified

- `archibald-web-app/backend/src/session-cache-manager.ts` - Per-user cookie cache
- `archibald-web-app/backend/src/browser-pool.ts` - Multi-user context pool
- `archibald-web-app/backend/src/archibald-bot.ts` - Added userId support
- `archibald-web-app/backend/.cache/` - Session cache directory (gitignored)
- `archibald-web-app/backend/.gitignore` - Added .cache/

## Decisions Made

- Session storage: File-based (.cache/session-{userId}.json)
- Context lifecycle: Create on first acquire, keep until logout or error
- Cookie isolation: Complete (BrowserContext API guarantees)
- Backwards compatibility: Legacy mode (no userId) still works

## Issues Encountered

None

## Next Step

Ready for Plan 06-06: Integrate User Sessions in Order Flow
</output>
