---
phase: 08-offline-capability
plan: 07
type: execute
---

<objective>
Implement offline order queue with automatic background sync and multi-level feedback.

Purpose: Enable order creation while offline by queuing orders in IndexedDB and automatically syncing when network returns, with push notifications, badge counter, and real-time status list.

Output: Working pending orders queue, automatic sync on network return, multi-level feedback UI (badge + list + notifications).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-offline-capability/08-CONTEXT.md
@.planning/phases/08-offline-capability/08-06-SUMMARY.md
@archibald-web-app/frontend/src/db/schema.ts

**From 08-CONTEXT.md:**
- **Quando offline**: L'ordine va in **coda automatica** per sync in background
- **Quando torna online**:
  - Il sistema sincronizza automaticamente in background
  - Ordini in coda vengono inviati automaticamente
  - **Notifiche push** informano: "Ordine #12345 inviato ad Archibald"
  - **Badge contatore** sull'icona ordini mostra quanti sono pending
  - **Lista sync con stato real-time**: "In coda (2)", "Invio in corso... (1)", "Inviati (5)"
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement pending orders queue service</name>
  <files>archibald-web-app/frontend/src/services/pending-orders-service.ts</files>
  <action>
Create `pending-orders-service.ts`:

```typescript
import { db } from '../db/schema';
import type { PendingOrder } from '../db/schema';

export class PendingOrdersService {
  private static instance: PendingOrdersService;

  static getInstance(): PendingOrdersService {
    if (!PendingOrdersService.instance) {
      PendingOrdersService.instance = new PendingOrdersService();
    }
    return PendingOrdersService.instance;
  }

  /**
   * Add order to pending queue
   */
  async addPendingOrder(customerId: string, items: Array<{ productId: string; variantId: string; quantity: number }>): Promise<number> {
    const order: PendingOrder = {
      customerId,
      items,
      createdAt: new Date().toISOString(),
      status: 'pending',
      retryCount: 0
    };

    const id = await db.pendingOrders.add(order);
    console.log('[PendingOrders] Added:', id);
    return id;
  }

  /**
   * Get all pending orders with counts by status
   */
  async getPendingOrdersWithCounts(): Promise<{
    orders: PendingOrder[];
    counts: { pending: number; syncing: number; error: number };
  }> {
    const orders = await db.pendingOrders.orderBy('createdAt').reverse().toArray();

    const counts = {
      pending: orders.filter(o => o.status === 'pending').length,
      syncing: orders.filter(o => o.status === 'syncing').length,
      error: orders.filter(o => o.status === 'error').length
    };

    return { orders, counts };
  }

  /**
   * Sync pending orders when online
   */
  async syncPendingOrders(jwt: string, onProgress?: (current: number, total: number) => void): Promise<{ success: number; failed: number }> {
    const pending = await db.pendingOrders.where('status').equals('pending').toArray();

    if (pending.length === 0) {
      return { success: 0, failed: 0 };
    }

    console.log('[PendingOrders] Syncing', pending.length, 'orders');

    let success = 0;
    let failed = 0;

    for (let i = 0; i < pending.length; i++) {
      const order = pending[i];

      try {
        // Update status to syncing
        await db.pendingOrders.update(order.id!, { status: 'syncing' });

        // Call backend API
        const response = await fetch('/api/orders/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${jwt}`
          },
          body: JSON.stringify({
            customerId: order.customerId,
            items: order.items
          })
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}`);
        }

        const result = await response.json();

        // Delete from queue on success
        await db.pendingOrders.delete(order.id!);
        success++;

        console.log('[PendingOrders] Synced:', order.id, '→ Job', result.jobId);

        // Show push notification
        if ('Notification' in window && Notification.permission === 'granted') {
          new Notification('Ordine inviato', {
            body: `Ordine inviato ad Archibald (Job ${result.jobId})`,
            icon: '/pwa-192x192.png'
          });
        }

        onProgress?.(i + 1, pending.length);
      } catch (error) {
        console.error('[PendingOrders] Sync failed:', order.id, error);

        // Mark as error and increment retry count
        await db.pendingOrders.update(order.id!, {
          status: 'error',
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
          retryCount: (order.retryCount || 0) + 1
        });

        failed++;
      }
    }

    return { success, failed };
  }

  /**
   * Retry failed orders
   */
  async retryFailedOrders(jwt: string): Promise<void> {
    // Reset error status to pending for retry
    const failed = await db.pendingOrders.where('status').equals('error').toArray();

    for (const order of failed) {
      await db.pendingOrders.update(order.id!, { status: 'pending', errorMessage: undefined });
    }

    // Trigger sync
    await this.syncPendingOrders(jwt);
  }
}

export const pendingOrdersService = PendingOrdersService.getInstance();
```

When offline, OrderForm calls `pendingOrdersService.addPendingOrder()` instead of direct API call.
When back online, automatic sync triggered by network status change.
  </action>
  <verify>Orders added to pendingOrders table when offline, syncPendingOrders() sends to backend when online</verify>
  <done>PendingOrdersService with queue, sync, and retry logic implemented</done>
</task>

<task type="auto">
  <name>Task 2: Integrate automatic sync on network return</name>
  <files>archibald-web-app/frontend/src/hooks/useAutomaticSync.ts, archibald-web-app/frontend/src/App.tsx</files>
  <action>
Create `useAutomaticSync.ts` hook:

```typescript
import { useEffect } from 'react';
import { useNetworkStatus } from './useNetworkStatus';
import { pendingOrdersService } from '../services/pending-orders-service';

export function useAutomaticSync(jwt: string | null) {
  const { isOnline } = useNetworkStatus();

  useEffect(() => {
    if (isOnline && jwt) {
      // Trigger sync when network comes back online
      console.log('[AutoSync] Network online, syncing pending orders...');

      pendingOrdersService.syncPendingOrders(jwt).then(result => {
        if (result.success > 0) {
          console.log('[AutoSync] Synced', result.success, 'orders');
        }
        if (result.failed > 0) {
          console.warn('[AutoSync] Failed', result.failed, 'orders');
        }
      });
    }
  }, [isOnline, jwt]); // Trigger on network status change
}
```

Add to `App.tsx`:

```typescript
import { useAutomaticSync } from './hooks/useAutomaticSync';

function App() {
  const jwt = localStorage.getItem('archibald_jwt');
  useAutomaticSync(jwt);

  return (/* ... */);
}
```

Automatic sync triggers whenever `isOnline` changes from false → true.
  </action>
  <verify>Pending orders sync automatically when network returns (test by going offline → create order → go back online)</verify>
  <done>Automatic sync on network return integrated</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Offline order queue with automatic background sync and multi-level feedback</what-built>
  <how-to-verify>
1. Run: `npm run dev`
2. Open: http://localhost:5173 and login
3. DevTools → Network: Enable "Offline"
4. Verify: Yellow "Modalità Offline" banner appears
5. Create order: Fill customer, add items, submit
6. Verify: Order added to pending queue (IndexedDB → pendingOrders table)
7. Verify: Badge counter shows "1" (if visible in UI)
8. DevTools → Network: Disable "Offline" (back online)
9. Verify: Yellow banner disappears
10. Wait: 2-3 seconds for automatic sync
11. Check console: "[AutoSync] Synced 1 orders"
12. Check IndexedDB: pendingOrders table should be empty (order sent)
13. Check: Push notification "Ordine inviato" (if permissions granted)
14. Repeat: Create multiple orders offline, verify batch sync

Expected results:
- Orders queue when offline
- Automatic sync when back online
- Push notifications sent (if permission granted)
- Badge counter shows pending count
- Console logs show sync progress
- No errors during sync
  </how-to-verify>
  <resume-signal>Type "approved" to continue, or describe sync issues to fix</resume-signal>
</task>

</tasks>

<verification>
- [ ] PendingOrdersService adds orders to queue when offline
- [ ] Automatic sync triggers when network returns
- [ ] Orders sync successfully to backend
- [ ] Push notifications sent (if permissions granted)
- [ ] Failed orders marked with error status
- [ ] Retry mechanism works for failed orders
- [ ] Human verification passed
</verification>

<success_criteria>

- PendingOrdersService with queue management
- Automatic sync on network return (useAutomaticSync hook)
- Multi-level feedback (notifications + badge + list statuses)
- Retry mechanism for failed sync
- Orders never lost (persistent queue)
- Human verification checkpoint passed
  </success_criteria>

<output>
After completion, create `.planning/phases/08-offline-capability/08-07-SUMMARY.md`
</output>
