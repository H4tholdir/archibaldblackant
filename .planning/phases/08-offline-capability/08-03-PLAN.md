---
phase: 08-offline-capability
plan: 03
type: tdd
---

<objective>
Create CacheService with fast search methods (< 100ms) and integrate with OrderForm for offline-first operation.

Purpose: Enable instant autocomplete search from IndexedDB cache instead of backend API, achieving banking app parity with native-like speed (< 100ms response time).

Output: Working CacheService with comprehensive tests, OrderForm reading from cache, cache freshness tracking UI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-offline-capability/08-CONTEXT.md
@.planning/phases/08-offline-capability/08-01-SUMMARY.md
@.planning/phases/08-offline-capability/08-02-SUMMARY.md
@archibald-web-app/frontend/src/db/schema.ts
@archibald-web-app/frontend/src/components/OrderForm.tsx

**From 08-CONTEXT.md:**
- **Velocità - form ordine istantaneo**: Ricerca cliente/prodotto < 100ms dalla cache locale
- Niente spinner, niente attesa
- L'esperienza offline deve essere veloce come un'app nativa

**Existing OrderForm:**
- Uses /api/customers/search and /api/products/search endpoints
- Autocomplete inputs with debounced search
- Already has local filtering logic

**Performance Target:**
- < 100ms for autocomplete search (5,000 customers + 4,500 products)
- Dexie.js compound indexes should enable this easily
</context>

<feature>
  <name>CacheService with < 100ms search</name>
  <files>archibald-web-app/frontend/src/services/cache-service.ts, archibald-web-app/frontend/src/services/cache-service.spec.ts</files>
  <behavior>
### Expected Behavior

**Customer Search:**
- Input: search term (e.g., "Mario Rossi")
- Output: array of matching customers, sorted by relevance
- Performance: < 100ms for any search term
- Match on: name (case-insensitive), code, city

**Product Search:**
- Input: search term (e.g., "H71")
- Output: array of matching products with variants and prices
- Performance: < 100ms for any search term
- Match on: name (case-insensitive), article code
- Include: all variants (packageContent, minQty, etc.) and price

**Cache Freshness:**
- getCacheAge() returns hours since last sync
- isCacheStale() returns true if > 3 days old (warning threshold from CONTEXT)

### Test Cases

```typescript
describe('CacheService', () => {
  describe('searchCustomers', () => {
    it('should return customers matching name (case-insensitive)', async () => {
      const results = await cacheService.searchCustomers('mario');
      expect(results.some(c => c.name.toLowerCase().includes('mario'))).toBe(true);
    });

    it('should return customers matching code', async () => {
      const results = await cacheService.searchCustomers('A123');
      expect(results.some(c => c.code.includes('A123'))).toBe(true);
    });

    it('should return customers matching city', async () => {
      const results = await cacheService.searchCustomers('Milano');
      expect(results.some(c => c.city.includes('Milano'))).toBe(true);
    });

    it('should limit results to 50 (performance)', async () => {
      const results = await cacheService.searchCustomers('a'); // Common letter
      expect(results.length).toBeLessThanOrEqual(50);
    });

    it('should complete search in < 100ms', async () => {
      const start = performance.now();
      await cacheService.searchCustomers('test');
      const duration = performance.now() - start;
      expect(duration).toBeLessThan(100);
    });
  });

  describe('searchProducts', () => {
    it('should return products matching name', async () => {
      const results = await cacheService.searchProducts('H71');
      expect(results.some(p => p.name.includes('H71'))).toBe(true);
    });

    it('should return products matching article code', async () => {
      const results = await cacheService.searchProducts('02.33.016');
      expect(results.some(p => p.article.includes('02.33.016'))).toBe(true);
    });

    it('should include variants for each product', async () => {
      const results = await cacheService.searchProducts('H71');
      expect(results[0]?.variants).toBeDefined();
      expect(results[0]?.variants.length).toBeGreaterThan(0);
    });

    it('should include price for each product', async () => {
      const results = await cacheService.searchProducts('H71');
      expect(results[0]?.price).toBeDefined();
      expect(typeof results[0]?.price).toBe('number');
    });

    it('should complete search in < 100ms', async () => {
      const start = performance.now();
      await cacheService.searchProducts('test');
      const duration = performance.now() - start;
      expect(duration).toBeLessThan(100);
    });
  });

  describe('cache freshness', () => {
    it('should return null age if no cache', async () => {
      // Clear cache first
      await db.cacheMetadata.clear();
      const age = await cacheService.getCacheAge();
      expect(age).toBeNull();
    });

    it('should return cache age in hours', async () => {
      // Populate metadata with timestamp 2 hours ago
      const twoHoursAgo = new Date(Date.now() - 2 * 60 * 60 * 1000);
      await db.cacheMetadata.put({
        key: 'customers',
        lastSynced: twoHoursAgo.toISOString(),
        recordCount: 5000,
        version: 1
      });

      const age = await cacheService.getCacheAge();
      expect(age).toBeGreaterThan(1.9);
      expect(age).toBeLessThan(2.1);
    });

    it('should detect stale cache (> 3 days)', async () => {
      // Populate metadata with timestamp 4 days ago
      const fourDaysAgo = new Date(Date.now() - 4 * 24 * 60 * 60 * 1000);
      await db.cacheMetadata.put({
        key: 'customers',
        lastSynced: fourDaysAgo.toISOString(),
        recordCount: 5000,
        version: 1
      });

      const isStale = await cacheService.isCacheStale();
      expect(isStale).toBe(true);
    });
  });
});
```
  </behavior>
  <implementation>
### Implementation Guide

**RED Phase:**
1. Create test file with all test cases above
2. Run tests - they MUST fail (CacheService doesn't exist yet)
3. Commit: `test(08-03): add failing tests for CacheService`

**GREEN Phase:**
1. Create `frontend/src/services/cache-service.ts` with CacheService class
2. Implement searchCustomers() using Dexie.js where() clauses and compound indexes
3. Implement searchProducts() with JOIN logic for variants and prices
4. Implement getCacheAge() and isCacheStale()
5. Run tests - they MUST pass
6. Commit: `feat(08-03): implement CacheService with < 100ms search`

**REFACTOR Phase (if needed):**
1. Extract common search logic if duplication exists
2. Add JSDoc comments for public methods
3. Run tests - MUST still pass
4. Commit: `refactor(08-03): clean up CacheService` (only if changes made)

**Performance Notes:**
- Use Dexie's `.where()` with compound indexes for fast queries
- Limit results to 50 (prevents UI lag with huge result sets)
- Use `startsWithIgnoreCase()` for name matching (leverages indexes)
- Use `.toArray()` at end (materializes results once)

**Integration with OrderForm:**
After TDD cycle complete, update OrderForm to use CacheService instead of API calls (this is NOT part of TDD, it's a separate task in this plan).
  </implementation>
</feature>

<tasks>

<task type="auto">
  <name>RED: Write failing tests for CacheService</name>
  <files>archibald-web-app/frontend/src/services/cache-service.spec.ts</files>
  <action>
Create `frontend/src/services/cache-service.spec.ts` with all test cases from `<behavior>` section above.

Tests must cover:
- searchCustomers() with name, code, city matching
- searchProducts() with name, article matching
- Variant and price inclusion in product results
- Performance requirement (< 100ms)
- Result limit (50 max)
- Cache age calculation
- Stale cache detection (> 3 days)

Run tests with `npm test` in frontend directory - they MUST fail with "CacheService is not defined" or similar.

Commit with message: `test(08-03): add failing tests for CacheService with < 100ms search`
  </action>
  <verify>npm test shows 13 failing tests for CacheService</verify>
  <done>All test cases written and failing as expected</done>
</task>

<task type="auto">
  <name>GREEN: Implement CacheService to pass tests</name>
  <files>archibald-web-app/frontend/src/services/cache-service.ts</files>
  <action>
Create `frontend/src/services/cache-service.ts`:

```typescript
import { db } from '../db/schema';
import type { Customer, Product, ProductVariant, Price } from '../db/schema';

export interface ProductWithDetails extends Product {
  variants: ProductVariant[];
  price?: number;
}

export class CacheService {
  private static instance: CacheService;

  private constructor() {}

  static getInstance(): CacheService {
    if (!CacheService.instance) {
      CacheService.instance = new CacheService();
    }
    return CacheService.instance;
  }

  /**
   * Search customers by name, code, or city
   * Performance target: < 100ms
   */
  async searchCustomers(query: string, limit = 50): Promise<Customer[]> {
    if (!query || query.length < 2) {
      return [];
    }

    const lowerQuery = query.toLowerCase();

    // Use Dexie compound index for fast search
    const results = await db.customers
      .where('name')
      .startsWithIgnoreCase(query)
      .or('code')
      .startsWithIgnoreCase(query)
      .or('city')
      .startsWithIgnoreCase(query)
      .limit(limit)
      .toArray();

    // Fallback: if no results, do broader contains search
    if (results.length === 0) {
      const allCustomers = await db.customers.toArray();
      return allCustomers
        .filter(c =>
          c.name.toLowerCase().includes(lowerQuery) ||
          c.code.toLowerCase().includes(lowerQuery) ||
          c.city.toLowerCase().includes(lowerQuery)
        )
        .slice(0, limit);
    }

    return results;
  }

  /**
   * Search products by name or article code
   * Includes variants and price
   * Performance target: < 100ms
   */
  async searchProducts(query: string, limit = 50): Promise<ProductWithDetails[]> {
    if (!query || query.length < 2) {
      return [];
    }

    const lowerQuery = query.toLowerCase();

    // Search products
    const products = await db.products
      .where('name')
      .startsWithIgnoreCase(query)
      .or('article')
      .startsWithIgnoreCase(query)
      .limit(limit)
      .toArray();

    // Fallback: broader search if no results
    let finalProducts = products;
    if (products.length === 0) {
      const allProducts = await db.products.toArray();
      finalProducts = allProducts
        .filter(p =>
          p.name.toLowerCase().includes(lowerQuery) ||
          p.article.toLowerCase().includes(lowerQuery)
        )
        .slice(0, limit);
    }

    // Enrich with variants and prices (parallel)
    const enriched = await Promise.all(
      finalProducts.map(async (product) => {
        const [variants, priceRecord] = await Promise.all([
          db.productVariants.where('productId').equals(product.id).toArray(),
          db.prices.where('articleId').equals(product.id).first()
        ]);

        return {
          ...product,
          variants,
          price: priceRecord?.price
        };
      })
    );

    return enriched;
  }

  /**
   * Get cache age in hours
   */
  async getCacheAge(): Promise<number | null> {
    const metadata = await db.cacheMetadata.get('customers');

    if (!metadata) {
      return null;
    }

    const lastSync = new Date(metadata.lastSynced);
    const ageHours = (Date.now() - lastSync.getTime()) / 1000 / 60 / 60;

    return ageHours;
  }

  /**
   * Check if cache is stale (> 3 days per 08-CONTEXT.md)
   */
  async isCacheStale(): Promise<boolean> {
    const age = await this.getCacheAge();

    if (age === null) {
      return true; // No cache = stale
    }

    return age > 72; // 3 days = 72 hours
  }

  /**
   * Get customer by ID
   */
  async getCustomerById(id: string): Promise<Customer | undefined> {
    return db.customers.get(id);
  }

  /**
   * Get product by ID with variants and price
   */
  async getProductById(id: string): Promise<ProductWithDetails | undefined> {
    const product = await db.products.get(id);

    if (!product) {
      return undefined;
    }

    const [variants, priceRecord] = await Promise.all([
      db.productVariants.where('productId').equals(id).toArray(),
      db.prices.where('articleId').equals(id).first()
    ]);

    return {
      ...product,
      variants,
      price: priceRecord?.price
    };
  }
}

export const cacheService = CacheService.getInstance();
```

Run tests with `npm test` - they MUST now pass (all 13 tests green).

Commit with message: `feat(08-03): implement CacheService with < 100ms IndexedDB search`
  </action>
  <verify>npm test shows 13 passing tests, < 100ms performance verified</verify>
  <done>CacheService implemented and all tests passing</done>
</task>

<task type="auto">
  <name>REFACTOR: Update OrderForm to use CacheService</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx</files>
  <action>
Update OrderForm to use CacheService instead of API calls:

1. **Replace customer search:**
```typescript
// OLD (API call):
const response = await fetch(`/api/customers/search?q=${encodeURIComponent(query)}`);
const data = await response.json();

// NEW (Cache):
import { cacheService } from '../services/cache-service';
const data = await cacheService.searchCustomers(query);
```

2. **Replace product search:**
```typescript
// OLD (API call):
const response = await fetch(`/api/products/search?q=${encodeURIComponent(query)}`);
const data = await response.json();

// NEW (Cache):
const data = await cacheService.searchProducts(query);
// Note: data already includes variants and price, no separate API calls needed
```

3. **Add cache freshness indicator:**
Add a subtle indicator above the form showing cache age:

```typescript
const [cacheAge, setCacheAge] = useState<number | null>(null);
const [cacheStale, setCacheStale] = useState(false);

useEffect(() => {
  async function checkCache() {
    const age = await cacheService.getCacheAge();
    const stale = await cacheService.isCacheStale();
    setCacheAge(age);
    setCacheStale(stale);
  }
  checkCache();
}, []);

// In render:
{cacheAge !== null && (
  <div style={{
    fontSize: '12px',
    color: cacheStale ? '#f57c00' : '#666',
    marginBottom: '8px'
  }}>
    {cacheStale ? '⚠️' : 'ℹ️'} Dati aggiornati {Math.round(cacheAge)} ore fa
    {cacheStale && ' (aggiornamento consigliato)'}
  </div>
)}
```

DO NOT remove API endpoints yet - they can coexist (useful for debugging). OrderForm now reads from cache by default.

Tests should still pass - OrderForm logic unchanged, just data source different.
  </action>
  <verify>OrderForm autocomplete works offline (disconnect network), search returns results in < 100ms, cache age indicator shows</verify>
  <done>OrderForm integrated with CacheService, cache freshness indicator added, offline search working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 13 CacheService tests passing
- [ ] Search performance < 100ms verified in tests
- [ ] OrderForm uses cacheService.searchCustomers() and searchProducts()
- [ ] Autocomplete works offline (test with network disabled in DevTools)
- [ ] Cache age indicator shows above form
- [ ] Stale cache warning (⚠️) appears if cache > 3 days old
- [ ] No TypeScript errors
- [ ] Frontend npm test passes all tests
</verification>

<success_criteria>

- CacheService implemented with TDD (RED-GREEN-REFACTOR)
- All 13 tests passing
- searchCustomers() and searchProducts() complete in < 100ms
- Result limit of 50 prevents UI lag
- OrderForm reads from IndexedDB cache (not API)
- Offline autocomplete search works
- Cache freshness indicator shows age in hours
- Stale cache warning (> 3 days) displayed
- 2-3 atomic commits (test, feat, refactor if applicable)
  </success_criteria>

<output>
After completion, create `.planning/phases/08-offline-capability/08-03-SUMMARY.md`:

# Phase 8 Plan 03: Frontend Offline-First Data Access Summary

**CacheService with < 100ms IndexedDB search and OrderForm offline integration complete.**

## Accomplishments

- CacheService implemented via TDD (RED-GREEN-REFACTOR)
- 13 comprehensive tests (customer search, product search, performance, cache age)
- < 100ms search performance verified in tests
- OrderForm migrated from API calls to CacheService
- Offline autocomplete search working
- Cache freshness indicator with stale warning (> 3 days)
- Dexie compound indexes leveraged for fast queries

## Files Created/Modified

- `frontend/src/services/cache-service.ts` - CacheService implementation
- `frontend/src/services/cache-service.spec.ts` - 13 TDD tests
- `frontend/src/components/OrderForm.tsx` - Integrated CacheService

## Decisions Made

- 50 result limit for search (prevents UI lag)
- 3-day threshold for stale cache warning (from 08-CONTEXT.md)
- Dexie `startsWithIgnoreCase()` for indexed prefix search
- Fallback to broader `contains()` search if no prefix matches
- Parallel enrichment for variants and prices (Promise.all)
- Cache age indicator always visible (not just on stale)

## Issues Encountered

[Document any issues or "None"]

## Next Step

Ready for 08-04-PLAN.md (Service Worker & Offline-First Strategy) - configure Workbox with cache-first strategy for app shell and offline scenarios.
</output>
