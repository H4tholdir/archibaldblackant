---
phase: 08-offline-capability
plan: 02
type: execute
---

<objective>
Implement full cache population from backend to IndexedDB with progress tracking.

Purpose: Enable the initial sync that downloads ALL data (5,000 customers, 4,500 products, 4,500 prices) from backend SQLite to frontend IndexedDB, making the app fully functional offline after first run.

Output: Working cache population service that fetches all data via new API endpoint, populates IndexedDB, and shows discrete progress bar during sync.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-offline-capability/08-CONTEXT.md
@.planning/phases/08-offline-capability/08-01-SUMMARY.md
@.planning/codebase/ARCHITECTURE.md
@archibald-web-app/backend/src/customer-db.ts
@archibald-web-app/backend/src/product-db.ts
@archibald-web-app/frontend/src/db/schema.ts

**From 08-CONTEXT.md:**
- Storage illimitato: scarica TUTTI i dati (5.000 clienti, 4.500 prodotti)
- Full sync per ora (delta optimization è Phase 9+)
- First-run sync richiede connessione online (logico)
- Progress bar discreto in basso: "Aggiornamento dati... 45%"
- Initial sync: accettabile anche 2-3 minuti (succede solo una volta)

**Existing Backend Databases:**
- CustomerDatabase: getAllCustomers() returns all 5,000 records
- ProductDatabase: getAllProducts(), getProductVariants() return all products + variants
- Price sync service: Has price data in prices.db

**Data Volume Estimate:**
- Customers: ~5,000 × 500 bytes = 2.5 MB
- Products: ~4,500 × 400 bytes = 1.8 MB
- Variants: ~4,500 × 200 bytes = 0.9 MB
- Prices: ~4,500 × 150 bytes = 0.7 MB
- **Total: ~6 MB uncompressed**

Note: Way under 50-100 MB estimate, plenty of headroom for future growth.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend API endpoint for full cache export</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
Add GET /api/cache/export endpoint to `backend/src/index.ts`:

```typescript
import { CustomerDatabase } from './customer-db';
import { ProductDatabase } from './product-db';

// Add near other API routes
app.get('/api/cache/export', authenticateJWT, async (req, res) => {
  try {
    logger.info('Cache export requested', { userId: req.user?.userId });

    const startTime = Date.now();

    // Get all data from SQLite databases
    const customerDb = CustomerDatabase.getInstance();
    const productDb = ProductDatabase.getInstance();

    const [customers, products, variants, prices] = await Promise.all([
      customerDb.getAllCustomers(),
      productDb.getAllProducts(),
      productDb.getAllProductVariants(), // Need to add this method
      productDb.getAllPrices() // Need to add this method
    ]);

    const duration = Date.now() - startTime;

    logger.info('Cache export completed', {
      userId: req.user?.userId,
      customers: customers.length,
      products: products.length,
      variants: variants.length,
      prices: prices.length,
      durationMs: duration
    });

    res.json({
      success: true,
      data: {
        customers,
        products,
        variants,
        prices
      },
      metadata: {
        exportedAt: new Date().toISOString(),
        recordCounts: {
          customers: customers.length,
          products: products.length,
          variants: variants.length,
          prices: prices.length
        }
      }
    });
  } catch (error) {
    logger.error('Cache export failed', { error, userId: req.user?.userId });
    res.status(500).json({
      success: false,
      error: 'Cache export failed'
    });
  }
});
```

Add missing methods to ProductDatabase:

```typescript
// In backend/src/product-db.ts

getAllProductVariants(): Array<{
  productId: string;
  variantId: string;
  multipleQty: number;
  minQty: number;
  maxQty: number;
  packageContent: string;
}> {
  const stmt = this.db.prepare(`
    SELECT
      productId,
      variantId,
      multipleQty,
      minQty,
      maxQty,
      packageContent
    FROM product_variants
    ORDER BY productId, multipleQty DESC
  `);

  return stmt.all() as any[];
}

getAllPrices(): Array<{
  articleId: string;
  articleName: string;
  price: number;
  lastSynced: string;
}> {
  const stmt = this.db.prepare(`
    SELECT
      articleId,
      articleName,
      price,
      lastSynced
    FROM prices
    ORDER BY articleName
  `);

  return stmt.all() as any[];
}
```

Endpoint protected with JWT (only authenticated users can sync cache).

Response size: ~6 MB JSON, compresses well with gzip (~1-2 MB over network).

DO NOT implement pagination yet - full sync in one request is acceptable for ~6 MB (Phase 9 can add delta sync if needed).
  </action>
  <verify>curl -H "Authorization: Bearer {JWT}" http://localhost:3000/api/cache/export returns all data, TypeScript compiles</verify>
  <done>API endpoint returns all customers, products, variants, prices in single response with metadata</done>
</task>

<task type="auto">
  <name>Task 2: Implement CachePopulationService in frontend</name>
  <files>archibald-web-app/frontend/src/services/cache-population.ts</files>
  <action>
Create `frontend/src/services/cache-population.ts`:

```typescript
import { db } from '../db/schema';
import type { Customer, Product, ProductVariant, Price } from '../db/schema';

export interface CachePopulationProgress {
  stage: 'fetching' | 'customers' | 'products' | 'variants' | 'prices' | 'complete';
  percentage: number;
  message: string;
}

export interface CachePopulationResult {
  success: boolean;
  error?: string;
  recordCounts?: {
    customers: number;
    products: number;
    variants: number;
    prices: number;
  };
  durationMs?: number;
}

export class CachePopulationService {
  private static instance: CachePopulationService;

  private constructor() {}

  static getInstance(): CachePopulationService {
    if (!CachePopulationService.instance) {
      CachePopulationService.instance = new CachePopulationService();
    }
    return CachePopulationService.instance;
  }

  /**
   * Populate IndexedDB cache from backend
   */
  async populateCache(
    jwt: string,
    onProgress?: (progress: CachePopulationProgress) => void
  ): Promise<CachePopulationResult> {
    const startTime = Date.now();

    try {
      // Stage 1: Fetch data from backend
      onProgress?.({
        stage: 'fetching',
        percentage: 5,
        message: 'Scaricamento dati dal server...'
      });

      const response = await fetch('/api/cache/export', {
        headers: {
          'Authorization': `Bearer ${jwt}`
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Export failed');
      }

      const { customers, products, variants, prices } = result.data;

      // Stage 2: Populate customers (20% → 40%)
      onProgress?.({
        stage: 'customers',
        percentage: 20,
        message: `Salvataggio ${customers.length} clienti...`
      });

      await db.customers.bulkPut(customers as Customer[]);

      onProgress?.({
        stage: 'customers',
        percentage: 40,
        message: `${customers.length} clienti salvati`
      });

      // Stage 3: Populate products (40% → 60%)
      onProgress?.({
        stage: 'products',
        percentage: 40,
        message: `Salvataggio ${products.length} prodotti...`
      });

      await db.products.bulkPut(products as Product[]);

      onProgress?.({
        stage: 'products',
        percentage: 60,
        message: `${products.length} prodotti salvati`
      });

      // Stage 4: Populate variants (60% → 80%)
      onProgress?.({
        stage: 'variants',
        percentage: 60,
        message: `Salvataggio ${variants.length} varianti...`
      });

      await db.productVariants.bulkPut(variants as ProductVariant[]);

      onProgress?.({
        stage: 'variants',
        percentage: 80,
        message: `${variants.length} varianti salvate`
      });

      // Stage 5: Populate prices (80% → 95%)
      onProgress?.({
        stage: 'prices',
        percentage: 80,
        message: `Salvataggio ${prices.length} prezzi...`
      });

      await db.prices.bulkPut(prices as Price[]);

      onProgress?.({
        stage: 'prices',
        percentage: 95,
        message: `${prices.length} prezzi salvati`
      });

      // Stage 6: Update metadata (95% → 100%)
      await db.cacheMetadata.bulkPut([
        {
          key: 'customers',
          lastSynced: result.metadata.exportedAt,
          recordCount: customers.length,
          version: 1
        },
        {
          key: 'products',
          lastSynced: result.metadata.exportedAt,
          recordCount: products.length,
          version: 1
        },
        {
          key: 'prices',
          lastSynced: result.metadata.exportedAt,
          recordCount: prices.length,
          version: 1
        }
      ]);

      const durationMs = Date.now() - startTime;

      onProgress?.({
        stage: 'complete',
        percentage: 100,
        message: 'Cache aggiornata con successo'
      });

      return {
        success: true,
        recordCounts: {
          customers: customers.length,
          products: products.length,
          variants: variants.length,
          prices: prices.length
        },
        durationMs
      };
    } catch (error) {
      console.error('[CachePopulation] Failed:', error);

      return {
        success: false,
        error: error instanceof Error ? error.message : 'Errore imprevisto'
      };
    }
  }

  /**
   * Check if cache needs refresh (more than 24 hours old)
   */
  async needsRefresh(): Promise<boolean> {
    const metadata = await db.cacheMetadata.get('customers');

    if (!metadata) {
      return true; // No cache, needs initial sync
    }

    const lastSync = new Date(metadata.lastSynced);
    const ageHours = (Date.now() - lastSync.getTime()) / 1000 / 60 / 60;

    return ageHours > 24;
  }

  /**
   * Get cache age in hours
   */
  async getCacheAge(): Promise<number | null> {
    const metadata = await db.cacheMetadata.get('customers');

    if (!metadata) {
      return null;
    }

    const lastSync = new Date(metadata.lastSynced);
    return (Date.now() - lastSync.getTime()) / 1000 / 60 / 60;
  }
}

export const cachePopulationService = CachePopulationService.getInstance();
```

Performance notes:
- bulkPut() is fastest method for large inserts (single transaction)
- Progress callbacks every 20% keep UI responsive
- Total time: ~2-3 seconds for 6 MB data on modern devices
- Error handling returns user-friendly Italian messages

DO NOT implement automatic background refresh yet (that's Plan 08-07).
  </action>
  <verify>TypeScript compiles, CachePopulationService can be instantiated, methods callable</verify>
  <done>CachePopulationService implemented with progress tracking, error handling, and cache age checking</done>
</task>

<task type="auto">
  <name>Task 3: Add initial sync progress UI component</name>
  <files>archibald-web-app/frontend/src/components/CacheSyncProgress.tsx, archibald-web-app/frontend/src/App.tsx</files>
  <action>
Create `frontend/src/components/CacheSyncProgress.tsx`:

```typescript
import { useState, useEffect } from 'react';
import { cachePopulationService, type CachePopulationProgress } from '../services/cache-population';

export function CacheSyncProgress() {
  const [syncing, setSyncing] = useState(false);
  const [progress, setProgress] = useState<CachePopulationProgress | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [jwt, setJwt] = useState<string | null>(null);

  useEffect(() => {
    // Get JWT from localStorage
    const token = localStorage.getItem('archibald_jwt');
    setJwt(token);

    // Check if cache needs refresh
    if (token) {
      checkCacheStatus(token);
    }
  }, []);

  async function checkCacheStatus(token: string) {
    const needsRefresh = await cachePopulationService.needsRefresh();

    if (needsRefresh) {
      // Auto-start sync on first run or stale cache
      await startSync(token);
    }
  }

  async function startSync(token: string) {
    setSyncing(true);
    setError(null);

    const result = await cachePopulationService.populateCache(
      token,
      (prog) => setProgress(prog)
    );

    setSyncing(false);

    if (!result.success) {
      setError(result.error || 'Errore durante sincronizzazione');
    } else {
      console.log('[CacheSync] Complete:', result.recordCounts, `${result.durationMs}ms`);
    }
  }

  async function handleManualSync() {
    if (!jwt) {
      setError('Nessun token di autenticazione trovato');
      return;
    }

    await startSync(jwt);
  }

  if (!syncing && !progress) {
    return null; // No sync in progress, no UI
  }

  return (
    <div style={{
      position: 'fixed',
      bottom: 0,
      left: 0,
      right: 0,
      backgroundColor: '#f5f5f5',
      borderTop: '1px solid #ddd',
      padding: '8px 16px',
      zIndex: 1000
    }}>
      {error ? (
        <div style={{ color: '#d32f2f', fontSize: '14px' }}>
          ⚠️ {error}
          <button
            onClick={handleManualSync}
            style={{ marginLeft: '12px', padding: '4px 8px', fontSize: '12px' }}
          >
            Riprova
          </button>
        </div>
      ) : syncing && progress ? (
        <div>
          <div style={{
            fontSize: '12px',
            color: '#666',
            marginBottom: '4px'
          }}>
            {progress.message}
          </div>
          <div style={{
            width: '100%',
            height: '4px',
            backgroundColor: '#e0e0e0',
            borderRadius: '2px',
            overflow: 'hidden'
          }}>
            <div style={{
              width: `${progress.percentage}%`,
              height: '100%',
              backgroundColor: '#4caf50',
              transition: 'width 0.3s ease'
            }} />
          </div>
        </div>
      ) : null}
    </div>
  );
}
```

Add to `frontend/src/App.tsx`:

```typescript
import { CacheSyncProgress } from './components/CacheSyncProgress';

function App() {
  return (
    <>
      {/* Existing app content */}
      <CacheSyncProgress />
    </>
  );
}
```

UI matches 08-CONTEXT.md requirements:
- **Discrete progress bar in basso** (fixed bottom, not blocking)
- Shows percentage and Italian messages
- Auto-starts on first run or stale cache
- Manual retry button on error
- Disappears when sync complete

Styling is minimal inline CSS (proper styling in Plan 08-06 with design system).
  </action>
  <verify>App shows progress bar during initial sync, percentage increases 0% → 100%, bar disappears when complete</verify>
  <done>CacheSyncProgress component integrated, auto-sync on first run, manual retry on error, discrete progress bar</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] GET /api/cache/export returns all data (test with curl + JWT)
- [ ] TypeScript compilation succeeds (backend and frontend)
- [ ] App starts and auto-triggers cache sync on first run
- [ ] Progress bar shows at bottom with percentage increasing
- [ ] Browser DevTools → Application → IndexedDB shows populated tables
- [ ] customers table has ~5,000 records
- [ ] products table has ~4,500 records
- [ ] productVariants table has ~4,500 records
- [ ] prices table has ~4,500 records
- [ ] cacheMetadata table has 3 records (customers, products, prices)
- [ ] Console logs show sync duration (< 5 seconds expected)
- [ ] Manual sync button works after error
</verification>

<success_criteria>

- Backend API endpoint /api/cache/export returns all data
- ProductDatabase has getAllProductVariants() and getAllPrices() methods
- CachePopulationService populates IndexedDB with progress tracking
- Progress UI shows discrete bar at bottom (08-CONTEXT.md requirement)
- Auto-sync on first run (no cache) or stale cache (> 24h)
- Manual retry available on error
- All ~14,000 records synced successfully
- Sync completes in < 5 seconds on modern devices
  </success_criteria>

<output>
After completion, create `.planning/phases/08-offline-capability/08-02-SUMMARY.md`:

# Phase 8 Plan 02: Cache Population from Backend Summary

**Full cache population from backend SQLite to frontend IndexedDB with discrete progress tracking.**

## Accomplishments

- Backend API endpoint /api/cache/export created (JWT-protected)
- ProductDatabase extended with getAllProductVariants() and getAllPrices()
- CachePopulationService with progress callbacks and error handling
- Discrete progress bar component at bottom of screen
- Auto-sync on first run or stale cache (> 24h)
- Manual retry button on sync errors
- ~14,000 records synced in single request (~6 MB uncompressed)

## Files Created/Modified

- `backend/src/index.ts` - Added GET /api/cache/export endpoint
- `backend/src/product-db.ts` - Added getAllProductVariants(), getAllPrices()
- `frontend/src/services/cache-population.ts` - CachePopulationService
- `frontend/src/components/CacheSyncProgress.tsx` - Progress UI component
- `frontend/src/App.tsx` - Integrated CacheSyncProgress

## Decisions Made

- Full sync in one request (not paginated) - acceptable for 6 MB
- bulkPut() for fast inserts (single transaction per table)
- Auto-sync on first run (no manual trigger needed)
- 24h cache TTL before auto-refresh suggested
- Progress callbacks every 20% for responsive UI
- Inline CSS for now (proper styling in Plan 08-06)

## Issues Encountered

[Document any issues or "None"]

## Next Step

Ready for 08-03-PLAN.md (Frontend Offline-First Data Access) - create CacheService wrapper for < 100ms IndexedDB queries and update OrderForm to read from cache.
</output>
