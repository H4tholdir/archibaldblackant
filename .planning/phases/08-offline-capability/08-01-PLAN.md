---
phase: 08-offline-capability
plan: 01
type: execute
---

<objective>
Design and setup IndexedDB infrastructure with Dexie.js for offline-first data caching.

Purpose: Establish the foundation for offline capability by creating a robust, well-structured IndexedDB schema that can store all customers, products, prices, and draft orders (~50-100 MB total).

Output: Working IndexedDB setup with Dexie.js wrapper, schema definition, and initial database connection ready for data population.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-offline-capability/08-CONTEXT.md
@.planning/codebase/STACK.md
@.planning/codebase/ARCHITECTURE.md

**Phase 8 Vision (from CONTEXT.md):**
L'app funziona **sempre**, online o offline. Cache automatica di tutti i dati (clienti, prodotti, prezzi) - circa 50-100 MB. Ricerca < 100ms dalla cache locale. Form ordine istantaneo come app nativa.

**Essential Requirements:**
- Affidabilità: Ordini non si perdono MAI
- Trasparenza: L'agente vede sempre lo stato
- Velocità: Ricerca < 100ms

**Storage Strategy:**
- Illimitato: scarica TUTTI i dati (5.000 clienti, 4.500 prodotti)
- Full sync per ora (delta optimization deferred)
- First-run sync richiede connessione online

**Tech Stack Available:**
- React 19.2.3 frontend with Vite 7.3.1
- TypeScript 5.9.3
- vite-plugin-pwa 1.2.0 (Workbox) already configured
- better-sqlite3 12.5.0 on backend (existing customer/product databases)

**Existing Data Models (from backend SQLite):**
- Customers: ~5,000 records (id, name, code, taxCode, address, city, province, cap, phone, email, fax, lastModified, hash)
- Products: ~4,500 records (id, name, article, description, lastModified, hash)
- Product Variants: multipleQty, minQty, maxQty, variantId, packageContent
- Prices: ~4,500 records (articleId, articleName, price, lastSynced)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research IndexedDB patterns and install Dexie.js</name>
  <files>archibald-web-app/frontend/package.json</files>
  <action>
Research IndexedDB best practices for offline-first PWA with ~50-100 MB data:
- Storage quota handling (IndexedDB typically 50% available disk space, ~100+ GB on modern devices)
- Schema versioning patterns (Dexie.js migrations)
- Query performance patterns (compound indexes for fast search)
- Offline-first PWA patterns (cache-first, network-first, stale-while-revalidate)

Install Dexie.js (latest stable):
```bash
cd archibald-web-app/frontend
npm install dexie
```

Dexie.js chosen because:
- TypeScript-first API (better DX than raw IndexedDB)
- Automatic schema versioning
- Query performance optimizations (compound indexes)
- Well-maintained (~100k weekly downloads)
- Simple migration system
- Promise-based API (async/await friendly)

DO NOT use localForage or other abstractions - Dexie.js provides optimal balance of simplicity and power for this use case.
  </action>
  <verify>npm list dexie shows installed version, no errors</verify>
  <done>Dexie.js installed and research findings documented in code comments</done>
</task>

<task type="auto">
  <name>Task 2: Create IndexedDB schema with Dexie.js</name>
  <files>archibald-web-app/frontend/src/db/schema.ts, archibald-web-app/frontend/src/db/database.ts</files>
  <action>
Create `frontend/src/db/schema.ts` with Dexie database class:

```typescript
import Dexie, { Table } from 'dexie';

// Match backend SQLite schema for customers
export interface Customer {
  id: string;
  name: string;
  code: string;
  taxCode: string;
  address: string;
  city: string;
  province: string;
  cap: string;
  phone: string;
  email: string;
  fax: string;
  lastModified: string;
  hash: string;
}

// Match backend SQLite schema for products
export interface Product {
  id: string;
  name: string;
  article: string;
  description: string;
  lastModified: string;
  hash: string;
}

// Match backend product variants
export interface ProductVariant {
  id?: number; // Auto-increment
  productId: string; // FK to Product
  variantId: string;
  multipleQty: number;
  minQty: number;
  maxQty: number;
  packageContent: string;
}

// Match backend prices
export interface Price {
  id?: number; // Auto-increment
  articleId: string;
  articleName: string;
  price: number;
  lastSynced: string;
}

// Draft orders (offline-first feature)
export interface DraftOrder {
  id?: number; // Auto-increment
  customerId: string;
  customerName: string;
  items: DraftOrderItem[];
  createdAt: string;
  updatedAt: string;
}

export interface DraftOrderItem {
  productId: string;
  productName: string;
  article: string;
  variantId: string;
  quantity: number;
  packageContent: string;
}

// Pending orders queue (offline submission)
export interface PendingOrder {
  id?: number; // Auto-increment
  customerId: string;
  items: Array<{
    productId: string;
    variantId: string;
    quantity: number;
  }>;
  createdAt: string;
  status: 'pending' | 'syncing' | 'error';
  errorMessage?: string;
  retryCount: number;
}

// Cache metadata (track freshness)
export interface CacheMetadata {
  key: string; // 'customers' | 'products' | 'prices'
  lastSynced: string;
  recordCount: number;
  version: number;
}

export class ArchibaldDatabase extends Dexie {
  customers!: Table<Customer, string>; // string = primary key type
  products!: Table<Product, string>;
  productVariants!: Table<ProductVariant, number>;
  prices!: Table<Price, number>;
  draftOrders!: Table<DraftOrder, number>;
  pendingOrders!: Table<PendingOrder, number>;
  cacheMetadata!: Table<CacheMetadata, string>;

  constructor() {
    super('ArchibaldOfflineDB');

    // Version 1 schema
    this.version(1).stores({
      // Customers: primary key 'id', indexes for search
      customers: 'id, name, code, city, *hash',

      // Products: primary key 'id', compound indexes for fast search
      products: 'id, name, article, *hash',

      // Product variants: auto-increment, FK to products
      productVariants: '++id, productId, variantId',

      // Prices: auto-increment, FK to products
      prices: '++id, articleId, articleName',

      // Draft orders: auto-increment, indexed by customer and timestamps
      draftOrders: '++id, customerId, createdAt, updatedAt',

      // Pending orders: auto-increment, indexed by status and createdAt
      pendingOrders: '++id, status, createdAt',

      // Cache metadata: primary key 'key'
      cacheMetadata: 'key, lastSynced'
    });
  }
}

// Singleton instance
export const db = new ArchibaldDatabase();
```

Create `frontend/src/db/database.ts` with utility functions:

```typescript
import { db } from './schema';

/**
 * Check if IndexedDB is supported
 */
export function isIndexedDBSupported(): boolean {
  return 'indexedDB' in window;
}

/**
 * Get database size estimate (in MB)
 */
export async function getDatabaseSize(): Promise<number> {
  if (!navigator.storage || !navigator.storage.estimate) {
    return 0;
  }

  const estimate = await navigator.storage.estimate();
  const usage = estimate.usage || 0;
  return Math.round(usage / 1024 / 1024 * 100) / 100; // MB with 2 decimals
}

/**
 * Check available storage quota
 */
export async function getStorageQuota(): Promise<{ used: number; available: number; percentage: number }> {
  if (!navigator.storage || !navigator.storage.estimate) {
    return { used: 0, available: 0, percentage: 0 };
  }

  const estimate = await navigator.storage.estimate();
  const used = estimate.usage || 0;
  const quota = estimate.quota || 0;
  const percentage = quota > 0 ? Math.round((used / quota) * 100) : 0;

  return {
    used: Math.round(used / 1024 / 1024), // MB
    available: Math.round(quota / 1024 / 1024), // MB
    percentage
  };
}

/**
 * Clear all data (for testing or reset)
 */
export async function clearAllData(): Promise<void> {
  await db.customers.clear();
  await db.products.clear();
  await db.productVariants.clear();
  await db.prices.clear();
  await db.draftOrders.clear();
  await db.pendingOrders.clear();
  await db.cacheMetadata.clear();
}

/**
 * Get cache freshness info
 */
export async function getCacheFreshness(): Promise<Map<string, Date>> {
  const metadata = await db.cacheMetadata.toArray();
  const freshness = new Map<string, Date>();

  for (const item of metadata) {
    freshness.set(item.key, new Date(item.lastSynced));
  }

  return freshness;
}
```

Performance considerations:
- Compound indexes on name/article for fast autocomplete search (< 100ms requirement)
- Hash indexes for change detection (match backend pattern)
- Separate table for variants (normalized, avoid duplication)
- Auto-increment IDs for drafts/pending (simpler than UUIDs for local-only data)

DO NOT create sync logic yet (that's Plan 08-02). Focus only on schema definition and database setup.
  </action>
  <verify>TypeScript compiles without errors, db instance can be imported, Dexie DevTools shows schema in browser</verify>
  <done>IndexedDB schema defined with all tables (customers, products, variants, prices, drafts, pending, metadata), utility functions created, database singleton exported</done>
</task>

<task type="auto">
  <name>Task 3: Add database initialization and error handling</name>
  <files>archibald-web-app/frontend/src/db/database.ts</files>
  <action>
Add database initialization logic to `frontend/src/db/database.ts`:

```typescript
import { db } from './schema';

/**
 * Initialize database and handle errors
 */
export async function initializeDatabase(): Promise<{ success: boolean; error?: string }> {
  try {
    // Check IndexedDB support
    if (!isIndexedDBSupported()) {
      return {
        success: false,
        error: 'IndexedDB non supportato in questo browser'
      };
    }

    // Open database (triggers schema creation if needed)
    await db.open();

    console.log('[IndexedDB] Database initialized successfully');
    console.log('[IndexedDB] Database version:', db.verno);

    // Log storage quota
    const quota = await getStorageQuota();
    console.log('[IndexedDB] Storage:', `${quota.used}MB / ${quota.available}MB (${quota.percentage}%)`);

    return { success: true };
  } catch (error) {
    console.error('[IndexedDB] Initialization failed:', error);

    // Handle common errors
    if (error instanceof Error) {
      if (error.name === 'QuotaExceededError') {
        return {
          success: false,
          error: 'Spazio di archiviazione insufficiente. Libera spazio sul dispositivo.'
        };
      }

      if (error.name === 'VersionError') {
        return {
          success: false,
          error: 'Errore di versione database. Prova a ricaricare l\'app.'
        };
      }
    }

    return {
      success: false,
      error: 'Errore imprevisto durante inizializzazione database'
    };
  }
}

/**
 * Handle database upgrade (version migration)
 */
db.on('ready', async () => {
  console.log('[IndexedDB] Database ready');

  // Log current record counts
  const counts = {
    customers: await db.customers.count(),
    products: await db.products.count(),
    variants: await db.productVariants.count(),
    prices: await db.prices.count(),
    drafts: await db.draftOrders.count(),
    pending: await db.pendingOrders.count()
  };

  console.log('[IndexedDB] Record counts:', counts);
});

/**
 * Handle database errors
 */
db.on('blocked', () => {
  console.warn('[IndexedDB] Database blocked - another tab may be using an older version');
});

db.on('versionchange', () => {
  console.warn('[IndexedDB] Database version changed - reload recommended');
  db.close();
});
```

Call `initializeDatabase()` in `frontend/src/main.tsx` before ReactDOM render:

```typescript
import { initializeDatabase } from './db/database';

// Initialize IndexedDB before rendering app
initializeDatabase().then(result => {
  if (!result.success) {
    console.error('[App] Database initialization failed:', result.error);
    // App will still render but offline features won't work
  }

  // Render app
  const root = document.getElementById('root');
  if (root) {
    ReactDOM.createRoot(root).render(<App />);
  }
});
```

Error handling strategy:
- Graceful degradation: App renders even if IndexedDB fails
- User-friendly Italian error messages
- Console logging for debugging
- Storage quota monitoring

DO NOT block app rendering on database initialization - offline features should degrade gracefully if IndexedDB unavailable.
  </action>
  <verify>App starts without errors, Dexie DevTools shows ArchibaldOfflineDB with 7 tables, console shows initialization logs</verify>
  <done>Database initialization with error handling complete, lifecycle hooks configured, app integration working</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm list dexie shows installed version
- [ ] TypeScript compilation succeeds (npm run build in frontend)
- [ ] App starts in dev mode without errors
- [ ] Browser DevTools → Application → IndexedDB shows ArchibaldOfflineDB
- [ ] All 7 tables visible (customers, products, productVariants, prices, draftOrders, pendingOrders, cacheMetadata)
- [ ] Console logs show successful database initialization
- [ ] Storage quota logged to console
</verification>

<success_criteria>

- Dexie.js installed and configured
- IndexedDB schema defined with 7 tables matching backend data models
- Database singleton created and exported
- Utility functions for quota checking and cache freshness
- Error handling with graceful degradation
- App integration in main.tsx (non-blocking initialization)
- All TypeScript types compile without errors
- Browser DevTools shows database structure
  </success_criteria>

<output>
After completion, create `.planning/phases/08-offline-capability/08-01-SUMMARY.md`:

# Phase 8 Plan 01: IndexedDB Schema Design & Dexie Setup Summary

**IndexedDB foundation established with Dexie.js wrapper and comprehensive schema for offline-first data caching.**

## Accomplishments

- Dexie.js installed and configured for TypeScript
- 7-table schema designed (customers, products, variants, prices, drafts, pending, metadata)
- Database singleton with lifecycle hooks
- Storage quota monitoring utilities
- Graceful error handling with Italian messages
- App integration with non-blocking initialization

## Files Created/Modified

- `frontend/package.json` - Added dexie dependency
- `frontend/src/db/schema.ts` - Database schema and types
- `frontend/src/db/database.ts` - Utility functions and initialization
- `frontend/src/main.tsx` - Database initialization before render

## Decisions Made

- Dexie.js chosen over raw IndexedDB for TypeScript DX and migration support
- Compound indexes on name/article for < 100ms search performance
- Auto-increment IDs for local-only data (drafts, pending)
- Graceful degradation if IndexedDB unavailable (app still renders)
- Storage quota monitoring for proactive full-disk warnings

## Issues Encountered

[Document any issues or "None"]

## Next Step

Ready for 08-02-PLAN.md (Cache Population from Backend) - create API endpoint for full data export and implement frontend cache population service.
</output>
