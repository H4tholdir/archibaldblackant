---
phase: 28.2-rewrite-orderform-with-proper-architecture
plan: 03
type: execute
---

<objective>
Build CustomerSelector and ProductSelector components with fast autocomplete (<100ms), variant-aware quantity input, and mobile-friendly UX.

Purpose: Create reusable, performant selection components that handle ~1500 customers and ~5000 products with optimal user experience.
Output: 3 components (CustomerSelector, ProductSelector, QuantityInput) with real-time autocomplete and validation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-CONTEXT.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-02-PLAN.md
@archibald-web-app/frontend/src/services/customers.service.ts
@archibald-web-app/frontend/src/services/products.service.ts

**Dependencies:**
- Plan 28.2-02 completed (CustomerService, ProductService available)
- IndexedDB populated with data
- Services tested and working

**Requirements from CONTEXT.md:**

**Customer Selection:**
- Match field: NOME cliente (not ID)
- UX: Sistema veloce, preciso, intelligente per selezione rapida
- Autocomplete: Filtraggio live mentre l'utente digita
- Data source: Database ufficiale clienti (~1500 records)
- Performance: <100ms perceived latency

**Product Selection:**
- Match field: NOME ARTICOLO (not ID or code)
- UX: Stesse indicazioni di customer selection - veloce, preciso, intelligente
- Autocomplete: Filtraggio live mentre l'utente digita
- Data source: Database ufficiale prodotti (~5000 records con varianti)
- Performance: <100ms perceived latency

**Quantity & Variants:**
- Variant selection: Sistema deve selezionare variante corretta basandosi su quantità
- Multiples: Gestire multipli di colli automaticamente
- Validation: Prevenire quantità invalide rispetto ai vincoli variante
- UX: Show constraints (min/max/multiples) to user

**Design Principles:**
- Debouncing: 300ms for search inputs (performance)
- Keyboard navigation: Arrow keys, Enter, Escape (accessibility)
- ARIA labels: Screen reader support
- Touch-friendly: Large tap targets (mobile)
- Clear feedback: Loading states, error messages, validation
- Inline styles: Project convention

**Component Architecture (from Plan 28.2-01):**

```
CustomerSelector
├── Input field (controlled)
├── Dropdown (filtered results)
├── Loading indicator
├── Error message
└── Selected confirmation

ProductSelector
├── Input field (controlled)
├── Dropdown (filtered results, shows article + description)
├── Loading indicator
├── Error message
└── Selected confirmation

QuantityInput
├── Number input (controlled)
├── Variant constraints display (min/max/multiples)
├── Validation feedback
└── Package content info
```

**Existing Pain Points to Avoid:**
- Race conditions in customer selection (fixed in 28.1-01 but fragile)
- Complex state management with multiple interdependent useState
- Lack of proper event handling (stopPropagation, preventDefault)
- No debouncing → excessive re-renders
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build CustomerSelector component with autocomplete</name>
  <files>archibald-web-app/frontend/src/components/new-order-form/CustomerSelector.tsx (new), archibald-web-app/frontend/src/components/new-order-form/CustomerSelector.spec.tsx (new)</files>
  <action>
Following React best practices and inline styles:

1. **Create test file first**: `CustomerSelector.spec.tsx`

Tests:
- Renders input field with placeholder
- Typing triggers debounced search (300ms)
- Displays filtered results in dropdown
- Clicking result selects customer and closes dropdown
- Escape key closes dropdown
- Arrow keys navigate dropdown items
- Shows loading state during search
- Shows error message on search failure
- Displays selected customer confirmation

Use React Testing Library:
```typescript
import { describe, test, expect, vi } from 'vitest';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { CustomerSelector } from './CustomerSelector';

describe('CustomerSelector', () => {
  test('renders input with placeholder', () => {
    render(<CustomerSelector onSelect={vi.fn()} />);
    expect(screen.getByPlaceholderText('Cerca cliente...')).toBeInTheDocument();
  });

  test('typing triggers debounced search after 300ms', async () => {
    const mockSearch = vi.fn().mockResolvedValue([
      { id: '1', name: 'Mario Rossi', code: 'MR001' },
    ]);

    render(<CustomerSelector onSelect={vi.fn()} searchFn={mockSearch} />);

    const input = screen.getByPlaceholderText('Cerca cliente...');
    await userEvent.type(input, 'mario');

    // Search should NOT be called immediately
    expect(mockSearch).not.toHaveBeenCalled();

    // Wait for debounce (300ms)
    await waitFor(() => expect(mockSearch).toHaveBeenCalledWith('mario'), {
      timeout: 400,
    });
  });

  test('clicking result selects customer and closes dropdown', async () => {
    const onSelect = vi.fn();
    const mockSearch = vi.fn().mockResolvedValue([
      { id: '1', name: 'Mario Rossi', code: 'MR001' },
    ]);

    render(<CustomerSelector onSelect={onSelect} searchFn={mockSearch} />);

    const input = screen.getByPlaceholderText('Cerca cliente...');
    await userEvent.type(input, 'mario');

    await waitFor(() => screen.getByText('Mario Rossi'));

    const result = screen.getByText('Mario Rossi');
    await userEvent.click(result);

    expect(onSelect).toHaveBeenCalledWith({ id: '1', name: 'Mario Rossi', code: 'MR001' });
    expect(screen.queryByText('Mario Rossi')).not.toBeInTheDocument(); // Dropdown closed
  });

  // More tests...
});
```

2. **Implement CustomerSelector**: `CustomerSelector.tsx`

```typescript
import { useState, useEffect, useRef, useCallback } from 'react';
import { customerService } from '../../services/customers.service';
import type { Customer } from '../../db/schema';

interface CustomerSelectorProps {
  onSelect: (customer: Customer) => void;
  placeholder?: string;
  disabled?: boolean;
  searchFn?: (query: string) => Promise<Customer[]>; // For testing
}

export function CustomerSelector({
  onSelect,
  placeholder = 'Cerca cliente per nome...',
  disabled = false,
  searchFn = customerService.searchCustomers.bind(customerService),
}: CustomerSelectorProps) {
  const [searchQuery, setSearchQuery] = useState('');
  const [results, setResults] = useState<Customer[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [showDropdown, setShowDropdown] = useState(false);
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);

  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const debounceTimerRef = useRef<number | null>(null);

  // Debounced search
  useEffect(() => {
    if (searchQuery.length === 0) {
      setResults([]);
      setShowDropdown(false);
      return;
    }

    // Clear previous timer
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }

    // Set new timer (300ms debounce)
    debounceTimerRef.current = window.setTimeout(async () => {
      setLoading(true);
      setError(null);

      try {
        const customers = await searchFn(searchQuery);
        setResults(customers);
        setShowDropdown(customers.length > 0);
      } catch (err) {
        setError('Errore durante la ricerca');
        console.error('[CustomerSelector] Search failed:', err);
      } finally {
        setLoading(false);
      }
    }, 300);

    return () => {
      if (debounceTimerRef.current) {
        clearTimeout(debounceTimerRef.current);
      }
    };
  }, [searchQuery, searchFn]);

  // Close dropdown on outside click
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        dropdownRef.current &&
        !dropdownRef.current.contains(event.target as Node) &&
        inputRef.current &&
        !inputRef.current.contains(event.target as Node)
      ) {
        setShowDropdown(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  // Handle keyboard navigation
  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent) => {
      if (!showDropdown || results.length === 0) return;

      switch (e.key) {
        case 'ArrowDown':
          e.preventDefault();
          setHighlightedIndex((prev) =>
            prev < results.length - 1 ? prev + 1 : prev
          );
          break;
        case 'ArrowUp':
          e.preventDefault();
          setHighlightedIndex((prev) => (prev > 0 ? prev - 1 : 0));
          break;
        case 'Enter':
          e.preventDefault();
          if (highlightedIndex >= 0 && highlightedIndex < results.length) {
            handleSelect(results[highlightedIndex]);
          }
          break;
        case 'Escape':
          e.preventDefault();
          setShowDropdown(false);
          setHighlightedIndex(-1);
          break;
      }
    },
    [showDropdown, results, highlightedIndex]
  );

  const handleSelect = (customer: Customer) => {
    setSelectedCustomer(customer);
    setSearchQuery(customer.name);
    setShowDropdown(false);
    setHighlightedIndex(-1);
    onSelect(customer);
  };

  return (
    <div style={{ position: 'relative', width: '100%' }}>
      {/* Input Field */}
      <div style={{ marginBottom: '0.5rem' }}>
        <label
          htmlFor="customer-search"
          style={{
            display: 'block',
            marginBottom: '0.25rem',
            fontWeight: '500',
            fontSize: '0.875rem',
          }}
        >
          Cliente
        </label>
        <input
          ref={inputRef}
          id="customer-search"
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder={placeholder}
          disabled={disabled}
          aria-label="Cerca cliente"
          aria-autocomplete="list"
          aria-controls="customer-dropdown"
          aria-expanded={showDropdown}
          style={{
            width: '100%',
            padding: '0.5rem',
            fontSize: '1rem',
            border: '1px solid #ccc',
            borderRadius: '4px',
            outline: 'none',
            ...(selectedCustomer && {
              borderColor: '#22c55e',
              backgroundColor: '#f0fdf4',
            }),
          }}
        />
      </div>

      {/* Loading Indicator */}
      {loading && (
        <div style={{ fontSize: '0.875rem', color: '#6b7280' }}>
          Ricerca in corso...
        </div>
      )}

      {/* Error Message */}
      {error && (
        <div style={{ fontSize: '0.875rem', color: '#dc2626' }}>{error}</div>
      )}

      {/* Selected Customer Confirmation */}
      {selectedCustomer && !showDropdown && (
        <div
          style={{
            padding: '0.5rem',
            backgroundColor: '#f0fdf4',
            border: '1px solid #22c55e',
            borderRadius: '4px',
            fontSize: '0.875rem',
            color: '#15803d',
          }}
        >
          ✅ Cliente selezionato: <strong>{selectedCustomer.name}</strong>
        </div>
      )}

      {/* Dropdown Results */}
      {showDropdown && results.length > 0 && (
        <div
          ref={dropdownRef}
          id="customer-dropdown"
          role="listbox"
          style={{
            position: 'absolute',
            top: '100%',
            left: 0,
            right: 0,
            maxHeight: '300px',
            overflowY: 'auto',
            backgroundColor: 'white',
            border: '1px solid #ccc',
            borderRadius: '4px',
            boxShadow: '0 4px 6px rgba(0, 0, 0, 0.1)',
            zIndex: 1000,
          }}
        >
          {results.map((customer, index) => (
            <div
              key={customer.id}
              role="option"
              aria-selected={index === highlightedIndex}
              onClick={(e) => {
                e.stopPropagation();
                e.preventDefault();
                handleSelect(customer);
              }}
              style={{
                padding: '0.75rem',
                cursor: 'pointer',
                backgroundColor:
                  index === highlightedIndex ? '#f3f4f6' : 'white',
                borderBottom:
                  index < results.length - 1 ? '1px solid #e5e7eb' : 'none',
              }}
              onMouseEnter={() => setHighlightedIndex(index)}
            >
              <div style={{ fontWeight: '500' }}>{customer.name}</div>
              <div style={{ fontSize: '0.875rem', color: '#6b7280' }}>
                Codice: {customer.code}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

3. **Run tests**: Ensure all tests pass

Key features implemented:
- ✅ 300ms debounced search
- ✅ Keyboard navigation (arrows, enter, escape)
- ✅ Click outside to close
- ✅ Loading and error states
- ✅ Selected customer confirmation
- ✅ ARIA labels for accessibility
- ✅ Inline styles (project convention)

DO NOT over-engineer - keep it simple and focused.
AVOID external dependencies (use plain React).
  </action>
  <verify>
1. `npm test CustomerSelector.spec.tsx` passes
2. All keyboard navigation tests passing
3. Debouncing working correctly (300ms delay)
4. Dropdown closes on outside click
5. Selected customer confirmation visible
6. ARIA attributes present for accessibility
  </verify>
  <done>CustomerSelector component implemented with passing tests</done>
</task>

<task type="auto">
  <name>Task 2: Build ProductSelector component with article code search</name>
  <files>archibald-web-app/frontend/src/components/new-order-form/ProductSelector.tsx (new), archibald-web-app/frontend/src/components/new-order-form/ProductSelector.spec.tsx (new)</files>
  <action>
Similar to CustomerSelector, but with additional features:

1. **Create test file first**: `ProductSelector.spec.tsx`

Tests (similar to CustomerSelector plus):
- Search by product name works
- Search by article code works
- Displays article code + description in dropdown
- Shows product variants in dropdown (if needed)
- Loading and error states

2. **Implement ProductSelector**: `ProductSelector.tsx`

Follow same pattern as CustomerSelector, with these differences:

```typescript
interface ProductSelectorProps {
  onSelect: (product: Product) => void;
  placeholder?: string;
  disabled?: boolean;
  searchFn?: (query: string) => Promise<Product[]>;
}

export function ProductSelector({ ... }: ProductSelectorProps) {
  // Same structure as CustomerSelector

  // Key difference: Dropdown shows article code + description
  return (
    <div style={{ position: 'relative', width: '100%' }}>
      <div style={{ marginBottom: '0.5rem' }}>
        <label htmlFor="product-search" style={{ ... }}>
          Prodotto
        </label>
        <input
          ref={inputRef}
          id="product-search"
          type="text"
          value={searchQuery}
          onChange={(e) => setSearchQuery(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="Cerca prodotto per nome o codice articolo..."
          aria-label="Cerca prodotto"
          style={{ ... }}
        />
      </div>

      {/* Dropdown with richer display */}
      {showDropdown && results.length > 0 && (
        <div ref={dropdownRef} role="listbox" style={{ ... }}>
          {results.map((product, index) => (
            <div
              key={product.id}
              role="option"
              onClick={(e) => {
                e.stopPropagation();
                e.preventDefault();
                handleSelect(product);
              }}
              style={{ ... }}
            >
              <div style={{ fontWeight: '500' }}>{product.name}</div>
              {product.article && (
                <div style={{ fontSize: '0.875rem', color: '#6b7280' }}>
                  Codice: {product.article}
                </div>
              )}
              {product.description && (
                <div style={{ fontSize: '0.75rem', color: '#9ca3af' }}>
                  {product.description}
                </div>
              )}
            </div>
          ))}
        </div>
      )}

      {/* Selected Product Confirmation */}
      {selectedProduct && !showDropdown && (
        <div style={{ ... }}>
          ✅ Prodotto selezionato: <strong>{selectedProduct.name}</strong>
          {selectedProduct.article && (
            <span style={{ marginLeft: '0.5rem', color: '#6b7280' }}>
              ({selectedProduct.article})
            </span>
          )}
        </div>
      )}
    </div>
  );
}
```

3. **Run tests**: Ensure all tests pass
  </action>
  <verify>
1. `npm test ProductSelector.spec.tsx` passes
2. Search by name working
3. Search by article code working
4. Dropdown shows name + article + description
5. Keyboard navigation working
6. Selected product confirmation visible
  </verify>
  <done>ProductSelector component implemented with passing tests</done>
</task>

<task type="auto">
  <name>Task 3: Build QuantityInput component with variant validation</name>
  <files>archibald-web-app/frontend/src/components/new-order-form/QuantityInput.tsx (new), archibald-web-app/frontend/src/components/new-order-form/QuantityInput.spec.tsx (new)</files>
  <action>
Quantity input with variant-aware validation:

1. **Create test file first**: `QuantityInput.spec.tsx`

Tests:
- Renders number input
- Displays variant constraints (min/max/multiples)
- Validates quantity against constraints
- Shows error for quantity below minQty
- Shows warning for quantity not multiple of multipleQty
- Shows error for quantity above maxQty
- Displays package content info
- Calls onChange with valid quantity

2. **Implement QuantityInput**: `QuantityInput.tsx`

```typescript
import { useState, useEffect } from 'react';
import type { ProductVariant } from '../../db/schema';

interface QuantityInputProps {
  productId: string;
  variant: ProductVariant | null;
  value: number;
  onChange: (quantity: number, isValid: boolean) => void;
  disabled?: boolean;
}

export function QuantityInput({
  productId,
  variant,
  value,
  onChange,
  disabled = false,
}: QuantityInputProps) {
  const [inputValue, setInputValue] = useState(value.toString());
  const [validationError, setValidationError] = useState<string | null>(null);

  useEffect(() => {
    setInputValue(value.toString());
  }, [value]);

  const validateQuantity = (qty: number): string | null => {
    if (!variant) {
      return null; // No variant selected yet
    }

    if (qty < variant.minQty) {
      return `Quantità minima: ${variant.minQty}`;
    }

    if (qty > variant.maxQty) {
      return `Quantità massima: ${variant.maxQty}`;
    }

    if (variant.multipleQty > 1 && qty % variant.multipleQty !== 0) {
      return `Quantità deve essere multiplo di ${variant.multipleQty}`;
    }

    return null; // Valid
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const rawValue = e.target.value;
    setInputValue(rawValue);

    const numValue = parseInt(rawValue, 10);

    if (isNaN(numValue) || numValue <= 0) {
      setValidationError('Quantità non valida');
      onChange(0, false);
      return;
    }

    const error = validateQuantity(numValue);
    setValidationError(error);
    onChange(numValue, error === null);
  };

  return (
    <div style={{ width: '100%' }}>
      <div style={{ marginBottom: '0.5rem' }}>
        <label
          htmlFor={`quantity-${productId}`}
          style={{
            display: 'block',
            marginBottom: '0.25rem',
            fontWeight: '500',
            fontSize: '0.875rem',
          }}
        >
          Quantità
        </label>
        <input
          id={`quantity-${productId}`}
          type="number"
          value={inputValue}
          onChange={handleChange}
          disabled={disabled}
          min={variant?.minQty || 1}
          max={variant?.maxQty || undefined}
          step={variant?.multipleQty || 1}
          aria-label="Quantità"
          aria-invalid={validationError !== null}
          aria-describedby={
            validationError ? `quantity-error-${productId}` : undefined
          }
          style={{
            width: '100%',
            padding: '0.5rem',
            fontSize: '1rem',
            border: validationError ? '1px solid #dc2626' : '1px solid #ccc',
            borderRadius: '4px',
            outline: 'none',
          }}
        />
      </div>

      {/* Variant Constraints Info */}
      {variant && (
        <div
          style={{
            padding: '0.5rem',
            backgroundColor: '#f3f4f6',
            borderRadius: '4px',
            fontSize: '0.875rem',
            color: '#4b5563',
            marginBottom: '0.5rem',
          }}
        >
          <div>
            <strong>Confezione:</strong> {variant.packageContent}
          </div>
          <div>
            <strong>Range:</strong> {variant.minQty} - {variant.maxQty} unità
          </div>
          {variant.multipleQty > 1 && (
            <div>
              <strong>Multiplo:</strong> {variant.multipleQty}
            </div>
          )}
        </div>
      )}

      {/* Validation Error */}
      {validationError && (
        <div
          id={`quantity-error-${productId}`}
          role="alert"
          style={{
            padding: '0.5rem',
            backgroundColor: '#fee2e2',
            border: '1px solid #dc2626',
            borderRadius: '4px',
            fontSize: '0.875rem',
            color: '#991b1b',
          }}
        >
          {validationError}
        </div>
      )}
    </div>
  );
}
```

3. **Run tests**: Ensure validation logic works correctly

Key features:
- ✅ Variant constraints displayed
- ✅ Validation against minQty/maxQty/multipleQty
- ✅ Clear error messages in Italian
- ✅ Package content info shown
- ✅ ARIA attributes for accessibility
- ✅ onChange callback with validity flag
  </action>
  <verify>
1. `npm test QuantityInput.spec.tsx` passes
2. Validation logic correct for all edge cases
3. Constraints displayed clearly
4. Error messages helpful and in Italian
5. ARIA attributes present
6. Component works with keyboard-only input
  </verify>
  <done>QuantityInput component implemented with variant validation</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Customer and product selection components with autocomplete and variant validation</what-built>
  <how-to-verify>
1. Run the app: `cd archibald-web-app/frontend && npm run dev`
2. Create a test page to render components (or integrate in WIP OrderForm)
3. **Test CustomerSelector**:
   a. Type in customer input field
   b. Verify dropdown appears after 300ms (debounced)
   c. Type "mario" → verify customers with "Mario" in name appear
   d. Navigate with arrow keys → verify highlighting works
   e. Press Enter or click → verify customer selected
   f. Verify confirmation message appears: "✅ Cliente selezionato: [name]"
   g. Verify dropdown closes after selection
   h. Click outside dropdown → verify it closes
   i. Test on mobile device or responsive mode → verify touch-friendly
4. **Test ProductSelector**:
   a. Type product name (e.g., "vite") → verify products appear
   b. Type article code (e.g., "h129") → verify products appear
   c. Verify dropdown shows: name, article code, description
   d. Keyboard navigation working
   e. Selection confirmation appears
   f. Mobile-friendly
5. **Test QuantityInput**:
   a. Select a product (to get variant)
   b. Verify variant constraints displayed (min/max/multiples, package content)
   c. Enter quantity below minQty → verify error message
   d. Enter quantity above maxQty → verify error message
   e. Enter quantity not multiple of multipleQty → verify error message
   f. Enter valid quantity → verify no error, onChange called
6. **Performance Test**:
   a. Type rapidly in customer search
   b. Verify debouncing works (search not triggered on every keystroke)
   c. Open dropdown with 50+ results → verify smooth scrolling
   d. Verify autocomplete feels fast (<100ms perceived)
7. **Accessibility Test**:
   a. Tab through components → verify logical focus order
   b. Use only keyboard (no mouse) → verify full functionality
   c. Check ARIA attributes in DevTools
   d. Test with screen reader (if available)

**Expected Results:**
- ✅ Customer autocomplete working, fast, accurate
- ✅ Product autocomplete working, searches by name and article
- ✅ Quantity validation working for all edge cases
- ✅ Debouncing working (300ms)
- ✅ Keyboard navigation working
- ✅ Mobile-friendly (touch targets, responsive)
- ✅ Accessible (ARIA labels, keyboard-only)
- ✅ Error messages clear and helpful (Italian)
  </how-to-verify>
  <resume-signal>Type "approved" if all components working correctly, or describe specific UX issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] CustomerSelector implemented with tests
- [ ] ProductSelector implemented with tests
- [ ] QuantityInput implemented with variant validation
- [ ] All unit tests passing
- [ ] Debouncing working (300ms)
- [ ] Keyboard navigation working (arrows, enter, escape)
- [ ] ARIA attributes present
- [ ] User verified UX (fast, accurate, mobile-friendly)
</verification>

<success_criteria>
- All 3 components implemented with comprehensive test coverage
- Autocomplete feels fast (<100ms perceived latency)
- Debouncing prevents excessive re-renders
- Keyboard navigation fully functional
- Mobile-friendly with large touch targets
- Accessible with ARIA labels and screen reader support
- Variant validation logic correct
- User satisfied with UX
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-03-SUMMARY.md`:

# Phase 28.2 Plan 03: Customer & Product Selection - Summary

**Selection components complete - fast autocomplete with variant validation**

## Accomplishments

- Built CustomerSelector with 300ms debounced autocomplete
- Built ProductSelector with name + article code search
- Built QuantityInput with variant-aware validation
- Comprehensive test coverage for all components
- Keyboard navigation working (arrows, enter, escape)
- ARIA attributes for accessibility
- Mobile-friendly with touch targets
- User verified UX - fast, accurate, intuitive

## Files Created

- `archibald-web-app/frontend/src/components/new-order-form/CustomerSelector.tsx`
- `archibald-web-app/frontend/src/components/new-order-form/CustomerSelector.spec.tsx`
- `archibald-web-app/frontend/src/components/new-order-form/ProductSelector.tsx`
- `archibald-web-app/frontend/src/components/new-order-form/ProductSelector.spec.tsx`
- `archibald-web-app/frontend/src/components/new-order-form/QuantityInput.tsx`
- `archibald-web-app/frontend/src/components/new-order-form/QuantityInput.spec.tsx`

## Component Features

**CustomerSelector:**
- ✅ Debounced search (300ms)
- ✅ Displays customer name + code
- ✅ Keyboard navigation
- ✅ Click outside to close
- ✅ Loading and error states
- ✅ Selected confirmation

**ProductSelector:**
- ✅ Search by name or article code
- ✅ Displays name + article + description
- ✅ Same UX as CustomerSelector
- ✅ Keyboard navigation
- ✅ Selected confirmation

**QuantityInput:**
- ✅ Variant constraints displayed (min/max/multiples)
- ✅ Package content info
- ✅ Validation against variant rules
- ✅ Clear error messages (Italian)
- ✅ onChange callback with validity flag

## Test Results

- ✅ CustomerSelector: [X] tests passing
- ✅ ProductSelector: [X] tests passing
- ✅ QuantityInput: [X] tests passing
- ✅ Debouncing working correctly
- ✅ Keyboard navigation functional
- ✅ Accessibility tested (ARIA, keyboard-only)

## User Feedback

[Document user's UX feedback from checkpoint]

## Issues Encountered

[Document any issues, or "None"]

## Next Step

Ready for 28.2-04-PLAN.md (Multi-Article & Discounts)

**Execute**: `/gsd:execute-plan .planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-04-PLAN.md`
</output>
