# OrderForm - New Architecture Design

**Design Date:** 2026-01-23
**Phase:** 28.2 (Rewrite OrderForm with Proper Architecture)
**Plan:** 01 (Codebase Analysis & Architecture Design)

---

## Executive Summary

This document defines the **new architecture** for OrderForm based on:
- **Separation of Concerns:** Data, Logic, UI cleanly separated
- **Testability:** Each layer independently testable
- **Modularity:** Components < 300 lines, single responsibility
- **Offline-First:** PWA architecture with background sync
- **Extensibility:** Ready for future voice input integration (Phase 28.3)

**Design Principles:**
1. **Cache-First:** IndexedDB → API fallback
2. **Context API:** Shared state without prop drilling
3. **Custom Hooks:** Reusable business logic
4. **Pure Functions:** Testable utilities
5. **Atomic Commits:** One commit per task

---

## 1. Architecture Overview

### 1.1 Three-Layer Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                      PRESENTATION LAYER                      │
│                   (React Components - UI)                    │
├─────────────────────────────────────────────────────────────┤
│  OrderFormPage                                               │
│    ├─ OrderFormProvider (Context)                           │
│    ├─ CustomerSection                                       │
│    │   └─ CustomerAutocomplete                              │
│    ├─ ProductSection                                        │
│    │   ├─ ProductAutocomplete                               │
│    │   └─ PackageConstraintsHint                            │
│    ├─ OrderItemsList                                        │
│    │   └─ OrderItemCard                                     │
│    ├─ PricingSummary                                        │
│    │   ├─ DiscountInput (optional)                          │
│    │   └─ PricingBreakdown                                  │
│    ├─ OrderActions                                          │
│    │   ├─ SaveDraftButton                                   │
│    │   └─ FinishButton                                      │
│    └─ Modals                                                │
│        ├─ ConfirmationModal                                 │
│        └─ StaleCacheWarning                                 │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                      BUSINESS LOGIC LAYER                    │
│                  (Custom Hooks + Services)                   │
├─────────────────────────────────────────────────────────────┤
│  Custom Hooks (State Management)                            │
│    ├─ useCustomerSelection                                  │
│    ├─ useProductSelection                                   │
│    ├─ useOrderItems                                         │
│    └─ usePricingCalculation                                 │
│                                                              │
│  Services (Business Logic)                                  │
│    ├─ SyncService (populate IndexedDB)                      │
│    ├─ DraftManager (unified draft system)                   │
│    ├─ PricingService (calculations)                         │
│    └─ ValidationService (constraints)                       │
└─────────────────────────────────────────────────────────────┘
                            ↕
┌─────────────────────────────────────────────────────────────┐
│                        DATA LAYER                            │
│              (IndexedDB + API + localStorage)                │
├─────────────────────────────────────────────────────────────┤
│  CacheService (IndexedDB queries)                           │
│    ├─ searchCustomers()                                     │
│    ├─ searchProducts()                                      │
│    ├─ getCacheAge()                                         │
│    └─ isCacheStale()                                        │
│                                                              │
│  API Client (Network requests)                              │
│    ├─ fetchCustomers()                                      │
│    ├─ fetchProducts()                                       │
│    └─ triggerSmartSync()                                    │
│                                                              │
│  Storage                                                     │
│    ├─ IndexedDB (ArchibaldOfflineDB)                        │
│    ├─ localStorage (drafts, auth)                           │
│    └─ Service Worker (background sync)                      │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. Component Tree

### 2.1 Page Structure

```tsx
<OrderFormPage>
  <OrderFormProvider value={orderFormContext}>
    {/* Cache Freshness Indicator */}
    <CacheFreshnessIndicator age={cacheAge} stale={cacheStale} />

    {/* Customer Selection Section */}
    <CustomerSection>
      <CustomerAutocomplete
        value={customerId}
        onChange={handleCustomerSelect}
        loading={loadingCustomers}
      />
      {customerId && (
        <SelectedCustomerBadge
          name={customerName}
          id={customerId}
        />
      )}
    </CustomerSection>

    {/* Product Selection Section */}
    <ProductSection>
      <ProductAutocomplete
        value={selectedProduct}
        onChange={handleProductSelect}
        loading={loadingProducts}
      />
      {selectedProduct && (
        <ProductDetails
          product={selectedProduct}
          constraints={packageConstraints}
        />
      )}
      <QuantityInput
        value={quantity}
        onChange={handleQuantityChange}
        constraints={packageConstraints}
      />
      <PriceInput
        value={price}
        onChange={handlePriceChange}
      />
      <DiscountInput
        value={discount}
        onChange={handleDiscountChange}
      />
      <AddItemButton onClick={handleAddItem} />
    </ProductSection>

    {/* Order Items List */}
    {orderItems.length > 0 && (
      <OrderItemsList>
        {orderItems.map((item, index) => (
          <OrderItemCard
            key={index}
            item={item}
            onEdit={() => handleEditItem(index)}
            onRemove={() => handleRemoveItem(index)}
          />
        ))}
      </OrderItemsList>
    )}

    {/* Pricing Summary */}
    {orderItems.length > 0 && (
      <PricingSummary
        items={orderItems}
        discountPercent={globalDiscount}
        targetTotal={targetTotal}
        onDiscountChange={setGlobalDiscount}
        onTargetTotalChange={setTargetTotal}
      />
    )}

    {/* Actions */}
    {orderItems.length > 0 && (
      <OrderActions>
        <SaveDraftButton
          onClick={handleSaveDraft}
          loading={saving}
        />
        <FinishButton
          onClick={() => navigate('/drafts')}
        />
      </OrderActions>
    )}

    {/* Modals */}
    <ConfirmationModal
      isOpen={showConfirmModal}
      onConfirm={handleConfirmSave}
      onCancel={() => setShowConfirmModal(false)}
      pricing={pricing}
    />

    <StaleCacheWarning
      isOpen={showStaleWarning}
      onConfirm={handleForceSubmit}
      onCancel={() => setShowStaleWarning(false)}
    />
  </OrderFormProvider>
</OrderFormPage>
```

### 2.2 Component Responsibilities

#### OrderFormPage (Container)
- **Size:** ~150 lines
- **Responsibilities:**
  - Initialize OrderFormProvider
  - Load cache on mount
  - Trigger smart sync
  - Handle navigation
- **State:** None (delegated to context)

#### CustomerSection
- **Size:** ~100 lines
- **Responsibilities:**
  - Render customer autocomplete
  - Display selected customer
  - Trigger customer loading
- **State:** Local UI state only

#### ProductSection
- **Size:** ~150 lines
- **Responsibilities:**
  - Render product autocomplete
  - Display product details
  - Collect quantity, price, discount
  - Add item to order
- **State:** Local form state (newItem)

#### OrderItemsList
- **Size:** ~80 lines
- **Responsibilities:**
  - Render list of items
  - Handle edit/remove actions
- **State:** None (reads from context)

#### PricingSummary
- **Size:** ~120 lines
- **Responsibilities:**
  - Display pricing breakdown
  - Handle discount input
  - Handle target total input
  - Show pricing errors
- **State:** Local UI state

#### OrderActions
- **Size:** ~60 lines
- **Responsibilities:**
  - Save draft button
  - Finish button
  - Loading states
- **State:** None

---

## 3. State Management

### 3.1 OrderFormContext

**File:** `frontend/src/contexts/OrderFormContext.tsx`

```tsx
interface OrderFormState {
  // Customer
  customerId: string;
  customerName: string;

  // Order Items
  orderItems: OrderItem[];

  // Pricing
  globalDiscount: number;
  targetTotal: string;
  pricing: PricingResult;

  // UI State
  loading: boolean;
  saving: boolean;

  // Cache State
  cacheAge: number | null;
  cacheStale: boolean;
}

interface OrderFormActions {
  // Customer
  setCustomer: (id: string, name: string) => void;

  // Order Items
  addItem: (item: OrderItem) => void;
  editItem: (index: number, item: OrderItem) => void;
  removeItem: (index: number) => void;
  clearItems: () => void;

  // Pricing
  setGlobalDiscount: (percent: number) => void;
  setTargetTotal: (total: string) => void;

  // Actions
  saveDraft: () => Promise<void>;
  loadDraft: (draftId: string) => Promise<void>;
}

interface OrderFormContextValue extends OrderFormState, OrderFormActions {}

const OrderFormContext = createContext<OrderFormContextValue | null>(null);

export function OrderFormProvider({ children }: { children: ReactNode }) {
  // State management
  const [state, setState] = useState<OrderFormState>(initialState);

  // Custom hooks
  const pricingService = usePricingService();
  const draftManager = useDraftManager();
  const cacheService = useCacheService();

  // Actions
  const actions: OrderFormActions = {
    setCustomer: (id, name) => {
      setState(prev => ({ ...prev, customerId: id, customerName: name }));
    },

    addItem: (item) => {
      setState(prev => ({
        ...prev,
        orderItems: [...prev.orderItems, item],
      }));
      // Recalculate pricing
      const pricing = pricingService.calculate(
        [...state.orderItems, item],
        state.targetTotal
      );
      setState(prev => ({ ...prev, pricing }));
    },

    // ... other actions
  };

  return (
    <OrderFormContext.Provider value={{ ...state, ...actions }}>
      {children}
    </OrderFormContext.Provider>
  );
}

export function useOrderForm() {
  const context = useContext(OrderFormContext);
  if (!context) {
    throw new Error('useOrderForm must be used within OrderFormProvider');
  }
  return context;
}
```

**Benefits:**
- No prop drilling
- Centralized state management
- Easy to test (mock context)
- Clear separation of state and UI

---

## 4. Custom Hooks

### 4.1 useCustomerSelection

**File:** `frontend/src/hooks/useCustomerSelection.ts`

```tsx
interface UseCustomerSelectionOptions {
  onSelect?: (customer: Customer) => void;
}

interface UseCustomerSelectionReturn {
  customers: Customer[];
  filteredCustomers: Customer[];
  searchQuery: string;
  loading: boolean;
  showDropdown: boolean;

  setSearchQuery: (query: string) => void;
  selectCustomer: (customer: Customer) => void;
  openDropdown: () => void;
  closeDropdown: () => void;
}

export function useCustomerSelection(
  options: UseCustomerSelectionOptions = {}
): UseCustomerSelectionReturn {
  const [customers, setCustomers] = useState<Customer[]>([]);
  const [searchQuery, setSearchQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const [showDropdown, setShowDropdown] = useState(false);

  // Load customers on mount
  useEffect(() => {
    loadCustomers();
  }, []);

  // Trigger smart sync
  useEffect(() => {
    triggerSmartCustomerSync();
    return () => resumeNormalSyncs();
  }, []);

  const loadCustomers = async () => {
    setLoading(true);
    try {
      // Try cache first
      const cached = await cacheService.searchCustomers("", 10000);
      if (cached.length > 0) {
        setCustomers(cached);
      } else {
        // Fallback to API
        const response = await api.fetchCustomers();
        setCustomers(response.data);
      }
    } catch (error) {
      console.error("Failed to load customers:", error);
    } finally {
      setLoading(false);
    }
  };

  const filteredCustomers = useMemo(() => {
    if (!searchQuery) return customers;
    const lower = searchQuery.toLowerCase();
    return customers.filter(
      c => c.name.toLowerCase().includes(lower) ||
           c.id.toLowerCase().includes(lower)
    );
  }, [customers, searchQuery]);

  const selectCustomer = (customer: Customer) => {
    setSearchQuery(customer.name);
    setShowDropdown(false);
    options.onSelect?.(customer);
  };

  return {
    customers,
    filteredCustomers,
    searchQuery,
    loading,
    showDropdown,
    setSearchQuery,
    selectCustomer,
    openDropdown: () => setShowDropdown(true),
    closeDropdown: () => setShowDropdown(false),
  };
}
```

**Benefits:**
- Encapsulates customer selection logic
- Reusable in other components
- Easy to test
- Clean API

### 4.2 useProductSelection

**File:** `frontend/src/hooks/useProductSelection.ts`

```tsx
interface UseProductSelectionReturn {
  products: Product[];
  filteredProducts: Product[];
  searchQuery: string;
  loading: boolean;
  showDropdown: boolean;
  selectedProduct: Product | null;
  packageConstraints: PackageConstraints | null;

  setSearchQuery: (query: string) => void;
  selectProduct: (product: Product) => void;
  clearSelection: () => void;
  openDropdown: () => void;
  closeDropdown: () => void;
}

export function useProductSelection(
  options: UseProductSelectionOptions = {}
): UseProductSelectionReturn {
  // Similar structure to useCustomerSelection
  // Additional: parse packageConstraints when product selected
}
```

### 4.3 useOrderItems

**File:** `frontend/src/hooks/useOrderItems.ts`

```tsx
interface UseOrderItemsReturn {
  items: OrderItem[];
  addItem: (item: OrderItem) => void;
  editItem: (index: number, item: OrderItem) => void;
  removeItem: (index: number) => void;
  clearItems: () => void;
  validateItem: (item: OrderItem) => ValidationResult;
}

export function useOrderItems(
  validationService: ValidationService
): UseOrderItemsReturn {
  const [items, setItems] = useState<OrderItem[]>([]);

  const validateItem = (item: OrderItem): ValidationResult => {
    return validationService.validateOrderItem(item);
  };

  const addItem = (item: OrderItem) => {
    const validation = validateItem(item);
    if (!validation.valid) {
      throw new Error(validation.error);
    }
    setItems(prev => [...prev, item]);
  };

  // ... other methods
}
```

### 4.4 usePricingCalculation

**File:** `frontend/src/hooks/usePricingCalculation.ts`

```tsx
interface UsePricingCalculationReturn {
  pricing: PricingResult;
  setGlobalDiscount: (percent: number) => void;
  setTargetTotal: (total: string) => void;
  error: string | null;
}

export function usePricingCalculation(
  items: OrderItem[]
): UsePricingCalculationReturn {
  const [globalDiscount, setGlobalDiscount] = useState(0);
  const [targetTotal, setTargetTotal] = useState("");
  const [error, setError] = useState<string | null>(null);

  const pricingService = useMemo(() => new PricingService({
    vatRate: 0.22,
    shippingCostBase: 15.45,
    shippingThreshold: 200,
  }), []);

  const pricing = useMemo(() => {
    try {
      const result = pricingService.calculate(items, targetTotal);
      setError(result.error);
      return result;
    } catch (err) {
      setError(err.message);
      return pricingService.calculate(items); // Fallback without target
    }
  }, [items, targetTotal, pricingService]);

  return {
    pricing,
    setGlobalDiscount,
    setTargetTotal,
    error,
  };
}
```

---

## 5. Service Layer

### 5.1 SyncService (NEW)

**File:** `frontend/src/services/sync-service.ts`
**Purpose:** Populate IndexedDB from API responses

```tsx
export class SyncService {
  constructor(
    private db: ArchibaldDatabase,
    private api: ApiClient
  ) {}

  /**
   * Sync products from API to IndexedDB
   */
  async syncProducts(): Promise<SyncResult> {
    const response = await this.api.fetchProducts();
    const products = response.data.products || response.data;

    await this.db.transaction(
      'rw',
      [this.db.products, this.db.productVariants, this.db.prices, this.db.cacheMetadata],
      async () => {
        // Clear old data
        await this.db.products.clear();
        await this.db.productVariants.clear();
        await this.db.prices.clear();

        // Insert products
        await this.db.products.bulkAdd(products);

        // Extract and save variants
        const variants = products.flatMap(p => p.variants || []);
        if (variants.length > 0) {
          await this.db.productVariants.bulkAdd(variants);
        }

        // Extract and save prices
        const prices = products
          .filter(p => p.price !== undefined)
          .map(p => ({
            articleId: p.id,
            articleName: p.name,
            price: p.price!,
            lastSynced: new Date().toISOString(),
          }));
        if (prices.length > 0) {
          await this.db.prices.bulkAdd(prices);
        }

        // Update metadata
        await this.db.cacheMetadata.put({
          key: "products",
          lastSynced: new Date().toISOString(),
          recordCount: products.length,
          version: 1,
        });
      }
    );

    return {
      success: true,
      recordsInserted: products.length,
      timestamp: new Date().toISOString(),
    };
  }

  /**
   * Sync customers from API to IndexedDB
   */
  async syncCustomers(): Promise<SyncResult> {
    // Similar to syncProducts
  }

  /**
   * Check if sync is needed
   */
  async needsSync(entityType: 'products' | 'customers'): Promise<boolean> {
    const metadata = await this.db.cacheMetadata.get(entityType);
    if (!metadata) return true; // No cache

    const age = Date.now() - new Date(metadata.lastSynced).getTime();
    const ageHours = age / 1000 / 60 / 60;

    return ageHours > 72; // Stale if > 3 days
  }
}
```

**Usage:**
```tsx
// In OrderFormProvider or App.tsx
useEffect(() => {
  const syncService = new SyncService(db, api);

  async function init() {
    if (await syncService.needsSync('products')) {
      await syncService.syncProducts();
    }
    if (await syncService.needsSync('customers')) {
      await syncService.syncCustomers();
    }
  }

  init();
}, []);
```

### 5.2 DraftManager (NEW - Consolidation)

**File:** `frontend/src/services/draft-manager.ts`
**Purpose:** Unified draft system (replaces DraftService + DraftOrderStorage)

```tsx
export class DraftManager {
  private storage: 'localStorage' | 'indexedDB';

  constructor(storage: 'localStorage' | 'indexedDB' = 'localStorage') {
    this.storage = storage;
  }

  async saveDraft(draft: DraftOrderData): Promise<DraftOrder> {
    if (this.storage === 'localStorage') {
      return this.saveToLocalStorage(draft);
    } else {
      return this.saveToIndexedDB(draft);
    }
  }

  async loadDraft(draftId: string): Promise<DraftOrder | null> {
    if (this.storage === 'localStorage') {
      return this.loadFromLocalStorage(draftId);
    } else {
      return this.loadFromIndexedDB(draftId);
    }
  }

  async listDrafts(): Promise<DraftOrder[]> {
    if (this.storage === 'localStorage') {
      return this.listFromLocalStorage();
    } else {
      return this.listFromIndexedDB();
    }
  }

  async deleteDraft(draftId: string): Promise<boolean> {
    if (this.storage === 'localStorage') {
      return this.deleteFromLocalStorage(draftId);
    } else {
      return this.deleteFromIndexedDB(draftId);
    }
  }

  /**
   * Migrate drafts from IndexedDB to localStorage
   */
  async migrate(): Promise<void> {
    const indexedDBDrafts = await this.listFromIndexedDB();
    for (const draft of indexedDBDrafts) {
      await this.saveToLocalStorage(draft);
    }
    // Clear IndexedDB after migration
    await db.draftOrders.clear();
  }

  /**
   * Clean up expired drafts (> 30 days)
   */
  async cleanup(): Promise<number> {
    const drafts = await this.listDrafts();
    const now = Date.now();
    const THIRTY_DAYS_MS = 30 * 24 * 60 * 60 * 1000;

    let deletedCount = 0;
    for (const draft of drafts) {
      const age = now - new Date(draft.createdAt).getTime();
      if (age > THIRTY_DAYS_MS) {
        await this.deleteDraft(draft.id);
        deletedCount++;
      }
    }

    return deletedCount;
  }

  // Private implementation methods...
}
```

### 5.3 PricingService

**File:** `frontend/src/services/pricing-service.ts`
**Purpose:** Extract pricing calculation logic

```tsx
export interface PricingConfig {
  vatRate: number;
  shippingCostBase: number;
  shippingThreshold: number;
}

export interface PricingResult {
  subtotalItems: number;
  shippingBase: number;
  shippingWithVAT: number;
  discountPercent: number;
  subtotalAfterDiscount: number;
  totalWithVAT: number;
  error: string | null;
}

export class PricingService {
  constructor(private config: PricingConfig) {}

  calculate(
    items: OrderItem[],
    targetTotalWithVAT?: string
  ): PricingResult {
    // Extract 99-line logic from OrderForm.tsx
    // Same calculation, but now testable and reusable
  }

  validateDiscount(discountPercent: number): boolean {
    return discountPercent >= 0 && discountPercent <= 100;
  }

  formatPrice(amount: number): string {
    return `€${amount.toFixed(2)}`;
  }
}
```

### 5.4 ValidationService

**File:** `frontend/src/services/validation-service.ts`
**Purpose:** Centralize validation logic

```tsx
export class ValidationService {
  validateOrderItem(item: OrderItem): ValidationResult {
    if (!item.articleCode) {
      return { valid: false, error: "Codice articolo mancante" };
    }
    if (item.quantity <= 0) {
      return { valid: false, error: "Quantità deve essere > 0" };
    }
    return { valid: true };
  }

  validatePackageConstraints(
    quantity: number,
    constraints: PackageConstraints
  ): ValidationResult {
    if (quantity < constraints.minQty) {
      return {
        valid: false,
        error: `Quantità minima: ${constraints.minQty}`,
      };
    }

    if (quantity % constraints.multipleQty !== 0) {
      return {
        valid: false,
        error: `Quantità deve essere multiplo di ${constraints.multipleQty}`,
        suggestions: [
          Math.floor(quantity / constraints.multipleQty) * constraints.multipleQty,
          Math.ceil(quantity / constraints.multipleQty) * constraints.multipleQty,
        ],
      };
    }

    if (constraints.maxQty && quantity > constraints.maxQty) {
      return {
        valid: false,
        error: `Quantità massima: ${constraints.maxQty}`,
      };
    }

    return { valid: true };
  }
}
```

---

## 6. Reusable Components

### 6.1 AutocompleteDropdown<T>

**File:** `frontend/src/components/common/AutocompleteDropdown.tsx`

```tsx
interface AutocompleteDropdownProps<T> {
  items: T[];
  value: string;
  onChange: (value: string) => void;
  onSelect: (item: T) => void;
  renderItem: (item: T) => ReactNode;
  getItemKey: (item: T) => string;
  loading?: boolean;
  placeholder?: string;
  disabled?: boolean;
}

export function AutocompleteDropdown<T>(
  props: AutocompleteDropdownProps<T>
) {
  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const [showDropdown, setShowDropdown] = useState(false);

  // Click outside handler
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        !inputRef.current?.contains(event.target as Node) &&
        !dropdownRef.current?.contains(event.target as Node)
      ) {
        setShowDropdown(false);
      }
    };

    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Keyboard navigation
  const handleKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Escape") {
      setShowDropdown(false);
    }
    // Add Arrow Up/Down, Enter support
  };

  return (
    <div className="autocomplete-container">
      <input
        ref={inputRef}
        type="text"
        value={props.value}
        onChange={(e) => props.onChange(e.target.value)}
        onFocus={() => setShowDropdown(true)}
        onKeyDown={handleKeyDown}
        placeholder={props.placeholder}
        disabled={props.disabled || props.loading}
        autoComplete="off"
      />

      {showDropdown && props.items.length > 0 && (
        <div ref={dropdownRef} className="autocomplete-dropdown">
          {props.items.slice(0, 10).map((item) => (
            <div
              key={props.getItemKey(item)}
              className="autocomplete-item"
              onClick={() => {
                props.onSelect(item);
                setShowDropdown(false);
              }}
            >
              {props.renderItem(item)}
            </div>
          ))}
        </div>
      )}

      {props.loading && <div className="autocomplete-loading">Caricamento...</div>}
    </div>
  );
}
```

**Usage:**
```tsx
<AutocompleteDropdown
  items={filteredCustomers}
  value={searchQuery}
  onChange={setSearchQuery}
  onSelect={selectCustomer}
  getItemKey={(c) => c.id}
  renderItem={(c) => (
    <>
      <div className="name">{c.name}</div>
      <div className="id">ID: {c.id}</div>
    </>
  )}
  loading={loading}
  placeholder="Cerca cliente..."
/>
```

### 6.2 ConfirmationModal

**File:** `frontend/src/components/common/ConfirmationModal.tsx`

```tsx
interface ConfirmationModalProps {
  isOpen: boolean;
  title: string;
  children: ReactNode;
  onConfirm: () => void;
  onCancel: () => void;
  confirmText?: string;
  cancelText?: string;
  loading?: boolean;
}

export function ConfirmationModal(props: ConfirmationModalProps) {
  if (!props.isOpen) return null;

  return (
    <div className="modal-overlay" onClick={props.onCancel}>
      <div className="modal-content" onClick={(e) => e.stopPropagation()}>
        <h2>{props.title}</h2>
        <div className="modal-body">{props.children}</div>
        <div className="modal-footer">
          <button
            className="btn btn-secondary"
            onClick={props.onCancel}
            disabled={props.loading}
          >
            {props.cancelText || "Annulla"}
          </button>
          <button
            className="btn btn-primary"
            onClick={props.onConfirm}
            disabled={props.loading}
          >
            {props.loading ? "Salvataggio..." : props.confirmText || "Conferma"}
          </button>
        </div>
      </div>
    </div>
  );
}
```

---

## 7. Data Flow (New Architecture)

### 7.1 Application Startup

```
App.tsx Mount
    ↓
Initialize SyncService
    ↓
Check if sync needed (> 3 days)
    ↓
YES: Sync products + customers → IndexedDB
NO: Skip sync
    ↓
IndexedDB populated and ready
```

### 7.2 OrderForm Flow

```
OrderFormPage Mount
    ↓
Initialize OrderFormProvider
    ↓
Load cache age/staleness
    ↓
Trigger Smart Customer Sync (background)
    ↓
useCustomerSelection loads customers from IndexedDB
    ↓
useProductSelection loads products from IndexedDB
    ↓
User selects customer → Context updated
    ↓
User selects product → Parse constraints → Add to items
    ↓
usePricingCalculation recalculates on items change
    ↓
User clicks "Save Draft"
    ↓
DraftManager.saveDraft(draft)
    ↓
Navigate to /drafts
```

### 7.3 Draft Loading Flow

```
OrderFormPage Mount with ?draftId=xyz
    ↓
useEffect detects draftId query param
    ↓
DraftManager.loadDraft(draftId)
    ↓
Populate context:
  - setCustomer(draft.customerId, draft.customerName)
  - draft.items.forEach(addItem)
  - setGlobalDiscount(draft.discountPercent)
  - setTargetTotal(draft.targetTotalWithVAT)
    ↓
Form populated and ready for editing
```

---

## 8. Testing Strategy

### 8.1 Unit Tests

**Services:**
```tsx
// pricing-service.test.ts
describe('PricingService', () => {
  it('calculates subtotal correctly', () => {
    const service = new PricingService(config);
    const items = [
      { price: 10, quantity: 2, discount: 0 },
      { price: 20, quantity: 1, discount: 0 },
    ];
    const result = service.calculate(items);
    expect(result.subtotalItems).toBe(40);
  });

  it('applies VAT correctly', () => {
    const service = new PricingService(config);
    const items = [{ price: 100, quantity: 1, discount: 0 }];
    const result = service.calculate(items);
    expect(result.totalWithVAT).toBe(137.45); // 100 * 1.22 + 15.45
  });

  it('reverse calculates discount from target total', () => {
    const service = new PricingService(config);
    const items = [{ price: 100, quantity: 1, discount: 0 }];
    const result = service.calculate(items, "122.00");
    expect(result.discountPercent).toBeCloseTo(10, 1); // ~10% discount
  });
});
```

**Validation:**
```tsx
// validation-service.test.ts
describe('ValidationService', () => {
  it('validates package constraints', () => {
    const service = new ValidationService();
    const constraints = { minQty: 10, multipleQty: 5, maxQty: 100 };

    // Valid
    expect(service.validatePackageConstraints(15, constraints).valid).toBe(true);

    // Too low
    expect(service.validatePackageConstraints(5, constraints).valid).toBe(false);

    // Not multiple
    expect(service.validatePackageConstraints(12, constraints).valid).toBe(false);

    // Too high
    expect(service.validatePackageConstraints(150, constraints).valid).toBe(false);
  });
});
```

### 8.2 Integration Tests

**OrderForm Flow:**
```tsx
// OrderForm.integration.test.tsx
describe('OrderForm Integration', () => {
  it('creates order with 2 items', async () => {
    const { getByPlaceholderText, getByText } = render(
      <OrderFormProvider>
        <OrderFormPage />
      </OrderFormProvider>
    );

    // Select customer
    const customerInput = getByPlaceholderText('Cerca cliente...');
    await userEvent.type(customerInput, 'Mario Rossi');
    await userEvent.click(getByText('Mario Rossi'));

    // Add first item
    const productInput = getByPlaceholderText('Cerca prodotto...');
    await userEvent.type(productInput, 'TD1272.314');
    await userEvent.click(getByText('TD1272.314'));
    await userEvent.type(getByPlaceholderText('Quantità'), '2');
    await userEvent.click(getByText('Aggiungi Articolo'));

    // Add second item
    await userEvent.clear(productInput);
    await userEvent.type(productInput, 'SF1000');
    await userEvent.click(getByText('SF1000'));
    await userEvent.type(getByPlaceholderText('Quantità'), '5');
    await userEvent.click(getByText('Aggiungi Articolo'));

    // Verify items in list
    expect(getByText('TD1272.314')).toBeInTheDocument();
    expect(getByText('SF1000')).toBeInTheDocument();

    // Save draft
    await userEvent.click(getByText('Salva Bozza'));

    // Verify draft saved
    expect(mockDraftManager.saveDraft).toHaveBeenCalledWith({
      customerId: expect.any(String),
      customerName: 'Mario Rossi',
      items: expect.arrayContaining([
        expect.objectContaining({ articleCode: 'TD1272.314', quantity: 2 }),
        expect.objectContaining({ articleCode: 'SF1000', quantity: 5 }),
      ]),
    });
  });
});
```

---

## 9. Future Extensibility

### 9.1 Voice Input Integration (Phase 28.3)

**Design:** Plugin architecture with callbacks

```tsx
// OrderFormPage.tsx
<OrderFormProvider>
  {/* Optional Voice Input Button */}
  {isVoiceSupported && (
    <VoiceInputButton
      onOrderParsed={(parsed) => {
        // Callback: populate form with voice data
        if (parsed.customerId) {
          orderForm.setCustomer(parsed.customerId, parsed.customerName);
        }
        parsed.items.forEach((item) => {
          orderForm.addItem({
            articleCode: item.articleCode,
            quantity: item.quantity,
            price: 0, // Will be populated by backend
            discount: 0,
          });
        });
      }}
    />
  )}

  {/* Rest of form... */}
</OrderFormProvider>
```

**Benefits:**
- Voice input completely decoupled
- OrderForm doesn't know about voice
- Easy to add/remove voice feature
- Can use different voice implementations (Web Speech API, Whisper, etc.)

### 9.2 Barcode Scanner Integration (Future)

```tsx
<BarcodeScanner
  onScan={(barcode) => {
    // Look up product by barcode
    const product = await api.getProductByBarcode(barcode);
    if (product) {
      orderForm.addItem({
        articleCode: product.articleCode,
        quantity: 1,
        price: product.price,
        discount: 0,
      });
    }
  }}
/>
```

### 9.3 Bulk Import (Future)

```tsx
<BulkImportButton
  onImport={(items) => {
    items.forEach((item) => orderForm.addItem(item));
  }}
/>
```

---

## 10. Migration Path

### 10.1 Feature Flag Strategy

```tsx
// App.tsx or router
const useNewOrderForm = localStorage.getItem('feature_new_orderform') === 'true';

<Route path="/order-form">
  {useNewOrderForm ? <OrderFormNew /> : <OrderFormOld />}
</Route>
```

### 10.2 Gradual Rollout

**Phase 1:** Internal testing
- Enable for admin users only
- Test all flows
- Fix bugs

**Phase 2:** Beta testing
- Enable for 10% of users
- Monitor error rates
- Collect feedback

**Phase 3:** Full rollout
- Enable for 100% of users
- Remove old OrderForm
- Clean up feature flag

---

## 11. Success Metrics

### 11.1 Code Quality

| Metric | Before | Target | Notes |
|--------|--------|--------|-------|
| Largest component | 2,705 lines | < 300 lines | OrderFormPage |
| State per component | 40 states | < 10 states | Context-based |
| useEffect per component | 22 effects | < 5 effects | Custom hooks |
| Coupling score (avg) | 6.0/10 | < 4.0/10 | Service abstraction |
| Test coverage | 0% | > 80% | Unit + integration |

### 11.2 Performance

| Metric | Before | Target | Notes |
|--------|--------|--------|-------|
| IndexedDB products | 0 records | > 5,000 records | Fixed sync |
| Page load time | ~2s (API fallback) | < 500ms (cache) | IndexedDB first |
| Form render time | ~300ms | < 100ms | Optimized re-renders |

### 11.3 User Experience

| Metric | Before | Target | Notes |
|--------|--------|--------|-------|
| Product dropdown | Broken (0 items) | Working (5000+ items) | Fixed cache |
| Customer selection | Race condition | Smooth | Proper state mgmt |
| Offline support | Broken | Working | PWA + IndexedDB |

---

## 12. Key Design Decisions

### 12.1 Context API vs Redux

**Decision:** Context API
**Rationale:**
- Simpler for this use case
- No global state needed
- Easier to test
- Less boilerplate

### 12.2 localStorage vs IndexedDB for Drafts

**Decision:** localStorage
**Rationale:**
- Simpler API
- No schema migrations
- Sufficient for draft storage
- Easier quota management

### 12.3 Custom Hooks vs HOCs

**Decision:** Custom Hooks
**Rationale:**
- Modern React pattern
- Better TypeScript support
- Easier to compose
- Cleaner syntax

### 12.4 Services vs Utilities

**Decision:** Service classes for stateful logic, pure functions for stateless
**Rationale:**
- Services: SyncService, DraftManager (manage state/side effects)
- Utilities: pricing calculations, validation (pure functions)
- Clear separation of concerns

---

## 13. Architecture Summary

### 13.1 Component Count

- **Pages:** 1 (OrderFormPage)
- **Sections:** 4 (Customer, Product, ItemsList, PricingSummary)
- **Common Components:** 6 (Autocomplete, Modal, Badge, Card, Button, Input)
- **Total:** ~11 components (vs 1 monolith)

### 13.2 Service Count

- **SyncService:** IndexedDB population
- **DraftManager:** Unified draft system
- **PricingService:** Calculations
- **ValidationService:** Constraints
- **Total:** 4 services

### 13.3 Hook Count

- **useCustomerSelection:** Customer autocomplete logic
- **useProductSelection:** Product autocomplete logic
- **useOrderItems:** Items management
- **usePricingCalculation:** Pricing logic
- **Total:** 4 custom hooks

### 13.4 Lines of Code Estimate

| Component/Service | Lines | Notes |
|-------------------|-------|-------|
| OrderFormPage | 150 | Container |
| CustomerSection | 100 | UI |
| ProductSection | 150 | UI |
| OrderItemsList | 80 | UI |
| PricingSummary | 120 | UI |
| OrderActions | 60 | UI |
| OrderFormContext | 200 | State management |
| useCustomerSelection | 120 | Hook |
| useProductSelection | 120 | Hook |
| useOrderItems | 80 | Hook |
| usePricingCalculation | 100 | Hook |
| SyncService | 150 | Service |
| DraftManager | 200 | Service |
| PricingService | 120 | Service |
| ValidationService | 80 | Service |
| AutocompleteDropdown | 120 | Common |
| ConfirmationModal | 80 | Common |
| **TOTAL** | **~1,930 lines** | vs 2,705 before |

**Reduction:** ~30% fewer lines, but with:
- Better separation
- Higher testability
- Cleaner architecture
- Easier maintenance

---

**End of Architecture Design**
