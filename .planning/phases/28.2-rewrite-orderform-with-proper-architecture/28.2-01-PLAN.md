---
phase: 28.2-rewrite-orderform-with-proper-architecture
plan: 01
type: research
---

<objective>
Analyze existing OrderForm.tsx implementation (2705 lines), map data flow from sync orchestrator through IndexedDB to form, and design new architecture with clean separation of concerns.

Purpose: Understand current pain points and create architecture blueprint for complete rewrite.
Output: Architecture design document with component tree, service layer contracts, state management approach, and migration strategy.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-CONTEXT.md

**Business Context:**
- OrderForm instabile con bug critici ricorrenti (race conditions, filtering broken, white screen crash)
- User frustrated: "sto perdendo tempo e soldi su questa problematica ed è inaccettabile"
- Root cause: Architettura fondamentalmente problematica - IndexedDB vuoto, sync disconnesso, state management complesso

**Current State:**
- OrderForm.tsx: 2705 lines (monolithic component)
- IndexedDB products table: 0 records (sync not populating)
- Sync orchestrator exists (Phases 22-25) but disconnected from form
- Customer selection: Race condition fixed in 28.1-01 but architecture fragile
- Product filtering: Broken because IndexedDB empty

**Requirements (from CONTEXT.md):**
1. Customer selection by NOME (autocomplete, ~1500 records)
2. Product selection by NOME ARTICOLO (autocomplete, ~5000 records)
3. Multi-article support (1-N items per order)
4. Quantity + variant management with multiples
5. Dual discount system (inline + global with reverse calculation)
6. Real-time summary (totals, VAT display)
7. Edit/delete items
8. Pending orders queue with batch bot submission
9. Offline support (create offline, sync when online)

**Key Files to Analyze:**
- archibald-web-app/frontend/src/components/OrderForm.tsx (2705 lines)
- archibald-web-app/frontend/src/services/cache-service.ts (IndexedDB wrapper)
- archibald-web-app/frontend/src/services/draft-service.ts (Draft order storage)
- archibald-web-app/frontend/src/db/schema.ts (Dexie schema)
- archibald-web-app/backend/src/routes/products.ts (Product API)
- archibald-web-app/backend/src/routes/customers.ts (Customer API)

**Architecture Constraints:**
- React + TypeScript (existing stack)
- IndexedDB + Dexie.js (Phase 8 architecture)
- Inline styles (project convention)
- Sync Orchestrator (Phase 22-25)
- Offline-first PWA pattern
</context>

<tasks>

<task type="auto">
  <name>Task 1: Comprehensive OrderForm.tsx Analysis</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx</files>
  <action>
Read OrderForm.tsx in segments and document:

1. **Component Structure**:
   - State variables (count them - how many useState/useRef hooks?)
   - useEffect dependencies and purposes
   - Event handlers and callbacks
   - Render logic complexity

2. **Data Flow**:
   - Customer loading: How are customers fetched? Cache-first? API fallback?
   - Product loading: How are products fetched? Where does IndexedDB come in?
   - Order submission: What happens when user submits? Where does data go?
   - Draft orders: How are drafts saved/loaded?

3. **Pain Points**:
   - Lines 727-737: Customer selection race condition (fixed in 28.1-01 but fragile)
   - Lines 691-711: Product filtering logic (broken due to empty IndexedDB)
   - Lines where IndexedDB is accessed (identify all calls)
   - Lines with complex state interdependencies
   - Lines with error handling (or lack thereof)

4. **Reusable Logic**:
   - Pure calculation functions (discount, totals, VAT)
   - Validation logic
   - Formatting utilities
   - API interaction patterns

5. **Voice Input Integration**:
   - How tightly coupled is voice input to form?
   - Can it be decoupled in rewrite?
   - Lines 1-30 show voice-related imports

Document findings in a structured markdown file: `28.2-01-ANALYSIS-OrderForm.md`

Include:
- Component metrics (LOC, state count, effect count, handler count)
- Data flow diagram (text-based)
- Pain points with line references
- Reusable vs needs-rewrite code classification
  </action>
  <verify>
1. Analysis document created and readable
2. All major pain points identified with line numbers
3. Data flow clearly documented
4. Reusable logic identified for extraction
  </verify>
  <done>OrderForm.tsx fully analyzed with documented findings</done>
</task>

<task type="auto">
  <name>Task 2: Map Sync Orchestrator → IndexedDB → Form Data Flow</name>
  <files>archibald-web-app/frontend/src/services/cache-service.ts, archibald-web-app/backend/src/routes/products.ts, archibald-web-app/backend/src/routes/customers.ts, archibald-web-app/frontend/src/db/schema.ts</files>
  <action>
Trace the complete data flow to understand why IndexedDB is empty:

1. **Backend Sync**:
   - Read products.ts and customers.ts API routes
   - Identify endpoints: GET /api/products, GET /api/customers
   - What data structure do they return?
   - Do they include `article` field for products?

2. **Cache Service**:
   - Read cache-service.ts thoroughly
   - Identify methods: searchProducts(), searchCustomers(), syncProducts(), syncCustomers()
   - How does cache-service populate IndexedDB?
   - Who calls these sync methods? When?

3. **IndexedDB Schema**:
   - Read db/schema.ts (already analyzed - v5 schema)
   - Products table: id, name, article, description, lastModified, hash
   - ProductVariants table: productId, variantId, multipleQty, minQty, maxQty, packageContent
   - Prices table: articleId, articleName, price

4. **Sync Orchestrator Integration**:
   - Search for files in archibald-web-app/frontend/src/ that call sync methods
   - Is there a background sync service?
   - When does sync get triggered? (login? manual? periodic?)

5. **Root Cause Hypothesis**:
   - Why is IndexedDB empty?
   - Is sync never called?
   - Is sync called but failing silently?
   - Is sync called but data format mismatch?

Document findings in: `28.2-01-ANALYSIS-DataFlow.md`

Include:
- Data flow diagram (Backend → API → Cache Service → IndexedDB → Form)
- Identified gaps or disconnections
- Root cause hypothesis for empty IndexedDB
- Recommendations for new architecture
  </action>
  <verify>
1. Data flow fully traced from backend to form
2. Root cause hypothesis documented
3. Sync integration points identified
4. Gaps in current architecture clear
  </verify>
  <done>Data flow mapped with root cause hypothesis documented</done>
</task>

<task type="auto">
  <name>Task 3: Analyze Related Services and Dependencies</name>
  <files>archibald-web-app/frontend/src/services/draft-service.ts, archibald-web-app/frontend/src/utils/orderParser.ts, archibald-web-app/frontend/src/hooks/useVoiceInput.ts</files>
  <action>
Analyze supporting services to understand dependencies:

1. **Draft Service**:
   - Read draft-service.ts
   - How are draft orders saved to IndexedDB?
   - What's the schema for DraftOrder vs PendingOrder?
   - Can we reuse this pattern for new architecture?

2. **Order Parser (Voice Input)**:
   - Read orderParser.ts (voice command parsing)
   - How tightly coupled to OrderForm?
   - Can voice input be a separate concern in new architecture?

3. **Voice Hook**:
   - Read useVoiceInput.ts hook
   - What state does it manage?
   - Can it be decoupled from form logic?

4. **Identify Dependencies**:
   - Which services are tightly coupled to OrderForm?
   - Which can be reused as-is?
   - Which need refactoring?

Document findings in: `28.2-01-ANALYSIS-Dependencies.md`

Include:
- Service dependency graph
- Reusable vs needs-refactoring classification
- Integration points for new architecture
  </action>
  <verify>
1. All related services analyzed
2. Dependency graph documented
3. Reusability assessment complete
  </verify>
  <done>Supporting services analyzed and documented</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <what-built>Comprehensive codebase analysis of OrderForm and related services</what-built>
  <how-to-verify>
Review the following analysis documents:

1. **28.2-01-ANALYSIS-OrderForm.md**:
   - Component metrics (LOC, state count, etc.)
   - Data flow within component
   - Pain points with line references
   - Reusable logic identified

2. **28.2-01-ANALYSIS-DataFlow.md**:
   - Backend → API → Cache → IndexedDB → Form flow
   - Root cause hypothesis for empty IndexedDB
   - Sync orchestrator integration analysis
   - Architecture gaps identified

3. **28.2-01-ANALYSIS-Dependencies.md**:
   - Draft service, voice input, order parser analysis
   - Service dependency graph
   - Reusability assessment

**Decision Point:**
Based on analysis findings, I will propose a new architecture. You can:
- Approve the architecture proposal
- Request modifications
- Ask questions about trade-offs

This checkpoint ensures we have a shared understanding of the current problems before designing the solution.
  </how-to-verify>
  <resume-signal>Type "approved" to proceed with architecture design, or provide feedback on analysis findings</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Design New Architecture with Component Tree</name>
  <files>None (design document creation)</files>
  <action>
Based on analysis findings, design new architecture following these principles:

**1. Separation of Concerns:**

```
Data Layer (Services)
├── CustomerService: searchCustomers(), getCustomerById(), syncCustomers()
├── ProductService: searchProducts(), getProductById(), getVariantByQty(), syncProducts()
├── PriceService: getPrice(), syncPrices()
├── OrderService: createDraftOrder(), savePendingOrder(), submitOrders()
└── SyncService: orchestrateSyncs(), handleOfflineSync()

State Management Layer
├── OrderFormContext: customer, items[], discounts, totals
├── useCustomerSelection: handles customer autocomplete logic
├── useProductSelection: handles product autocomplete + variants
├── useOrderCalculations: pure calculation functions (totals, VAT, discounts)
└── useOfflineSync: online/offline detection, sync queue

UI Components (Pure & Presentational)
├── OrderFormContainer (orchestrator)
│   ├── CustomerSelector
│   │   ├── CustomerAutocomplete
│   │   └── CustomerConfirmation
│   ├── OrderItemsManager
│   │   ├── ProductSelector
│   │   ├── QuantityInput (with variant validation)
│   │   ├── DiscountInput (inline)
│   │   └── OrderItemsList (add/edit/delete)
│   ├── OrderSummary
│   │   ├── ItemsTable
│   │   ├── TotalsDisplay (pre/post VAT)
│   │   └── GlobalDiscountInput (with reverse calc)
│   └── OrderActions
│       ├── SaveDraftButton
│       └── SubmitOrderButton
└── PendingOrdersPage (separate route)
    ├── PendingOrdersList
    ├── MultiSelectControls
    └── BatchSubmitButton
```

**2. State Management Approach:**

Option A: Context API + Custom Hooks
- Pros: No external dependency, familiar React patterns
- Cons: Can be verbose, performance considerations for large forms

Option B: Zustand (lightweight state management)
- Pros: Simple, performant, small bundle size
- Cons: External dependency

Recommendation: Context API + Custom Hooks (keep it simple, no new deps)

**3. Data Flow:**

```
User Action → Component Event Handler → Service Method → IndexedDB/API
                                                              ↓
User Feedback ← Component Re-render ← Context Update ← Service Response
```

**4. Offline-First Pattern:**

```
1. User opens form → Check IndexedDB cache
2. If cache empty/stale → Trigger background sync
3. User interacts → Always read from IndexedDB (cache-first)
4. User submits → Save to PendingOrders queue (IndexedDB)
5. Online detection → Auto-trigger batch sync
```

**5. Testing Strategy:**

- Unit Tests: Pure calculation functions (discounts, totals, VAT)
- Integration Tests: Service layer (mock IndexedDB with Dexie.test)
- Component Tests: UI components (React Testing Library)
- E2E Tests: Full user workflows (Playwright/Cypress)

Create design document: `28.2-01-ARCHITECTURE-Design.md`

Include:
- Component tree (detailed)
- Service layer contracts (method signatures, return types)
- State management architecture
- Data flow diagrams
- Testing strategy
- Performance considerations (debouncing, virtualization, memoization)
- Accessibility considerations (keyboard nav, ARIA, focus management)
  </action>
  <verify>
1. Architecture design document created
2. Component tree fully specified
3. Service layer contracts defined
4. State management approach chosen with rationale
5. Data flow clearly documented
6. Testing strategy outlined
  </verify>
  <done>Architecture design completed and documented</done>
</task>

<task type="checkpoint:decision" gate="blocking">
  <what-built>Complete architecture design for new OrderForm</what-built>
  <how-to-verify>
Review the architecture design document: **28.2-01-ARCHITECTURE-Design.md**

Key sections to review:
1. **Component Tree**: Does this structure make sense for your workflow?
2. **Service Layer**: Do these service contracts cover all requirements?
3. **State Management**: Context API + Custom Hooks approach - do you agree?
4. **Data Flow**: Is the offline-first pattern clear?
5. **Testing Strategy**: Does this give you confidence in the rewrite?

**Critical Decisions to Confirm:**
- ✅ Separate CustomerSelector and ProductSelector components
- ✅ Centralized state management via OrderFormContext
- ✅ Service layer abstracts IndexedDB and API interactions
- ✅ Offline-first: cache-first reads, queue-based writes
- ✅ PendingOrdersPage as separate route (not part of OrderForm)

**Trade-offs:**
- More files/components vs single large file (better maintainability)
- Context API vs external state library (simplicity vs features)
- Service abstraction vs direct DB calls (testability vs directness)

**Questions for You:**
1. Do you want voice input integrated from the start, or add it later?
2. Do you prefer verbose component names (CustomerAutocomplete) or shorter (CustomerInput)?
3. Should we build all components at once, or phase the rewrite (e.g., customer selection first, then products)?
  </how-to-verify>
  <resume-signal>Answer the 3 questions above, then type "approved" to proceed with migration strategy, or provide feedback on architecture</resume-signal>
</task>

<task type="auto">
  <name>Task 5: Design Migration Strategy</name>
  <files>None (design document creation)</files>
  <action>
Design the migration strategy from old OrderForm to new implementation:

**Option A: Big Bang Rewrite**
- Rename OrderForm.tsx → OrderForm_OLD_BACKUP.tsx
- Build new OrderForm from scratch in parallel
- Feature flag to switch between old/new
- Cut over when new version reaches feature parity

**Option B: Incremental Replacement**
- Extract one piece at a time (e.g., CustomerSelector first)
- Replace in existing OrderForm.tsx
- Gradually replace all pieces
- Old code deleted incrementally

**Option C: Parallel Implementation**
- New OrderForm at /new-order route
- Old OrderForm stays at /order route
- User testing on new route
- Cut over when validated

**Recommendation: Option A (Big Bang with Feature Flag)**

Rationale:
- Clean slate avoids compromises with old architecture
- Feature flag allows quick rollback if issues
- Parallel development doesn't interfere with old code
- Easier to implement new patterns without old constraints

**Implementation Steps:**

1. **Preparation** (Plan 28.2-01):
   - Rename OrderForm.tsx → OrderForm_OLD_BACKUP.tsx
   - Create feature flag: `ENABLE_NEW_ORDER_FORM` env var
   - Create routing logic to switch between old/new
   - Document rollback procedure

2. **Data Layer** (Plan 28.2-02):
   - Build CustomerService, ProductService, OrderService
   - Ensure IndexedDB sync working correctly
   - Unit tests for all services

3. **UI Components** (Plans 28.2-03, 28.2-04, 28.2-05):
   - Build components incrementally
   - Integration tests for each component
   - Checkpoint after each major component for user feedback

4. **Integration** (Plan 28.2-06):
   - Wire all components together in new OrderForm
   - E2E tests for full workflows
   - Performance testing with real data volumes
   - UAT with user

5. **Cutover**:
   - Deploy with feature flag OFF (old form active)
   - Enable feature flag for testing
   - User validates new form
   - Enable feature flag for production
   - Monitor for issues
   - Delete old code after 1 week of stable operation

Create migration document: `28.2-01-MIGRATION-Strategy.md`

Include:
- Chosen migration approach with rationale
- Step-by-step implementation plan
- Feature flag configuration
- Rollback procedure
- Cutover checklist
- Post-cutover monitoring plan
- Timeline estimate (optional - if user asks)
  </action>
  <verify>
1. Migration strategy document created
2. Approach chosen with clear rationale
3. Implementation steps defined
4. Feature flag mechanism specified
5. Rollback procedure documented
6. Cutover checklist complete
  </verify>
  <done>Migration strategy designed and documented</done>
</task>

<task type="auto">
  <name>Task 6: Create Implementation Roadmap for Remaining Plans</name>
  <files>None (design document creation)</files>
  <action>
Based on architecture design and migration strategy, create detailed roadmap for Plans 02-06:

**Plan 28.2-02: Data Layer & Services**
- Scope: Build CustomerService, ProductService, PriceService, OrderService
- Deliverables: 4 service files with full test coverage
- Dependencies: IndexedDB schema (already exists), API endpoints (already exist)
- Checkpoint: Services tested and working with real IndexedDB data

**Plan 28.2-03: Customer & Product Selection**
- Scope: CustomerSelector, ProductSelector, QuantityInput components
- Deliverables: 3 components with autocomplete, validation, variants
- Dependencies: Plan 28.2-02 (services)
- Checkpoint: User verifies autocomplete UX (speed, accuracy, mobile-friendly)

**Plan 28.2-04: Multi-Article & Discounts**
- Scope: OrderItemsList, DiscountSystem, OrderSummary components
- Deliverables: Item management, discount calculations, real-time totals
- Dependencies: Plan 28.2-03 (selection components)
- Checkpoint: User verifies discount calculations (inline, global, reverse)

**Plan 28.2-05: Pending Queue & Offline**
- Scope: PendingOrdersPage, offline detection, sync queue, batch submission
- Deliverables: Queue UI, offline support, bot integration
- Dependencies: Plan 28.2-04 (complete order form)
- Checkpoint: User tests offline order creation and batch submission

**Plan 28.2-06: Integration & Testing**
- Scope: E2E tests, performance testing, UAT, cutover
- Deliverables: Test suite, performance report, production deployment
- Dependencies: Plans 28.2-02 through 28.2-05 (all components)
- Checkpoint: User validates production-ready application

Create roadmap document: `28.2-01-ROADMAP-Implementation.md`

Include:
- Detailed breakdown of Plans 02-06
- Task estimates (if user wants them - otherwise skip)
- Dependency graph
- Checkpoint strategy
- Risk mitigation
  </action>
  <verify>
1. Implementation roadmap created
2. Plans 02-06 clearly defined
3. Dependencies identified
4. Checkpoints specified
5. Risk mitigation considered
  </verify>
  <done>Implementation roadmap complete</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] OrderForm.tsx analyzed comprehensively
- [ ] Data flow traced from backend to form
- [ ] Root cause hypothesis for empty IndexedDB documented
- [ ] Related services and dependencies analyzed
- [ ] New architecture designed with component tree
- [ ] Service layer contracts defined
- [ ] State management approach chosen
- [ ] Migration strategy documented with feature flag
- [ ] Implementation roadmap created for Plans 02-06
- [ ] User approved architecture design (checkpoint decision)
- [ ] User answered 3 questions about voice input, naming, phasing
</verification>

<success_criteria>
- Analysis documents provide clear understanding of current problems
- Architecture design addresses all pain points from analysis
- Migration strategy is safe and allows rollback
- Implementation roadmap breaks down remaining work into manageable plans
- User has high confidence in proposed approach
- All questions answered, all decisions documented
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-01-SUMMARY.md`:

# Phase 28.2 Plan 01: Codebase Analysis & Architecture Design - Summary

**Complete OrderForm architecture designed - ready to implement rewrite**

## Accomplishments

- Analyzed OrderForm.tsx (2705 lines) - documented all pain points
- Mapped data flow from sync orchestrator through IndexedDB to form
- Identified root cause of empty IndexedDB (sync disconnection)
- Designed new architecture with clean separation of concerns
- Defined service layer contracts (CustomerService, ProductService, OrderService)
- Chose state management approach (Context API + Custom Hooks)
- Designed migration strategy with feature flag and rollback
- Created implementation roadmap for Plans 02-06

## Analysis Findings

### Current Pain Points
- Monolithic component: 2705 lines, [X] state variables, [Y] useEffect hooks
- Data flow unclear: Sync orchestrator exists but doesn't populate IndexedDB
- Race conditions: Customer selection fragile (fixed in 28.1-01 but architecture issue)
- Product filtering broken: IndexedDB empty, no fallback mechanism
- Complex state: Multiple interdependent useState hooks without centralized management
- Error handling: Insufficient error boundaries and user feedback

### Root Cause: Empty IndexedDB
[Document hypothesis from Task 2 analysis]

## Architecture Design

### Component Tree
```
OrderFormContainer
├── CustomerSelector (autocomplete, ~1500 records)
├── OrderItemsManager
│   ├── ProductSelector (autocomplete, ~5000 records)
│   ├── QuantityInput (variant validation)
│   └── OrderItemsList (add/edit/delete)
├── OrderSummary (real-time totals, VAT)
└── OrderActions (draft/submit)

PendingOrdersPage (separate route)
├── PendingOrdersList
└── BatchSubmitButton
```

### Service Layer
- CustomerService: Cache-first with API fallback
- ProductService: Cache-first with variant selection logic
- OrderService: Draft orders, pending queue, batch submission
- SyncService: Orchestrate background syncs

### State Management
Context API + Custom Hooks (no external dependencies)

## Migration Strategy

**Approach**: Big Bang Rewrite with Feature Flag

1. Rename OrderForm.tsx → OrderForm_OLD_BACKUP.tsx
2. Build new OrderForm incrementally (Plans 02-05)
3. Feature flag: `ENABLE_NEW_ORDER_FORM` env var
4. User testing with flag enabled
5. Production cutover when validated
6. Delete old code after 1 week stable

**Rollback**: Disable feature flag → instant revert to old form

## User Decisions

1. **Voice Input**: [User answer from checkpoint]
2. **Naming Convention**: [User answer from checkpoint]
3. **Phasing**: [User answer from checkpoint]

## Implementation Roadmap

- **Plan 28.2-02**: Data Layer & Services (CustomerService, ProductService, OrderService)
- **Plan 28.2-03**: Customer & Product Selection (autocomplete components)
- **Plan 28.2-04**: Multi-Article & Discounts (item management, calculations)
- **Plan 28.2-05**: Pending Queue & Offline (queue UI, sync, bot integration)
- **Plan 28.2-06**: Integration & Testing (E2E tests, performance, UAT, cutover)

## Documents Created

- `28.2-01-ANALYSIS-OrderForm.md` - Component analysis
- `28.2-01-ANALYSIS-DataFlow.md` - Data flow and sync orchestrator
- `28.2-01-ANALYSIS-Dependencies.md` - Related services
- `28.2-01-ARCHITECTURE-Design.md` - New architecture design
- `28.2-01-MIGRATION-Strategy.md` - Migration approach
- `28.2-01-ROADMAP-Implementation.md` - Plans 02-06 breakdown

## Issues Encountered

[Document any issues, or "None"]

## Next Step

Ready for 28.2-02-PLAN.md (Data Layer & Services)

**Execute**: `/gsd:execute-plan .planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-02-PLAN.md`
</output>
