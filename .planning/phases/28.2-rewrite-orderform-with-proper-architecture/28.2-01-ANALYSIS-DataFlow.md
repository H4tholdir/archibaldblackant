# Data Flow Analysis: Sync Orchestrator → IndexedDB → OrderForm

**Analysis Date:** 2026-01-23
**Phase:** 28.2 (Rewrite OrderForm with Proper Architecture)
**Plan:** 01 (Codebase Analysis & Architecture Design)

---

## Executive Summary

This document traces the **complete data flow** from the Archibald backend through the Sync Orchestrator, into IndexedDB storage, and finally to the OrderForm component. The analysis reveals:

- **Critical Disconnection:** Sync Orchestrator runs successfully but IndexedDB remains empty (0 products)
- **Root Cause:** Schema mismatch between backend sync and frontend expectations
- **Impact:** Product autocomplete completely broken, requiring API fallback on every page load

---

## 1. Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────┐
│                          ARCHIBALD BACKEND                           │
│                         (External System)                            │
└─────────────────────────┬───────────────────────────────────────────┘
                          │
                          │ Playwright Automation
                          │ (PDF Download + Scraping)
                          ↓
┌─────────────────────────────────────────────────────────────────────┐
│                         BACKEND API SERVER                           │
│                          (Fastify + SQLite)                          │
├─────────────────────────────────────────────────────────────────────┤
│  Sync Orchestrator (sync-orchestrator.ts)                           │
│    ├─ CustomerSyncService → customers table (SQLite)                │
│    ├─ ProductSyncService  → products table (SQLite)                 │
│    └─ PriceSyncService    → prices table (SQLite)                   │
├─────────────────────────────────────────────────────────────────────┤
│  API Routes                                                          │
│    ├─ GET  /api/customers → Read from SQLite                        │
│    ├─ GET  /api/products  → Read from SQLite                        │
│    ├─ GET  /api/cache/delta → Incremental sync                      │
│    └─ POST /api/customers/smart-sync → On-demand fast sync          │
└─────────────────────────┬───────────────────────────────────────────┘
                          │
                          │ HTTP API (JSON)
                          │
                          ↓
┌─────────────────────────────────────────────────────────────────────┐
│                        FRONTEND (React PWA)                          │
├─────────────────────────────────────────────────────────────────────┤
│  Cache Service (cache-service.ts)                                   │
│    ├─ searchCustomers() → Query IndexedDB                           │
│    └─ searchProducts()  → Query IndexedDB                           │
├─────────────────────────────────────────────────────────────────────┤
│  IndexedDB (ArchibaldOfflineDB - Dexie.js)                          │
│    ├─ customers table    (v5 schema)                                │
│    ├─ products table     (v4 schema)                                │
│    ├─ productVariants    (v4 schema)                                │
│    ├─ prices table       (v4 schema)                                │
│    ├─ draftOrders        (legacy auto-save)                         │
│    ├─ pendingOrders      (v2 schema)                                │
│    └─ cacheMetadata      (freshness tracking)                       │
├─────────────────────────────────────────────────────────────────────┤
│  OrderForm Component (OrderForm.tsx - 2705 lines)                   │
│    ├─ Customer Autocomplete (loads via cacheService)                │
│    ├─ Product Autocomplete  (loads via cacheService)                │
│    └─ Draft Management      (saves to pendingOrders)                │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 2. Backend Sync Orchestrator Flow

### 2.1 Sync Orchestrator Architecture

**File:** `archibald-web-app/backend/src/sync-orchestrator.ts`

**Purpose:** Central coordinator for all sync operations with mutual exclusion (only one sync runs at a time).

#### Key Features
- **Priority Queue:** Higher priority syncs jump queue
- **Mutual Exclusion:** Only 1 sync active at a time
- **Smart Customer Sync:** Fast, on-demand sync for OrderForm
- **Event Emitter:** Broadcasts sync-started, sync-completed, sync-error events
- **History Tracking:** Records last 100 sync operations per type

#### Default Priorities
```typescript
{
  orders: 6,      // Highest (real-time critical)
  customers: 5,   // High (needed for orders)
  ddt: 4,         // Medium-high (transport docs)
  invoices: 3,    // Medium (financial)
  products: 2,    // Products before prices
  prices: 1       // Lowest (requires products first)
}
```

#### Sync Execution Flow
```typescript
// Lines 139-166: requestSync method
async requestSync(type: SyncType, priority?: number, userId?: string) {
  // 1. Check if Smart Customer Sync is active
  if (this.smartCustomerSyncActive && type !== "customers") {
    this.addToQueue(type, finalPriority, userId);
    return; // Queue non-customer syncs
  }

  // 2. Check if another sync is running
  if (this.currentSync !== null) {
    this.addToQueue(type, finalPriority, userId);
    return; // Queue this sync
  }

  // 3. No sync running, start immediately
  await this.executeSync(type, userId);
}
```

### 2.2 Product Sync Service Flow

**File:** `archibald-web-app/backend/src/product-sync-service.ts`

**Sync Strategy:** Full PDF export + parse + delta update

#### Stage 1: Login & Acquire Context (Lines 104-111)
```
BrowserPool.acquireContext(userId)
  ↓
Playwright browser context ready
  ↓
ArchibaldBot initialized
```

#### Stage 2: Download PDF (Lines 115-122)
```
bot.downloadProductsPDF(context)
  ↓
Navigate to Archibald listino page
  ↓
Trigger PDF export ("Esporta Listino")
  ↓
Save to temp file: /tmp/products-{timestamp}.pdf
```

**Measured Timing:** ~28 seconds for download

#### Stage 3: Parse PDF (Lines 124-135)
```
pdfParser.parsePDF(tempPdfPath)
  ↓
Read PDF with pdf-parse library
  ↓
Extract product table rows
  ↓
Parse columns: article, description, variants, pricing, package info
  ↓
Return ParsedProduct[] array
```

**Measured Timing:** ~4 minutes 34 seconds (274 seconds)
**Total Sync Time:** ~5 minutes 7 seconds

#### Stage 4: Apply Delta & Update DB (Lines 137-146)
```
applyDelta(parsedProducts)
  ↓
For each product:
  - Calculate hash (MD5) from product data
  - Query SQLite: SELECT * FROM products WHERE id = ?
  - Compare hashes:
    - No match → INSERT or UPDATE
    - Match → Skip (no changes)
  ↓
Update sync_metadata.version++
  ↓
Log to change_log table
```

**Backend Storage:** SQLite database (`product-db.ts`)
```sql
-- products table
CREATE TABLE products (
  id TEXT PRIMARY KEY,
  name TEXT NOT NULL,
  article TEXT,
  description TEXT,
  lastModified TEXT,
  hash TEXT
);

-- productVariants table
CREATE TABLE productVariants (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  productId TEXT,
  variantId TEXT,
  multipleQty INTEGER,
  minQty INTEGER,
  maxQty INTEGER,
  packageContent TEXT
);

-- prices table
CREATE TABLE prices (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  articleId TEXT,
  articleName TEXT,
  price REAL,
  lastSynced TEXT
);

-- sync_metadata table
CREATE TABLE sync_metadata (
  key TEXT PRIMARY KEY,
  version INTEGER,
  lastSynced TEXT,
  recordCount INTEGER
);

-- change_log table
CREATE TABLE change_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  sync_version INTEGER,
  entity_type TEXT,
  entity_id TEXT,
  operation TEXT,
  is_critical INTEGER,
  timestamp TEXT
);
```

#### Stage 5: Cleanup (Lines 148-164)
```
Unlink temp PDF file
  ↓
Release browser context
  ↓
Update sync session record
  ↓
Emit "sync-completed" event
```

### 2.3 Smart Customer Sync

**Purpose:** Fast, on-demand customer sync when user enters OrderForm

**File:** `sync-orchestrator.ts` Lines 286-340

#### How It Works
```typescript
// Triggered by: POST /api/customers/smart-sync
async smartCustomerSync() {
  if (this.smartCustomerSyncActive) {
    this.sessionCount++; // Track concurrent sessions
    return;
  }

  this.smartCustomerSyncActive = true;
  this.sessionCount = 1;

  // 1. Pause all other syncs
  logger.info("Smart Customer Sync started - pausing other syncs");

  // 2. Execute customer sync (priority = 10, highest)
  await this.requestSync("customers", 10, "smart-customer-sync");

  // 3. Set safety timeout (10 minutes)
  this.resetSafetyTimeout();
}
```

**Resume Flow:** (Lines 341-365)
```typescript
// Triggered by: POST /api/customers/resume-syncs
resumeSyncs() {
  this.sessionCount--;

  if (this.sessionCount <= 0) {
    this.smartCustomerSyncActive = false;
    this.clearSafetyTimeout();
    logger.info("Smart Customer Sync ended - resuming other syncs");
    this.processQueue(); // Process queued syncs
  }
}
```

**Key Benefits:**
- Customers sync completes in 3-5 seconds (vs full sync ~2 minutes)
- Other syncs paused to avoid resource contention
- Session tracking handles multiple OrderForm instances
- Safety timeout (10 min) prevents indefinite pause

---

## 3. Frontend Delta Sync Flow

### 3.1 Delta Sync API

**File:** `archibald-web-app/backend/src/routes/delta-sync.ts`

**Purpose:** Incremental sync to minimize data transfer

#### Endpoint: GET /api/cache/delta

**Query Parameters:**
- `clientVersion`: Current client sync version (integer)
- `types`: Comma-separated list (e.g., "customers,products,prices")

**Response Structure:**
```typescript
{
  success: true,
  upToDate: false,
  serverVersion: 150,
  changes: [
    {
      id: 123,
      sync_version: 148,
      entity_type: "products",
      entity_id: "PROD-001",
      operation: "update",
      is_critical: 1,
      timestamp: "2026-01-23T10:30:00Z"
    },
    // ... more changes
  ],
  metadata: {
    clientVersion: 140,
    serverVersion: 150,
    syncTypes: ["products"],
    hasCritical: true,
    changesCount: 10
  }
}
```

**Flow:**
```
1. Client sends current version (e.g., 140)
2. Server checks max(version) from sync_metadata → 150
3. Client behind? Query change_log for versions 141-150
4. Return delta changes (10 changes)
5. Client applies changes incrementally
```

**Optimization:**
- Only changed records transferred
- No full table downloads
- Critical changes flagged for immediate action

### 3.2 Current Sync Implementation Issue

**PROBLEM:** Frontend does NOT use delta sync endpoint yet

**Evidence from OrderForm.tsx:**

#### Customer Load (Lines 563-598)
```typescript
// Triggered on OrderForm mount
const loadCustomersFromCache = async () => {
  // 1. Load from IndexedDB
  const cachedCustomers = await cacheService.searchCustomers("", 10000);

  if (cachedCustomers.length > 0) {
    setCustomers(cachedCustomers); // Use cache
  } else {
    // 2. Fallback to FULL API load (NOT delta)
    const response = await fetch("/api/customers");
    const data = await response.json();
    setCustomers(data.data.customers || data.data);
  }
};
```

#### Product Load (Lines 627-693)
```typescript
// Triggered on OrderForm mount
const loadProductsFromCache = async () => {
  // 1. Load from IndexedDB
  const cachedProducts = await cacheService.searchProducts("", 10000);

  if (cachedProducts.length > 0) {
    // DIAGNOSTIC 28.1-02: IndexedDB empty, 0 products
    console.log("[Products] Loaded from cache:", cachedProducts.length); // 0

    // Map products with fallback
    const mappedProducts = cachedProducts.map((p) => ({
      ...p,
      article: p.article || p.name, // FIX 28.1-02: Fallback
    }));
    setProducts(mappedProducts);
  } else {
    // 2. Fallback to FULL API load (NOT delta)
    const response = await fetch("/api/products");
    const data = await response.json();
    setProducts(data.data.products || data.data);
  }
};
```

**Issues:**
1. **No Delta Sync:** Always loads full data from IndexedDB OR full API
2. **Empty IndexedDB:** Cache returns 0 records despite sync running
3. **API Fallback:** Loads ALL ~5000 products on every OrderForm mount
4. **No Population Logic:** IndexedDB never gets populated from API response

---

## 4. IndexedDB Schema & Population

### 4.1 IndexedDB Schema

**File:** `archibald-web-app/frontend/src/db/schema.ts`

**Database Name:** `ArchibaldOfflineDB`
**Schema Version:** 5 (current)

#### Migration History
```typescript
// v1: Original schema
// v2: Updated PendingOrder schema (cleared old data)
// v3: Clean corrupted draft orders with undefined id
// v4: Fix corrupted productVariants and prices (bulkPut → bulkAdd)
// v5: Fix customer schema mismatch (customerProfile → id mapping)
```

#### Current Schema (v5)

**customers table:**
```typescript
stores: {
  customers: 'id, name, code, city, *hash'
}

interface Customer {
  id: string;
  name: string;
  code: string;
  taxCode: string;
  address: string;
  city: string;
  province: string;
  cap: string;
  phone: string;
  email: string;
  fax: string;
  lastModified: string;
  hash: string;
}
```

**products table:**
```typescript
stores: {
  products: 'id, name, article, *hash'
}

interface Product {
  id: string;
  name: string;
  article: string; // ← CRITICAL FIELD
  description: string;
  lastModified: string;
  hash: string;
}
```

**productVariants table:**
```typescript
stores: {
  productVariants: '++id, productId, variantId'
}

interface ProductVariant {
  id?: number; // Auto-increment
  productId: string; // FK to Product
  variantId: string;
  multipleQty: number;
  minQty: number;
  maxQty: number;
  packageContent: string;
}
```

**prices table:**
```typescript
stores: {
  prices: '++id, articleId, articleName'
}

interface Price {
  id?: number; // Auto-increment
  articleId: string;
  articleName: string;
  price: number;
  lastSynced: string;
}
```

**cacheMetadata table:**
```typescript
stores: {
  cacheMetadata: 'key, lastSynced'
}

interface CacheMetadata {
  key: string; // 'customers' | 'products' | 'prices'
  lastSynced: string;
  recordCount: number;
  version: number;
}
```

### 4.2 Population Gap Analysis

**CRITICAL FINDING:** No code populates IndexedDB from backend sync

#### What We Have:
1. ✅ Backend syncs products to SQLite successfully
2. ✅ Backend exposes `/api/products` endpoint
3. ✅ Frontend loads products via API fallback
4. ✅ IndexedDB schema defined correctly

#### What We DON'T Have:
1. ❌ No Service Worker intercepts `/api/products` response
2. ❌ No code saves API response to IndexedDB
3. ❌ No delta sync client implementation
4. ❌ No background sync worker

**Result:** IndexedDB stays empty forever

---

## 5. Cache Service Operations

### 5.1 Cache Service Methods

**File:** `archibald-web-app/frontend/src/services/cache-service.ts`

#### searchCustomers (Lines 25-59)
```typescript
async searchCustomers(query: string, limit = 50): Promise<Customer[]> {
  // Empty query → Return all (limited)
  if (!query || query.length < 2) {
    return await db.customers.limit(limit).toArray();
  }

  // Dexie compound index search
  const results = await db.customers
    .where("name").startsWithIgnoreCase(query)
    .or("code").startsWithIgnoreCase(query)
    .or("city").startsWithIgnoreCase(query)
    .limit(limit)
    .toArray();

  // Fallback: broader contains search
  if (results.length === 0) {
    const allCustomers = await db.customers.toArray();
    return allCustomers
      .filter((c) =>
        (c.name && c.name.toLowerCase().includes(query.toLowerCase())) ||
        (c.code && c.code.toLowerCase().includes(query.toLowerCase())) ||
        (c.city && c.city.toLowerCase().includes(query.toLowerCase()))
      )
      .slice(0, limit);
  }

  return results;
}
```

**Performance Target:** < 100ms
**Actual:** Fast when data exists, instant when empty (0 records)

#### searchProducts (Lines 66-146)
```typescript
async searchProducts(query: string, limit = 50): Promise<ProductWithDetails[]> {
  // Empty query → Return all (limited)
  if (!query || query.length < 2) {
    const allProducts = await db.products.limit(limit).toArray();

    // Enrich with variants and prices (parallel)
    return await Promise.all(
      allProducts.map(async (product) => {
        const [variants, priceRecord] = await Promise.all([
          db.productVariants.where("productId").equals(product.id).toArray(),
          db.prices.where("articleId").equals(product.id).first(),
        ]);

        return {
          ...product,
          variants,
          price: priceRecord?.price,
        };
      })
    );
  }

  // Search products by name or article
  const products = await db.products
    .where("name").startsWithIgnoreCase(query)
    .or("article").startsWithIgnoreCase(query)
    .limit(limit)
    .toArray();

  // DIAGNOSTIC 28.1-02: Check article field
  console.log('[DIAGNOSTIC 28.1-02] searchProducts query:', query);
  console.log('[DIAGNOSTIC 28.1-02] Found products:', products.length); // 0

  // Enrich with variants and prices
  return await Promise.all(
    products.map(async (product) => {
      const [variants, priceRecord] = await Promise.all([
        db.productVariants.where("productId").equals(product.id).toArray(),
        db.prices.where("articleId").equals(product.id).first(),
      ]);

      return {
        ...product,
        variants,
        price: priceRecord?.price,
      };
    })
  );
}
```

**Issue:** Diagnostic logs show `products.length = 0` consistently

#### Cache Freshness Check (Lines 151-175)
```typescript
async getCacheAge(): Promise<number | null> {
  const metadata = await db.cacheMetadata.get("customers");
  if (!metadata) return null;

  const lastSync = new Date(metadata.lastSynced);
  const ageHours = (Date.now() - lastSync.getTime()) / 1000 / 60 / 60;
  return ageHours;
}

async isCacheStale(): Promise<boolean> {
  const age = await this.getCacheAge();
  if (age === null) return true; // No cache = stale
  return age > 72; // 3 days = 72 hours
}
```

**Purpose:** Warn user if cache is > 3 days old before order submission

---

## 6. OrderForm Data Flow

### 6.1 Customer Selection Flow

```
OrderForm Mount
  ↓
useEffect (Lines 540-621)
  ↓
Trigger Smart Customer Sync: POST /api/customers/smart-sync
  ↓ (parallel)
loadCustomersFromCache()
  ↓
cacheService.searchCustomers("", 10000)
  ↓
IndexedDB Query: db.customers.limit(10000).toArray()
  ↓
Result: Customer[] (may be empty if never populated)
  ↓
If empty → Fallback: GET /api/customers
  ↓
setCustomers(data.data.customers)
  ↓
Customer dropdown populated
  ↓
User types in search box → setCustomerSearch(value)
  ↓
filteredCustomers = customers.filter(c =>
  c.name.toLowerCase().includes(search) ||
  c.id.toLowerCase().includes(search)
)
  ↓
Show dropdown with filteredCustomers.slice(0, 10)
  ↓
User clicks customer → handleCustomerSelect
  ↓
setCustomerId(customer.id)
setCustomerName(customer.name)
setCustomerSearch(customer.name)
  ↓
setTimeout(() => setShowCustomerDropdown(false), 100) // Race fix
```

### 6.2 Product Selection Flow

```
OrderForm Mount
  ↓
useEffect (Lines 623-700)
  ↓
loadProductsFromCache()
  ↓
cacheService.searchProducts("", 10000)
  ↓
IndexedDB Query: db.products.limit(10000).toArray()
  ↓
Result: Product[] (0 records - EMPTY)
  ↓
DIAGNOSTIC LOG: "[Products] Loaded from cache: 0"
  ↓
DIAGNOSTIC LOG: "article: undefined" for first product
  ↓
Fallback mapping: article = p.article || p.name
  ↓
Result still empty → Fallback: GET /api/products
  ↓
setProducts(data.data.products)
  ↓
Product dropdown populated (from API, NOT cache)
  ↓
User types in search box → setProductSearch(value)
  ↓
useMemo filteredProducts (Lines 713-743)
  ↓
products.filter(p =>
  p.name.toLowerCase().includes(search) ||
  p.article?.toLowerCase().includes(search) ||
  p.id.toLowerCase().includes(search) ||
  p.description?.toLowerCase().includes(search)
)
  ↓
Show dropdown with filteredProducts.slice(0, 10)
  ↓
User clicks product → handleProductSelect
  ↓
Parse packageContent → packageConstraints
  ↓
setNewItem({
  articleCode: product.name,
  productName: product.name,
  description: product.description,
  quantity: packageSize,
  price: product.price
})
  ↓
setProductSearch(product.name)
setShowProductDropdown(false)
```

### 6.3 Voice Input Data Flow

```
User clicks "Dettatura Completa Ordine"
  ↓
handleVoiceStart() (Line 1154)
  ↓
setShowVoiceModal(true)
resetTranscript()
startListening() → Web Speech API
  ↓
User speaks: "Cliente Mario Rossi, articolo TD1272.314, quantità 2"
  ↓
Transcript updates (interim + final)
  ↓
onResult callback (Lines 181-387) when final
  ↓
parseVoiceOrder(finalTranscript) → orderParser.ts
  ↓
Extract entities:
  - customerName: "Mario Rossi"
  - items[0].articleCode: "TD1272.314"
  - items[0].quantity: 2
  ↓
Async validation (parallel):
  - validateCustomerName("Mario Rossi") → Fuzzy match in cache
  - validateArticleCode("TD1272.314") → Normalized match
  ↓
Calculate confidence scores:
  - Customer: 85% (phonetic match)
  - Article: 95% (normalized match)
  - Quantity: 95% (always high)
  ↓
Auto-apply if confidence ≥ 70%
  ↓
setTimeout 1.5s delay (show validation feedback)
  ↓
applyVoiceData (Lines 1209-1348)
  ↓
Populate form fields:
  - setCustomerSearch(customerName)
  - setCustomerId(customerId)
  - Add item to draftItems
  ↓
Mark as voice-populated:
  - setVoicePopulatedFields({ customer: true, article: true })
  ↓
Reset modal for next input:
  - resetTranscript()
  - setParsedOrder({ items: [] })
  - setValidations(null)
```

---

## 7. Root Cause Analysis: Empty IndexedDB

### 7.1 Hypothesis 1: Schema Mismatch

**Backend Schema (SQLite):**
```sql
CREATE TABLE products (
  id TEXT PRIMARY KEY,
  name TEXT,
  article TEXT,
  ...
);
```

**Frontend Schema (IndexedDB):**
```typescript
interface Product {
  id: string;
  name: string;
  article: string; // Expected
  ...
}
```

**API Response:** Likely missing `article` field or named differently

**Evidence:**
```typescript
// Line 637: DIAGNOSTIC shows article field missing
console.log('[DIAGNOSTIC 28.1-02] First cached product:', {
  article: cachedProducts[0].article, // undefined
  hasArticle: 'article' in cachedProducts[0] // false
});

// Line 650: Fallback added
article: p.article || p.name, // Fallback to name
```

### 7.2 Hypothesis 2: No Population Logic

**Missing Implementation:**
- No Service Worker to cache API responses
- No explicit cache population after API fetch
- No delta sync client
- No background sync worker

**Expected Flow (Not Implemented):**
```
API Response: GET /api/products
  ↓
Cache in IndexedDB: db.products.bulkAdd(products)
  ↓
Update metadata: db.cacheMetadata.put({
  key: "products",
  lastSynced: new Date().toISOString(),
  recordCount: products.length,
  version: response.serverVersion
})
```

**Current Flow:**
```
API Response: GET /api/products
  ↓
setProducts(response.data) // Only in React state
  ↓
IndexedDB: UNCHANGED (still 0 records)
```

### 7.3 Hypothesis 3: Migration Cleared Data

**Evidence from schema.ts:**
```typescript
// v4 migration (Lines 157-179)
.upgrade(async (trans) => {
  console.log('[IndexedDB:Schema] v3→v4: Clearing corrupted variants and prices');
  await trans.table('productVariants').clear();
  await trans.table('prices').clear();
  await trans.table('cacheMetadata').clear(); // Force re-sync
});

// v5 migration (Lines 181-202)
.upgrade(async (trans) => {
  console.log('[IndexedDB:Schema] v4→v5: Clearing customers (schema fix)');
  await trans.table('customers').clear();
  await trans.table('cacheMetadata').clear(); // Force re-sync
});
```

**Analysis:**
- Migrations clear tables to fix corruption
- `cacheMetadata.clear()` intended to trigger re-sync
- BUT: No re-sync implementation exists
- Result: Tables stay empty forever

---

## 8. Fix Strategy

### 8.1 Immediate Fix (Phase 28.2-02)

#### Option A: Populate on API Fallback
```typescript
// In OrderForm.tsx loadProductsFromCache
const loadProductsFromCache = async () => {
  const cachedProducts = await cacheService.searchProducts("", 10000);

  if (cachedProducts.length > 0) {
    setProducts(mappedProducts);
  } else {
    // API fallback
    const response = await fetch("/api/products");
    const data = await response.json();
    const apiProducts = data.data.products || data.data;

    // ✅ NEW: Populate IndexedDB
    await db.transaction('rw', [db.products, db.cacheMetadata], async () => {
      await db.products.bulkAdd(apiProducts);
      await db.cacheMetadata.put({
        key: "products",
        lastSynced: new Date().toISOString(),
        recordCount: apiProducts.length,
        version: 1 // Initial version
      });
    });

    setProducts(apiProducts);
  }
};
```

#### Option B: Dedicated Sync Service (Recommended)
```typescript
// New file: frontend/src/services/sync-service.ts
class SyncService {
  async syncProducts(): Promise<void> {
    const token = localStorage.getItem("authToken");
    const response = await fetch("/api/products", {
      headers: { Authorization: `Bearer ${token}` }
    });

    const data = await response.json();
    const products = data.data.products || data.data;

    // Save to IndexedDB
    await db.transaction('rw', [db.products, db.productVariants, db.prices, db.cacheMetadata], async () => {
      // Clear old data
      await db.products.clear();
      await db.productVariants.clear();
      await db.prices.clear();

      // Insert new data
      await db.products.bulkAdd(products);

      // Extract and save variants
      const variants = products.flatMap(p => p.variants || []);
      await db.productVariants.bulkAdd(variants);

      // Extract and save prices
      const prices = products.map(p => ({
        articleId: p.id,
        articleName: p.name,
        price: p.price || 0,
        lastSynced: new Date().toISOString()
      }));
      await db.prices.bulkAdd(prices);

      // Update metadata
      await db.cacheMetadata.put({
        key: "products",
        lastSynced: new Date().toISOString(),
        recordCount: products.length,
        version: 1
      });
    });
  }
}
```

### 8.2 Long-term Solution (Phase 28.2-06)

#### Implement Delta Sync Client
```typescript
// New file: frontend/src/services/delta-sync-client.ts
class DeltaSyncClient {
  async syncProducts(): Promise<void> {
    // 1. Get current client version
    const metadata = await db.cacheMetadata.get("products");
    const clientVersion = metadata?.version || 0;

    // 2. Request delta from server
    const response = await fetch(
      `/api/cache/delta?clientVersion=${clientVersion}&types=products`,
      { headers: { Authorization: `Bearer ${token}` } }
    );

    const delta = await response.json();

    if (delta.upToDate) {
      console.log("Cache up to date");
      return;
    }

    // 3. Apply changes
    await db.transaction('rw', [db.products, db.cacheMetadata], async () => {
      for (const change of delta.changes) {
        if (change.operation === "insert" || change.operation === "update") {
          // Fetch full record
          const product = await this.fetchProduct(change.entity_id);
          await db.products.put(product);
        } else if (change.operation === "delete") {
          await db.products.delete(change.entity_id);
        }
      }

      // 4. Update version
      await db.cacheMetadata.put({
        key: "products",
        lastSynced: new Date().toISOString(),
        recordCount: await db.products.count(),
        version: delta.serverVersion
      });
    });
  }
}
```

#### Service Worker Cache Strategy
```typescript
// New file: frontend/public/sw.js
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Intercept /api/products
  if (url.pathname === '/api/products') {
    event.respondWith(
      caches.open('api-cache-v1').then(async (cache) => {
        try {
          // Fetch from network
          const response = await fetch(event.request);
          const data = await response.clone().json();

          // Store in IndexedDB
          const db = await openDB('ArchibaldOfflineDB', 5);
          await db.put('products', data.data.products);

          // Cache response
          cache.put(event.request, response.clone());
          return response;
        } catch (error) {
          // Network failed, try cache
          return cache.match(event.request);
        }
      })
    );
  }
});
```

---

## 9. Key Findings Summary

### Critical Issues
1. **Empty IndexedDB:** 0 products despite successful backend sync
2. **No Population Logic:** API responses never saved to IndexedDB
3. **Schema Mismatch:** `article` field missing or incorrectly mapped
4. **Migration Side Effect:** v4 & v5 migrations cleared tables without re-population

### Architecture Gaps
1. **No Delta Sync Client:** Frontend always does full loads
2. **No Service Worker:** API responses not cached
3. **No Background Sync:** No automatic sync on app load
4. **Tight Coupling:** OrderForm responsible for data loading

### Performance Impact
1. **Slow Load Times:** Full API fetch (~5000 products) on every OrderForm mount
2. **Network Dependent:** Broken when offline
3. **Poor UX:** Empty dropdowns until API responds
4. **Wasted Bandwidth:** Re-downloading same data repeatedly

### Next Steps (Phase 28.2-02)
1. Implement SyncService to populate IndexedDB
2. Fix schema mapping (article field)
3. Add background sync on app mount
4. Test offline functionality
5. Implement delta sync client

---

**End of Data Flow Analysis**
