---
phase: 28.2-rewrite-orderform-with-proper-architecture
plan: 06
type: execute
---

<objective>
Wire all components together in new OrderForm, create E2E test suite, perform performance testing with real data volumes, conduct UAT with user, and execute production cutover with feature flag.

Purpose: Complete Phase 28.2 by integrating all pieces, thoroughly testing, and deploying to production.
Output: Production-ready OrderForm, comprehensive test suite, UAT approval, successful cutover.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-CONTEXT.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-01-PLAN.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-05-PLAN.md

**Dependencies:**
- All Plans 28.2-01 through 28.2-05 completed
- Services layer working (CustomerService, ProductService, OrderService)
- Components built (CustomerSelector, ProductSelector, QuantityInput, OrderItemsList, DiscountSystem, OrderSummary)
- PendingOrdersPage working
- Offline support implemented

**Migration Strategy (from Plan 28.2-01):**

**Big Bang Rewrite with Feature Flag**

1. Rename OrderForm.tsx → OrderForm_OLD_BACKUP.tsx
2. Create new OrderForm.tsx wiring all components together
3. Feature flag: `ENABLE_NEW_ORDER_FORM` env var
4. Routing logic to switch between old/new based on flag
5. Deploy with flag OFF (old form active)
6. Enable flag for testing
7. User validates new form (UAT)
8. Enable flag for production
9. Monitor for issues
10. Delete old code after 1 week stable

**Testing Strategy (from Plan 28.2-01):**

- Unit Tests: Pure calculation functions ✅ (completed in Plan 28.2-04)
- Integration Tests: Service layer ✅ (completed in Plan 28.2-02)
- Component Tests: UI components ✅ (completed in Plans 28.2-03, 28.2-04, 28.2-05)
- E2E Tests: Full user workflows (this plan)
- Performance Tests: Real data volumes ~1500 customers, ~5000 products (this plan)
- UAT: User acceptance testing (this plan)

**Success Criteria (from CONTEXT.md):**

**Must Have:**
- ✅ Customer selection works reliably (no race conditions)
- ✅ Product filtering works (IndexedDB populated correctly)
- ✅ Multi-article support functional
- ✅ Quantity + variant validation working
- ✅ Inline + global discount calculations correct
- ✅ Real-time summary displays correctly
- ✅ Edit/delete items functional
- ✅ Offline order creation works
- ✅ Pending orders queue displays correctly
- ✅ Batch submission to bot works

**Should Have:**
- Fast autocomplete (<100ms perceived latency)
- Mobile-friendly UI (responsive, touch targets)
- Error messages clear and helpful
- Accessibility compliant (keyboard nav, ARIA)
- Form state persists across refreshes (drafts)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire all components together in new OrderForm</name>
  <files>archibald-web-app/frontend/src/components/OrderForm.tsx (backup old, create new), archibald-web-app/frontend/src/components/OrderForm_OLD_BACKUP.tsx (renamed)</files>
  <action>
1. **Backup existing OrderForm**:
```bash
mv archibald-web-app/frontend/src/components/OrderForm.tsx \
   archibald-web-app/frontend/src/components/OrderForm_OLD_BACKUP.tsx
```

2. **Create new OrderForm.tsx** integrating all components:

```typescript
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { CustomerSelector } from './new-order-form/CustomerSelector';
import { ProductSelector } from './new-order-form/ProductSelector';
import { QuantityInput } from './new-order-form/QuantityInput';
import { OrderItemsList } from './new-order-form/OrderItemsList';
import { DiscountSystem } from './new-order-form/DiscountSystem';
import { OrderSummary } from './new-order-form/OrderSummary';
import { customerService } from '../services/customers.service';
import { productService } from '../services/products.service';
import { priceService } from '../services/prices.service';
import { orderService } from '../services/orders.service';
import { calculateItemTotals, calculateOrderTotals } from '../utils/order-calculations';
import type { Customer, Product, ProductVariant } from '../db/schema';
import type { OrderItem } from '../types/order';
import { v4 as uuidv4 } from 'uuid';

export default function OrderForm() {
  const navigate = useNavigate();

  // Customer state
  const [selectedCustomer, setSelectedCustomer] = useState<Customer | null>(null);

  // Product selection state (for adding new item)
  const [selectedProduct, setSelectedProduct] = useState<Product | null>(null);
  const [selectedVariant, setSelectedVariant] = useState<ProductVariant | null>(null);
  const [quantity, setQuantity] = useState(1);
  const [quantityValid, setQuantityValid] = useState(false);

  // Order items
  const [items, setItems] = useState<OrderItem[]>([]);

  // Global discount
  const [globalDiscountType, setGlobalDiscountType] = useState<'percentage' | 'amount'>('percentage');
  const [globalDiscountValue, setGlobalDiscountValue] = useState(0);

  // UI state
  const [submitting, setSubmitting] = useState(false);

  // Handle customer selection
  const handleCustomerSelect = (customer: Customer) => {
    setSelectedCustomer(customer);
  };

  // Handle product selection
  const handleProductSelect = async (product: Product) => {
    setSelectedProduct(product);

    // Auto-select variant based on default quantity
    const variant = await productService.getVariantByQuantity(product.id, quantity);
    setSelectedVariant(variant);
  };

  // Handle quantity change
  const handleQuantityChange = async (qty: number, isValid: boolean) => {
    setQuantity(qty);
    setQuantityValid(isValid);

    // Update variant based on new quantity
    if (selectedProduct) {
      const variant = await productService.getVariantByQuantity(selectedProduct.id, qty);
      setSelectedVariant(variant);
    }
  };

  // Add item to order
  const handleAddItem = async () => {
    if (!selectedProduct || !selectedVariant || !quantityValid) {
      alert('Seleziona prodotto e quantità valida');
      return;
    }

    // Get price
    const price = await priceService.getPriceByArticleId(selectedProduct.article || selectedProduct.id);

    if (!price) {
      alert('Prezzo non disponibile per questo prodotto');
      return;
    }

    // Calculate item totals
    const totals = calculateItemTotals({
      unitPrice: price,
      quantity,
    });

    const newItem: OrderItem = {
      id: uuidv4(),
      productId: selectedProduct.id,
      productName: selectedProduct.name,
      article: selectedProduct.article || '',
      description: selectedProduct.description,
      variantId: selectedVariant.variantId,
      quantity,
      packageContent: selectedVariant.packageContent,
      unitPrice: price,
      ...totals,
    };

    setItems([...items, newItem]);

    // Reset selection
    setSelectedProduct(null);
    setSelectedVariant(null);
    setQuantity(1);
  };

  // Edit item
  const handleEditItem = (itemId: string, updates: Partial<OrderItem>) => {
    setItems((prevItems) =>
      prevItems.map((item) => {
        if (item.id !== itemId) return item;

        // Recalculate totals with updates
        const updatedItem = { ...item, ...updates };
        const totals = calculateItemTotals({
          unitPrice: updatedItem.unitPrice,
          quantity: updatedItem.quantity,
          discountType: updatedItem.discountType,
          discountValue: updatedItem.discountValue,
        });

        return { ...updatedItem, ...totals };
      })
    );
  };

  // Delete item
  const handleDeleteItem = (itemId: string) => {
    setItems((prevItems) => prevItems.filter((item) => item.id !== itemId));
  };

  // Calculate order totals
  const orderTotals = calculateOrderTotals(items, {
    discountType: globalDiscountType,
    discountValue: globalDiscountValue,
  });

  // Submit order
  const handleSubmitOrder = async () => {
    if (!selectedCustomer) {
      alert('Seleziona un cliente');
      return;
    }

    if (items.length === 0) {
      alert('Aggiungi almeno un articolo');
      return;
    }

    setSubmitting(true);

    try {
      // Save to pending orders queue
      await orderService.savePendingOrder({
        customerId: selectedCustomer.id,
        customerName: selectedCustomer.name,
        items: items.map((item) => ({
          articleCode: item.article,
          productName: item.productName,
          description: item.description,
          quantity: item.quantity,
          price: item.unitPrice,
          discount: item.discount,
        })),
        discountPercent: globalDiscountType === 'percentage' ? globalDiscountValue : undefined,
        targetTotalWithVAT: undefined, // Could add reverse calc target here
        createdAt: new Date().toISOString(),
        status: 'pending',
        retryCount: 0,
      });

      alert('Ordine salvato nella coda. Vai a "Ordini in Attesa" per inviarlo.');

      // Clear form
      setSelectedCustomer(null);
      setItems([]);
      setGlobalDiscountValue(0);

      // Navigate to pending orders
      navigate('/pending-orders');
    } catch (error) {
      console.error('[OrderForm] Failed to save order:', error);
      alert('Errore durante il salvataggio dell\'ordine');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div style={{ maxWidth: '1200px', margin: '0 auto', padding: '2rem' }}>
      <h1 style={{ fontSize: '2rem', fontWeight: '700', marginBottom: '2rem' }}>
        Nuovo Ordine
      </h1>

      {/* Customer Selection */}
      <div style={{ marginBottom: '2rem' }}>
        <CustomerSelector onSelect={handleCustomerSelect} />
      </div>

      {/* Product Selection (only if customer selected) */}
      {selectedCustomer && (
        <>
          <div
            style={{
              display: 'grid',
              gridTemplateColumns: '2fr 1fr 100px',
              gap: '1rem',
              marginBottom: '2rem',
            }}
          >
            <ProductSelector onSelect={handleProductSelect} />

            {selectedProduct && (
              <>
                <QuantityInput
                  productId={selectedProduct.id}
                  variant={selectedVariant}
                  value={quantity}
                  onChange={handleQuantityChange}
                />

                <button
                  onClick={handleAddItem}
                  disabled={!quantityValid}
                  style={{
                    padding: '0.5rem',
                    backgroundColor: quantityValid ? '#22c55e' : '#d1d5db',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    fontWeight: '600',
                    cursor: quantityValid ? 'pointer' : 'not-allowed',
                  }}
                >
                  Aggiungi
                </button>
              </>
            )}
          </div>

          {/* Order Items List */}
          <div style={{ marginBottom: '2rem' }}>
            <OrderItemsList
              items={items}
              onEditItem={handleEditItem}
              onDeleteItem={handleDeleteItem}
            />
          </div>

          {/* Discount System (only if items exist) */}
          {items.length > 0 && (
            <div style={{ marginBottom: '2rem' }}>
              <DiscountSystem
                orderSubtotal={orderTotals.itemsSubtotal}
                discountType={globalDiscountType}
                discountValue={globalDiscountValue}
                onDiscountChange={(type, value) => {
                  setGlobalDiscountType(type);
                  setGlobalDiscountValue(value);
                }}
              />
            </div>
          )}

          {/* Order Summary (only if items exist) */}
          {items.length > 0 && (
            <div style={{ marginBottom: '2rem' }}>
              <OrderSummary orderTotals={orderTotals} />
            </div>
          )}

          {/* Submit Button */}
          {items.length > 0 && (
            <div style={{ textAlign: 'right' }}>
              <button
                onClick={handleSubmitOrder}
                disabled={submitting}
                style={{
                  padding: '1rem 2rem',
                  backgroundColor: submitting ? '#d1d5db' : '#3b82f6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  fontSize: '1.125rem',
                  fontWeight: '600',
                  cursor: submitting ? 'not-allowed' : 'pointer',
                }}
              >
                {submitting ? 'Salvataggio...' : 'Crea Ordine'}
              </button>
            </div>
          )}
        </>
      )}
    </div>
  );
}
```

3. **Create feature flag mechanism**:

Add to `.env`:
```
VITE_ENABLE_NEW_ORDER_FORM=false
```

Create routing wrapper:
```typescript
// In routes/router.tsx or App.tsx
const OrderFormComponent =
  import.meta.env.VITE_ENABLE_NEW_ORDER_FORM === 'true'
    ? OrderForm
    : OrderForm_OLD_BACKUP;

<Route path="/order" element={<OrderFormComponent />} />
```

4. **Test integration**:
- Build and run app
- Verify new form renders without errors
- Test basic workflow: select customer → add product → submit
  </action>
  <verify>
1. Old OrderForm backed up to OrderForm_OLD_BACKUP.tsx
2. New OrderForm.tsx created and compiles
3. Feature flag mechanism working
4. App runs without errors
5. Basic workflow works (customer → product → submit)
6. Can toggle between old/new form with env var
  </verify>
  <done>New OrderForm integrated, feature flag working</done>
</task>

<task type="auto">
  <name>Task 2: Create E2E test suite with Playwright/Cypress</name>
  <files>archibald-web-app/frontend/e2e/order-form.spec.ts (new)</files>
  <action>
Create E2E tests for full user workflows:

**Test Scenarios:**

1. **Complete Online Order Flow**:
   - Navigate to /order
   - Select customer by typing name
   - Add first product with quantity
   - Add second product with different quantity
   - Apply inline discount to one item
   - Apply global discount
   - Verify order summary totals
   - Submit order
   - Verify redirect to /pending-orders
   - Verify order appears in pending queue

2. **Offline Order Creation**:
   - Go offline (network: offline)
   - Navigate to /order
   - Create order with 2 items
   - Submit order
   - Verify success message
   - Verify order saved to IndexedDB
   - Go online
   - Verify sync banner appears
   - Navigate to /pending-orders
   - Verify order exists

3. **Edit and Delete Items**:
   - Create order with 3 items
   - Click edit on item 2
   - Change quantity
   - Verify totals recalculate
   - Delete item 3
   - Verify removed from list
   - Verify totals recalculate

4. **Batch Order Submission**:
   - Create 3 pending orders
   - Navigate to /pending-orders
   - Select 2 orders with checkboxes
   - Click "Invia Ordini Selezionati"
   - Verify orders submitted to bot
   - Wait for completion
   - Verify orders removed from queue

Example E2E test (Playwright):
```typescript
import { test, expect } from '@playwright/test';

test.describe('OrderForm E2E', () => {
  test('complete online order flow', async ({ page }) => {
    // Navigate to order form
    await page.goto('/order');

    // Select customer
    await page.fill('[aria-label="Cerca cliente"]', 'Mario');
    await page.waitForSelector('text=Mario Rossi');
    await page.click('text=Mario Rossi');

    // Verify customer selected
    await expect(page.locator('text=✅ Cliente selezionato: Mario Rossi')).toBeVisible();

    // Select first product
    await page.fill('[aria-label="Cerca prodotto"]', 'vite');
    await page.waitForSelector('text=Vite M10');
    await page.click('text=Vite M10');

    // Enter quantity
    await page.fill('[aria-label="Quantità"]', '50');

    // Add item
    await page.click('button:has-text("Aggiungi")');

    // Verify item added to list
    await expect(page.locator('text=Vite M10')).toBeVisible();

    // Submit order
    await page.click('button:has-text("Crea Ordine")');

    // Verify redirect to pending orders
    await expect(page).toHaveURL('/pending-orders');

    // Verify order in queue
    await expect(page.locator('text=Mario Rossi')).toBeVisible();
  });

  // More tests...
});
```

Run E2E tests:
```bash
npm run test:e2e
```
  </action>
  <verify>
1. E2E test suite created
2. All 4 test scenarios implemented
3. Tests pass in CI/local environment
4. Coverage includes happy paths and edge cases
5. Tests run in < 5 minutes total
  </verify>
  <done>E2E test suite complete and passing</done>
</task>

<task type="auto">
  <name>Task 3: Performance testing with real data volumes</name>
  <files>archibald-web-app/frontend/tests/performance/order-form.perf.ts (new)</files>
  <action>
Test performance with real data volumes:

**Test Scenarios:**

1. **Customer Autocomplete Performance**:
   - Populate IndexedDB with 1500 customers
   - Measure search latency for queries: "mar", "mario", "rossi"
   - Target: <100ms perceived latency
   - Verify debouncing reduces excessive searches

2. **Product Autocomplete Performance**:
   - Populate IndexedDB with 5000 products
   - Measure search latency for queries: "vite", "h129", "articolo"
   - Target: <100ms perceived latency
   - Test both name and article code searches

3. **Order Calculation Performance**:
   - Create order with 50 items
   - Measure time to recalculate totals when:
     - Adding item
     - Editing item quantity
     - Applying global discount
   - Target: <50ms (real-time feel)

4. **Pending Orders Page Load**:
   - Populate queue with 100 pending orders
   - Measure page load time
   - Target: <500ms initial render

Example performance test:
```typescript
import { performance } from 'perf_hooks';
import { customerService } from '../services/customers.service';

describe('Performance Tests', () => {
  test('customer search completes in <100ms', async () => {
    const start = performance.now();
    const results = await customerService.searchCustomers('mario');
    const end = performance.now();

    const duration = end - start;
    console.log(`Customer search took ${duration.toFixed(2)}ms`);

    expect(duration).toBeLessThan(100);
    expect(results.length).toBeGreaterThan(0);
  });

  // More performance tests...
});
```

Run performance tests and document results.
  </action>
  <verify>
1. Performance test suite created
2. All scenarios tested with real data volumes
3. Customer autocomplete: <100ms ✅
4. Product autocomplete: <100ms ✅
5. Order calculations: <50ms ✅
6. Pending orders page: <500ms ✅
7. Performance report generated
  </verify>
  <done>Performance testing complete, targets met</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete integrated OrderForm with all features working</what-built>
  <how-to-verify>
**User Acceptance Testing (UAT) Checklist**

Enable new form: Set `VITE_ENABLE_NEW_ORDER_FORM=true` in `.env`, rebuild.

**Test 1: Customer Selection**
- [ ] Click customer input → dropdown appears
- [ ] Type "mario" → customers with "Mario" appear
- [ ] Arrow keys navigate results
- [ ] Enter or click selects customer
- [ ] Confirmation message appears

**Test 2: Product Selection**
- [ ] Type product name → results appear
- [ ] Type article code (e.g., "h129") → results appear
- [ ] Product shows name + article + description
- [ ] Selection works

**Test 3: Quantity & Variants**
- [ ] Variant constraints displayed (min/max/multiples)
- [ ] Enter quantity below min → error message
- [ ] Enter valid quantity → no error
- [ ] Package content displayed

**Test 4: Add Multiple Items**
- [ ] Add 3 different products
- [ ] All items appear in list
- [ ] Each item shows: name, qty, price, total

**Test 5: Edit Item**
- [ ] Click edit icon on an item
- [ ] Modal opens with current values
- [ ] Change quantity → save
- [ ] Verify item updated, totals recalculated

**Test 6: Delete Item**
- [ ] Click delete icon
- [ ] Confirmation dialog appears
- [ ] Confirm → item removed
- [ ] Totals recalculate

**Test 7: Inline Discount**
- [ ] Edit item, add 10% discount
- [ ] Verify discount appears in list
- [ ] Verify line total recalculates

**Test 8: Global Discount**
- [ ] Enter 15% global discount
- [ ] Verify order total recalculates
- [ ] Switch to amount (€50)
- [ ] Verify recalculation

**Test 9: Reverse Calculation**
- [ ] Current total: €244
- [ ] Enter target total: €183
- [ ] Verify discount auto-calculates to 25%
- [ ] Verify new total matches target

**Test 10: Order Summary**
- [ ] Displays items subtotal
- [ ] Displays global discount
- [ ] Displays VAT (22%)
- [ ] Displays total with VAT
- [ ] All values update in real-time

**Test 11: Offline Order**
- [ ] Go offline (airplane mode)
- [ ] Create order with 2 items
- [ ] Submit → success message
- [ ] Navigate to /pending-orders
- [ ] Order appears with "In Attesa" status

**Test 12: Online Sync**
- [ ] With pending orders, go online
- [ ] Banner appears: "Hai X ordini da inviare"
- [ ] Click "Vai agli Ordini"
- [ ] Navigate to pending orders page

**Test 13: Batch Submission**
- [ ] Create 3 pending orders
- [ ] Go to /pending-orders
- [ ] Select 2 orders with checkboxes
- [ ] Click "Invia Ordini Selezionati"
- [ ] Verify orders submitted

**Test 14: Mobile UX**
- [ ] Test on mobile device or responsive mode
- [ ] All touch targets large enough
- [ ] Dropdowns work on mobile
- [ ] Form usable on small screen

**Test 15: Performance**
- [ ] Autocomplete feels fast
- [ ] No lag when typing
- [ ] Calculations instant
- [ ] Page loads quickly

**Overall Assessment:**
- [ ] All features working as expected
- [ ] UX feels "optimal, fast, responsive" (user requirement)
- [ ] No critical bugs
- [ ] Ready for production
  </how-to-verify>
  <resume-signal>Complete UAT checklist above. Type "approved" if all tests pass and ready for production, or list issues found</resume-signal>
</task>

<task type="auto">
  <name>Task 4: Production cutover with monitoring</name>
  <files>.env (production), deployment scripts</files>
  <action>
Execute production deployment:

**Step 1: Pre-Deployment**
- Commit all changes to git
- Create release branch: `release/phase-28.2-new-orderform`
- Tag release: `v28.2.0`
- Push to remote

**Step 2: Deploy with Feature Flag OFF**
- Deploy to production with `VITE_ENABLE_NEW_ORDER_FORM=false`
- Verify old form still working
- Monitor for any deployment issues

**Step 3: Enable Feature Flag for Testing**
- Set `VITE_ENABLE_NEW_ORDER_FORM=true` on staging/test environment
- User tests new form in production-like environment
- Verify all functionality working

**Step 4: Production Cutover**
- Set `VITE_ENABLE_NEW_ORDER_FORM=true` on production
- Rebuild and deploy
- Monitor application logs for errors
- Monitor user activity

**Step 5: Post-Cutover Monitoring (24-48 hours)**
- Check error logs for issues
- Monitor performance metrics
- Check user feedback
- Verify orders submitting successfully

**Step 6: Cleanup (after 1 week stable)**
- If no issues, remove feature flag
- Delete OrderForm_OLD_BACKUP.tsx
- Remove old dependencies
- Update documentation

**Rollback Procedure (if issues):**
- Set `VITE_ENABLE_NEW_ORDER_FORM=false`
- Rebuild and deploy
- Old form immediately active
- Investigate issues before retry

Document all steps and outcomes.
  </action>
  <verify>
1. Production deployed successfully
2. Feature flag toggled to new form
3. No critical errors in logs
4. Orders submitting successfully
5. User satisfied with new form
6. Performance metrics good
7. Rollback procedure tested (if needed)
  </verify>
  <done>Production cutover complete, new OrderForm live</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] New OrderForm integrated with all components
- [ ] Feature flag mechanism working
- [ ] E2E test suite created and passing
- [ ] Performance testing complete, targets met
- [ ] UAT completed by user (all tests passed)
- [ ] Production deployment successful
- [ ] Feature flag enabled in production
- [ ] Monitoring shows no critical issues
- [ ] User confirmed new form working in production
</verification>

<success_criteria>
- New OrderForm fully integrated and working
- All E2E tests passing
- Performance targets met (<100ms autocomplete, <50ms calculations)
- UAT completed with user approval
- Production cutover successful with no critical issues
- User satisfied with new OrderForm UX and functionality
- All 9 requirements from CONTEXT.md fulfilled
- Old OrderForm can be safely deleted after 1 week stable
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-06-SUMMARY.md`:

# Phase 28.2 Plan 06: Integration & Testing - Summary

**OrderForm rewrite complete - production deployment successful**

## Accomplishments

- Integrated all components into new OrderForm.tsx
- Backed up old OrderForm to OrderForm_OLD_BACKUP.tsx
- Implemented feature flag for safe cutover
- Created comprehensive E2E test suite (4 test scenarios)
- Performed performance testing with real data volumes
- Conducted UAT with user (15-point checklist)
- Executed production deployment with feature flag
- Monitored production for 48 hours - no critical issues
- User approved new form for production use

## Files Created/Modified

- `archibald-web-app/frontend/src/components/OrderForm.tsx` - New integrated form
- `archibald-web-app/frontend/src/components/OrderForm_OLD_BACKUP.tsx` - Old form backup
- `archibald-web-app/frontend/e2e/order-form.spec.ts` - E2E test suite
- `archibald-web-app/frontend/tests/performance/order-form.perf.ts` - Performance tests
- `.env` - Feature flag: `VITE_ENABLE_NEW_ORDER_FORM=true`

## Test Results

**E2E Tests:**
- ✅ Complete online order flow
- ✅ Offline order creation
- ✅ Edit and delete items
- ✅ Batch order submission

**Performance Tests:**
- ✅ Customer autocomplete: [X]ms (< 100ms target)
- ✅ Product autocomplete: [X]ms (< 100ms target)
- ✅ Order calculations: [X]ms (< 50ms target)
- ✅ Pending orders page load: [X]ms (< 500ms target)

**UAT Results:**
- All 15 test scenarios passed ✅
- User feedback: [Document user's assessment]

## Production Deployment

**Timeline:**
- Deployed: [Date/Time]
- Feature flag enabled: [Date/Time]
- Monitoring period: [48 hours]

**Metrics:**
- Orders created: [X]
- Success rate: [X%]
- Average form completion time: [X seconds]
- Error rate: [X%]

**Issues Encountered:**
[Document any issues or "None"]

## Rollback Plan

Feature flag allows instant rollback:
1. Set `VITE_ENABLE_NEW_ORDER_FORM=false`
2. Rebuild and deploy
3. Old form immediately active

**Rollback Needed:** [Yes/No]

## Next Steps

**Immediate (Post-Deployment):**
- Continue monitoring for 1 week
- Gather user feedback
- Fix any minor issues discovered

**Cleanup (After 1 Week Stable):**
- Remove feature flag if no issues
- Delete OrderForm_OLD_BACKUP.tsx
- Update documentation
- Close Phase 28.2

**Future Enhancements (Nice to Have):**
- Undo/redo for item edits
- Keyboard shortcuts for power users
- CSV import for bulk orders
- Order templates for recurring orders

## Phase 28.2 Complete

✅ **All 9 Requirements Fulfilled:**
1. ✅ Customer selection by NOME (fast autocomplete)
2. ✅ Product selection by NOME ARTICOLO (fast autocomplete)
3. ✅ Multi-article support (1-N items)
4. ✅ Quantity + variant management
5. ✅ Dual discount system (inline + global + reverse calc)
6. ✅ Real-time summary with VAT display
7. ✅ Edit/delete items
8. ✅ Pending orders queue with batch submission
9. ✅ Offline support with auto-sync

**Success Criteria Met:**
- ✅ Customer selection reliable (no race conditions)
- ✅ Product filtering works (IndexedDB populated)
- ✅ All calculations correct (tested extensively)
- ✅ Offline-first functionality working
- ✅ Performance targets met
- ✅ Accessible and mobile-friendly
- ✅ User satisfied with UX

**Business Impact:**
- Time and money savings (no more debugging unstable form)
- Reliable order creation process
- Offline capability enables field usage
- Clean architecture enables future enhancements

## Thank You

Phase 28.2 rewrite successful. OrderForm now stable, maintainable, and feature-complete.
</output>
