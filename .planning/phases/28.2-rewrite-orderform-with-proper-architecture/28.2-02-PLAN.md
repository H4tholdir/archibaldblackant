---
phase: 28.2-rewrite-orderform-with-proper-architecture
plan: 02
type: execute
---

<objective>
Build clean service layer for customers, products, prices, and orders with IndexedDB cache-first pattern, API fallback, and comprehensive test coverage.

Purpose: Create testable, maintainable data layer that abstracts IndexedDB and API interactions from UI components.
Output: 4 service files (CustomerService, ProductService, PriceService, OrderService) with unit tests and working IndexedDB integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
@~/.claude/get-shit-done/references/tdd.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-CONTEXT.md
@.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-01-PLAN.md
@archibald-web-app/frontend/src/db/schema.ts
@archibald-web-app/frontend/src/services/cache-service.ts
@archibald-web-app/backend/src/routes/customers.ts
@archibald-web-app/backend/src/routes/products.ts

**Dependencies:**
- Plan 28.2-01 completed (architecture design available)
- IndexedDB schema exists (v5 - customers, products, productVariants, prices)
- API endpoints exist (GET /api/customers, GET /api/products)
- Dexie.js already in use

**Requirements from CONTEXT.md:**
1. Customer search by NOME (~1500 records, <100ms autocomplete)
2. Product search by NOME ARTICOLO (~5000 records, <100ms autocomplete)
3. Variant selection by quantity (multipleQty, minQty, maxQty)
4. Price lookup by article ID
5. Draft order save/load (offline drafts)
6. Pending order queue (offline submission)
7. Cache-first pattern (IndexedDB → API fallback)
8. Sync orchestrator integration

**Current Issues to Fix:**
- IndexedDB products table empty (0 records)
- Sync orchestrator not populating cache
- No clear separation between data access and UI logic
- Error handling insufficient

**Service Layer Contracts (from Plan 28.2-01):**

```typescript
// CustomerService
interface CustomerService {
  searchCustomers(query: string, limit?: number): Promise<Customer[]>
  getCustomerById(id: string): Promise<Customer | null>
  syncCustomers(): Promise<void>
  getCacheMetadata(): Promise<CacheMetadata | null>
}

// ProductService
interface ProductService {
  searchProducts(query: string, limit?: number): Promise<Product[]>
  getProductById(id: string): Promise<Product | null>
  getVariantByQuantity(productId: string, quantity: number): Promise<ProductVariant | null>
  syncProducts(): Promise<void>
  getCacheMetadata(): Promise<CacheMetadata | null>
}

// PriceService
interface PriceService {
  getPriceByArticleId(articleId: string): Promise<number | null>
  syncPrices(): Promise<void>
}

// OrderService
interface OrderService {
  saveDraftOrder(order: DraftOrder): Promise<number>
  getDraftOrders(): Promise<DraftOrder[]>
  deleteDraftOrder(id: number): Promise<void>
  savePendingOrder(order: PendingOrder): Promise<number>
  getPendingOrders(): Promise<PendingOrder[]>
  updatePendingOrderStatus(id: number, status: 'syncing' | 'error' | 'pending'): Promise<void>
}
```

**Performance Requirements:**
- Search autocomplete: <100ms perceived latency
- Debouncing: 300ms for search inputs
- Virtualization: If >1000 items in dropdown
- Memoization: Cache search results

**Testing Requirements:**
- Unit tests for all service methods
- Mock IndexedDB with Dexie test utilities
- Test cache-first fallback pattern
- Test error handling (network failures, empty cache)
- Test variant selection logic edge cases
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build CustomerService with cache-first pattern</name>
  <files>archibald-web-app/frontend/src/services/customers.service.ts (new), archibald-web-app/frontend/src/services/customers.service.spec.ts (new)</files>
  <action>
Following TDD approach:

1. **Create test file first**: `customers.service.spec.ts`

Write tests for:
- `searchCustomers()`: Returns customers from IndexedDB filtered by name
- `searchCustomers()` with empty cache: Falls back to API
- `getCustomerById()`: Returns single customer by ID
- `getCustomerById()` not found: Returns null
- `syncCustomers()`: Fetches from API and populates IndexedDB
- `getCacheMetadata()`: Returns last sync time and record count

Use Dexie test utilities to mock IndexedDB.

Example test structure:
```typescript
import { describe, test, expect, beforeEach, afterEach } from 'vitest';
import Dexie from 'dexie';
import { CustomerService } from './customers.service';

describe('CustomerService', () => {
  let db: TestDatabase;
  let service: CustomerService;

  beforeEach(async () => {
    // Setup test IndexedDB
    db = new TestDatabase();
    service = new CustomerService(db);
  });

  afterEach(async () => {
    // Cleanup
    await db.delete();
  });

  describe('searchCustomers', () => {
    test('returns customers matching query from cache', async () => {
      // Arrange: populate IndexedDB with test data
      await db.customers.bulkAdd([
        { id: '1', name: 'Mario Rossi', code: 'MR001', ... },
        { id: '2', name: 'Luigi Verdi', code: 'LV001', ... },
      ]);

      // Act
      const results = await service.searchCustomers('mario');

      // Assert
      expect(results).toHaveLength(1);
      expect(results[0].name).toBe('Mario Rossi');
    });

    test('falls back to API when cache empty', async () => {
      // Arrange: empty cache, mock fetch
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: async () => [{ id: '1', name: 'Mario Rossi', ... }],
      });

      // Act
      const results = await service.searchCustomers('mario');

      // Assert
      expect(results).toHaveLength(1);
      expect(global.fetch).toHaveBeenCalledWith('/api/customers?search=mario');
    });
  });

  // ... more tests
});
```

2. **Implement CustomerService**: `customers.service.ts`

Follow this structure:
```typescript
import { db } from '../db/schema';
import type { Customer, CacheMetadata } from '../db/schema';

export class CustomerService {
  /**
   * Search customers by name (cache-first, API fallback)
   * @param query - Search query string
   * @param limit - Max results (default 50)
   * @returns Array of matching customers
   */
  async searchCustomers(query: string, limit: number = 50): Promise<Customer[]> {
    // 1. Try cache first
    try {
      const cached = await db.customers
        .where('name')
        .startsWithIgnoreCase(query)
        .limit(limit)
        .toArray();

      if (cached.length > 0) {
        return cached;
      }
    } catch (error) {
      console.warn('[CustomerService] Cache search failed:', error);
    }

    // 2. Fallback to API
    try {
      const response = await fetch(`/api/customers?search=${encodeURIComponent(query)}`);
      if (!response.ok) throw new Error('API fetch failed');

      const data = await response.json();
      return data;
    } catch (error) {
      console.error('[CustomerService] API fetch failed:', error);
      return [];
    }
  }

  async getCustomerById(id: string): Promise<Customer | null> {
    // Implementation
  }

  async syncCustomers(): Promise<void> {
    // Fetch all customers from API, populate IndexedDB
    // Update cache metadata
  }

  async getCacheMetadata(): Promise<CacheMetadata | null> {
    // Return cache metadata for 'customers' key
  }
}

// Singleton instance
export const customerService = new CustomerService();
```

3. **Run tests**: Ensure all tests pass before moving on

DO NOT over-engineer - keep it simple and focused on the requirements.
AVOID adding features not specified in requirements.
DO add proper error handling and logging.
  </action>
  <verify>
1. `npm test customers.service.spec.ts` passes
2. All 6+ test cases passing
3. CustomerService implements all interface methods
4. Cache-first pattern working correctly
5. API fallback tested and working
  </verify>
  <done>CustomerService implemented with passing tests</done>
</task>

<task type="auto">
  <name>Task 2: Build ProductService with variant selection logic</name>
  <files>archibald-web-app/frontend/src/services/products.service.ts (new), archibald-web-app/frontend/src/services/products.service.spec.ts (new)</files>
  <action>
Following TDD approach:

1. **Create test file first**: `products.service.spec.ts`

Write tests for:
- `searchProducts()`: Returns products from IndexedDB filtered by name or article
- `searchProducts()` by article code: Filters by article field
- `searchProducts()` with empty cache: Falls back to API
- `getProductById()`: Returns product with variants
- `getVariantByQuantity()`: Selects correct variant based on quantity
- `getVariantByQuantity()` edge cases:
  - Quantity below minQty of all variants → return null
  - Quantity above maxQty of all variants → return highest variant
  - Quantity not multiple of multipleQty → round down to nearest multiple
  - Multiple variants match → return best fit
- `syncProducts()`: Fetches products + variants from API, populates IndexedDB

Example test for variant selection:
```typescript
describe('getVariantByQuantity', () => {
  test('selects variant matching quantity range', async () => {
    // Arrange: Product with 3 variants
    await db.products.add({ id: 'P1', name: 'Vite', article: 'V001', ... });
    await db.productVariants.bulkAdd([
      { productId: 'P1', variantId: 'V1', multipleQty: 10, minQty: 10, maxQty: 50, packageContent: 'Box 10' },
      { productId: 'P1', variantId: 'V2', multipleQty: 50, minQty: 50, maxQty: 200, packageContent: 'Box 50' },
      { productId: 'P1', variantId: 'V3', multipleQty: 100, minQty: 200, maxQty: 1000, packageContent: 'Pallet 100' },
    ]);

    // Act: Request 120 units
    const variant = await service.getVariantByQuantity('P1', 120);

    // Assert: Should select V2 (50-200 range)
    expect(variant).not.toBeNull();
    expect(variant!.variantId).toBe('V2');
    expect(variant!.packageContent).toBe('Box 50');
  });

  test('returns null when quantity below minimum', async () => {
    // Test edge case
  });

  test('returns highest variant when quantity above maximum', async () => {
    // Test edge case
  });

  test('handles quantity not multiple of multipleQty', async () => {
    // Test rounding logic
  });
});
```

2. **Implement ProductService**: `products.service.ts`

Key method - variant selection logic:
```typescript
async getVariantByQuantity(productId: string, quantity: number): Promise<ProductVariant | null> {
  // 1. Get all variants for product
  const variants = await db.productVariants
    .where('productId')
    .equals(productId)
    .sortBy('minQty'); // Sort by minQty ascending

  if (variants.length === 0) return null;

  // 2. Filter variants where quantity fits in [minQty, maxQty] range
  const matchingVariants = variants.filter(
    v => quantity >= v.minQty && quantity <= v.maxQty
  );

  if (matchingVariants.length > 0) {
    // Return first matching variant (lowest minQty)
    return matchingVariants[0];
  }

  // 3. Edge case: quantity below all minQty
  if (quantity < variants[0].minQty) {
    return null; // Invalid quantity
  }

  // 4. Edge case: quantity above all maxQty
  // Return variant with highest maxQty
  return variants[variants.length - 1];
}
```

Implement other methods following same pattern as CustomerService.

3. **Run tests**: Ensure all tests pass

CRITICAL: Variant selection logic must be correct - this is core business logic.
  </action>
  <verify>
1. `npm test products.service.spec.ts` passes
2. All variant selection edge cases tested and passing
3. ProductService implements all interface methods
4. Article code search working
5. Cache-first pattern working
  </verify>
  <done>ProductService implemented with passing tests, variant logic verified</done>
</task>

<task type="auto">
  <name>Task 3: Build PriceService and OrderService</name>
  <files>archibald-web-app/frontend/src/services/prices.service.ts (new), archibald-web-app/frontend/src/services/prices.service.spec.ts (new), archibald-web-app/frontend/src/services/orders.service.ts (new), archibald-web-app/frontend/src/services/orders.service.spec.ts (new)</files>
  <action>
Following TDD approach for both services:

**PriceService** (simpler):

Tests:
- `getPriceByArticleId()`: Returns price from cache
- `getPriceByArticleId()` not found: Returns null
- `syncPrices()`: Fetches from API and populates IndexedDB

Implementation:
```typescript
export class PriceService {
  async getPriceByArticleId(articleId: string): Promise<number | null> {
    try {
      const price = await db.prices
        .where('articleId')
        .equals(articleId)
        .first();

      return price ? price.price : null;
    } catch (error) {
      console.error('[PriceService] Failed to get price:', error);
      return null;
    }
  }

  async syncPrices(): Promise<void> {
    // Fetch from /api/prices, populate IndexedDB
  }
}
```

**OrderService** (more complex):

Tests:
- `saveDraftOrder()`: Saves to draftOrders table, returns ID
- `getDraftOrders()`: Returns all drafts sorted by updatedAt
- `deleteDraftOrder()`: Removes draft by ID
- `savePendingOrder()`: Saves to pendingOrders table with status 'pending'
- `getPendingOrders()`: Returns all pending orders
- `updatePendingOrderStatus()`: Updates order status (syncing/error/pending)

Implementation:
```typescript
export class OrderService {
  async saveDraftOrder(order: Omit<DraftOrder, 'id'>): Promise<number> {
    const id = await db.draftOrders.add({
      ...order,
      updatedAt: new Date().toISOString(),
    });
    return id as number;
  }

  async getDraftOrders(): Promise<DraftOrder[]> {
    return db.draftOrders
      .orderBy('updatedAt')
      .reverse() // Most recent first
      .toArray();
  }

  async deleteDraftOrder(id: number): Promise<void> {
    await db.draftOrders.delete(id);
  }

  async savePendingOrder(order: Omit<PendingOrder, 'id'>): Promise<number> {
    const id = await db.pendingOrders.add({
      ...order,
      createdAt: new Date().toISOString(),
      status: 'pending',
      retryCount: 0,
    });
    return id as number;
  }

  async getPendingOrders(): Promise<PendingOrder[]> {
    return db.pendingOrders
      .where('status')
      .anyOf(['pending', 'error']) // Exclude 'syncing' (in progress)
      .sortBy('createdAt'); // Oldest first
  }

  async updatePendingOrderStatus(
    id: number,
    status: 'syncing' | 'error' | 'pending',
    errorMessage?: string
  ): Promise<void> {
    await db.pendingOrders.update(id, {
      status,
      ...(errorMessage && { errorMessage }),
    });
  }
}
```

Run tests for both services, ensure all pass.
  </action>
  <verify>
1. `npm test prices.service.spec.ts` passes
2. `npm test orders.service.spec.ts` passes
3. PriceService and OrderService implement all methods
4. Draft order CRUD working
5. Pending order queue working with status updates
  </verify>
  <done>PriceService and OrderService implemented with passing tests</done>
</task>

<task type="auto">
  <name>Task 4: Fix IndexedDB sync integration</name>
  <files>archibald-web-app/frontend/src/services/sync.service.ts (new or update existing), archibald-web-app/frontend/src/services/cache-service.ts</files>
  <action>
Root cause investigation and fix:

1. **Investigate why IndexedDB is empty**:

Check existing `cache-service.ts`:
- Does it have sync methods?
- Are they being called anywhere?
- Is there a background sync service?

Search for sync orchestrator integration:
```bash
# Find files that import cache-service
rg "import.*cache-service" archibald-web-app/frontend/src/

# Find sync-related files
find archibald-web-app/frontend/src -name "*sync*"

# Find where sync might be triggered
rg "sync(Products|Customers)" archibald-web-app/frontend/src/
```

2. **Create or update SyncService**:

If sync service doesn't exist, create it:
```typescript
// sync.service.ts
import { customerService } from './customers.service';
import { productService } from './products.service';
import { priceService } from './prices.service';

export class SyncService {
  private syncInProgress = false;

  /**
   * Sync all data from backend to IndexedDB
   * Called on: app startup, manual refresh, periodic background
   */
  async syncAll(): Promise<void> {
    if (this.syncInProgress) {
      console.log('[SyncService] Sync already in progress, skipping');
      return;
    }

    this.syncInProgress = true;

    try {
      console.log('[SyncService] Starting full sync...');

      // Sync in parallel for performance
      await Promise.all([
        customerService.syncCustomers(),
        productService.syncProducts(),
        priceService.syncPrices(),
      ]);

      console.log('[SyncService] Full sync completed');
    } catch (error) {
      console.error('[SyncService] Sync failed:', error);
      throw error;
    } finally {
      this.syncInProgress = false;
    }
  }

  /**
   * Trigger sync on app initialization
   */
  async initializeSync(): Promise<void> {
    // Check if cache is stale or empty
    const customersMetadata = await customerService.getCacheMetadata();
    const productsMetadata = await productService.getCacheMetadata();

    const needsSync =
      !customersMetadata ||
      !productsMetadata ||
      customersMetadata.recordCount === 0 ||
      productsMetadata.recordCount === 0;

    if (needsSync) {
      console.log('[SyncService] Cache empty or stale, triggering sync');
      await this.syncAll();
    } else {
      console.log('[SyncService] Cache is fresh, skipping sync');
    }
  }
}

export const syncService = new SyncService();
```

3. **Integrate SyncService with app initialization**:

Find app entry point (likely `main.tsx` or `App.tsx`):
```typescript
// In main.tsx or App.tsx
import { syncService } from './services/sync.service';

// On app mount
useEffect(() => {
  syncService.initializeSync().catch(console.error);
}, []);
```

4. **Test sync integration**:

- Clear IndexedDB in browser DevTools
- Reload app
- Verify sync triggers automatically
- Verify IndexedDB populated with data
- Check console logs for sync progress

This should fix the empty IndexedDB issue.
  </action>
  <verify>
1. SyncService created or updated
2. Integration with app initialization added
3. Clear IndexedDB and reload → sync triggers automatically
4. IndexedDB populated with customers, products, variants, prices
5. Console logs show sync progress
6. Cache metadata updated correctly
  </verify>
  <done>IndexedDB sync integration fixed, cache populating correctly</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete service layer with IndexedDB sync working correctly</what-built>
  <how-to-verify>
1. Run the app: `cd archibald-web-app/frontend && npm run dev`
2. Open browser DevTools → Application tab → IndexedDB → ArchibaldOfflineDB
3. **Verify tables populated**:
   - `customers` table: Should have ~1500 records
   - `products` table: Should have ~5000 records
   - `productVariants` table: Should have variant records
   - `prices` table: Should have price records
   - `cacheMetadata` table: Should show last sync times
4. **Test CustomerService** (browser console):
   ```javascript
   // Import service (if exposed globally or via DevTools)
   const { customerService } = await import('./services/customers.service.ts');

   // Test search
   const results = await customerService.searchCustomers('mario');
   console.log(results); // Should show customers with "mario" in name
   ```
5. **Test ProductService** (browser console):
   ```javascript
   const { productService } = await import('./services/products.service.ts');

   // Test search by article
   const products = await productService.searchProducts('h129');
   console.log(products); // Should show products with "h129" in article code

   // Test variant selection
   const variant = await productService.getVariantByQuantity('PRODUCT_ID', 120);
   console.log(variant); // Should return appropriate variant
   ```
6. **Check console logs**:
   - Should see `[SyncService] Starting full sync...`
   - Should see `[SyncService] Full sync completed`
   - Should NOT see errors
7. **Test cache-first pattern**:
   - Go offline (Network tab → Offline)
   - Try searching customers/products
   - Should still work (reading from IndexedDB cache)

**Expected Results:**
- ✅ IndexedDB populated with all data
- ✅ Customer search returns results (<100ms)
- ✅ Product search by article code works
- ✅ Variant selection logic correct
- ✅ Offline mode works (cache-first)
- ✅ No console errors
  </how-to-verify>
  <resume-signal>Type "approved" if all services working correctly, or describe specific issues found</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] CustomerService implemented with tests
- [ ] ProductService implemented with tests (including variant logic)
- [ ] PriceService implemented with tests
- [ ] OrderService implemented with tests
- [ ] SyncService created and integrated with app
- [ ] IndexedDB sync working - tables populated
- [ ] All unit tests passing
- [ ] User verified services working in browser
</verification>

<success_criteria>
- All 4 services implemented with comprehensive test coverage
- IndexedDB sync fixed - no longer empty
- Cache-first pattern working correctly
- API fallback tested and working
- Variant selection logic correct for all edge cases
- User verified services working in production app
- Code is clean, testable, maintainable
</success_criteria>

<output>
After completion, create `.planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-02-SUMMARY.md`:

# Phase 28.2 Plan 02: Data Layer & Services - Summary

**Service layer complete - IndexedDB sync fixed, cache-first pattern working**

## Accomplishments

- Built CustomerService with cache-first autocomplete
- Built ProductService with variant selection logic
- Built PriceService for price lookups
- Built OrderService for drafts and pending queue
- Created/updated SyncService for automatic data population
- Fixed IndexedDB empty issue - sync now populates cache correctly
- Comprehensive test coverage for all services
- Verified services working in production app

## Files Created

- `archibald-web-app/frontend/src/services/customers.service.ts` - Customer search and sync
- `archibald-web-app/frontend/src/services/customers.service.spec.ts` - Unit tests
- `archibald-web-app/frontend/src/services/products.service.ts` - Product search, variants
- `archibald-web-app/frontend/src/services/products.service.spec.ts` - Unit tests
- `archibald-web-app/frontend/src/services/prices.service.ts` - Price lookups
- `archibald-web-app/frontend/src/services/prices.service.spec.ts` - Unit tests
- `archibald-web-app/frontend/src/services/orders.service.ts` - Drafts and pending queue
- `archibald-web-app/frontend/src/services/orders.service.spec.ts` - Unit tests
- `archibald-web-app/frontend/src/services/sync.service.ts` - Sync orchestration

## Root Cause Fix: Empty IndexedDB

**Problem**: IndexedDB products/customers tables were empty despite sync orchestrator existing.

**Root Cause**: [Document findings from Task 4]

**Fix**: Created SyncService that triggers automatic sync on app initialization. Sync now populates IndexedDB correctly.

## Test Results

- ✅ All unit tests passing (`npm test`)
- ✅ CustomerService: [X] tests passing
- ✅ ProductService: [X] tests passing (including variant edge cases)
- ✅ PriceService: [X] tests passing
- ✅ OrderService: [X] tests passing
- ✅ IndexedDB populated: ~1500 customers, ~5000 products
- ✅ Cache-first pattern working in offline mode

## Variant Selection Logic

Implemented algorithm:
1. Get all variants sorted by minQty
2. Filter variants where quantity fits [minQty, maxQty] range
3. Return first matching variant (lowest minQty)
4. Edge case: quantity below all minQty → return null
5. Edge case: quantity above all maxQty → return highest variant

Tested edge cases:
- Quantity below minimum: Returns null ✅
- Quantity above maximum: Returns highest variant ✅
- Quantity not multiple: Handled correctly ✅
- Multiple variants match: Returns best fit ✅

## Issues Encountered

[Document any issues, or "None"]

## Next Step

Ready for 28.2-03-PLAN.md (Customer & Product Selection Components)

**Execute**: `/gsd:execute-plan .planning/phases/28.2-rewrite-orderform-with-proper-architecture/28.2-03-PLAN.md`
</output>
