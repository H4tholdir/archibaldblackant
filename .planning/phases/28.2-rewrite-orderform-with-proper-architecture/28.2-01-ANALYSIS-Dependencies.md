# Related Services and Dependencies Analysis

**Analysis Date:** 2026-01-23
**Phase:** 28.2 (Rewrite OrderForm with Proper Architecture)
**Plan:** 01 (Codebase Analysis & Architecture Design)

---

## Executive Summary

This document catalogs all services, utilities, hooks, and dependencies used by the OrderForm component. It reveals:

- **10 External Services** with varying quality and coupling
- **5 Utility Functions** for parsing, validation, and calculations
- **2 Custom Hooks** for voice input and debugging
- **Dual Draft Systems** (IndexedDB + localStorage) causing complexity

**Key Finding:** OrderForm has **high coupling** to 12+ external modules, making testing and refactoring difficult.

---

## 1. Service Dependencies

### 1.1 CacheService

**File:** `frontend/src/services/cache-service.ts`
**Pattern:** Singleton
**Purpose:** IndexedDB query abstraction layer

#### Interface
```typescript
class CacheService {
  // Customer operations
  searchCustomers(query: string, limit: number): Promise<Customer[]>
  getCustomerById(id: string): Promise<Customer | undefined>

  // Product operations
  searchProducts(query: string, limit: number): Promise<ProductWithDetails[]>
  getProductById(id: string): Promise<ProductWithDetails | undefined>

  // Cache freshness
  getCacheAge(): Promise<number | null>
  isCacheStale(): Promise<boolean>
}

export const cacheService = CacheService.getInstance();
```

#### Usage in OrderForm
```typescript
// Line 569: Load all customers
const cachedCustomers = await cacheService.searchCustomers("", 10000);

// Line 631: Load all products
const cachedProducts = await cacheService.searchProducts("", 10000);

// Line 434-435: Check cache age
const age = await cacheService.getCacheAge();
const stale = await cacheService.isCacheStale();

// Line 1042: Pre-submission staleness check
const isStale = await cacheService.isCacheStale();
```

#### Strengths
- Clean abstraction over IndexedDB
- Singleton pattern prevents multiple instances
- Parallel enrichment (variants + prices)
- Performance target: < 100ms

#### Weaknesses
- **No pagination:** Loads ALL records (10,000 limit)
- **No error handling:** IndexedDB failures silently return []
- **No caching:** Query results not cached
- **Empty result issue:** Returns 0 records due to missing population logic

#### Coupling Score: 7/10 (High)
- OrderForm directly calls cache methods 5 times
- Tight dependency on IndexedDB schema
- No interface/abstraction layer

---

### 1.2 DraftService (Legacy)

**File:** `frontend/src/services/draft-service.ts`
**Pattern:** Singleton (via instantiation)
**Purpose:** Auto-save draft orders to IndexedDB during editing

#### Interface
```typescript
class DraftService {
  saveDraft(
    customerId: string,
    customerName: string,
    items: DraftOrderItem[]
  ): Promise<void>

  getDraft(): Promise<DraftOrder | null>

  clearDraft(): Promise<void>
}

export const draftService = new DraftService();
```

#### Usage in OrderForm
```typescript
// Line 489: Restore draft on mount
const draft = await draftService.getDraft();

// Line 532: Auto-save with 1-second debounce
draftService.saveDraft(customerId, customerName, draftOrderItems);

// Line 1090: Clear after submission
await draftService.clearDraft();
```

#### Schema
```typescript
interface DraftOrder {
  id?: number; // Auto-increment
  customerId: string;
  customerName: string;
  items: DraftOrderItem[];
  createdAt: string;
  updatedAt: string;
}

interface DraftOrderItem {
  productId: string;
  productName: string;
  article: string;
  variantId: string;
  quantity: number;
  packageContent: string;
}
```

#### Strengths
- Upsert pattern (reuses existing draft ID)
- Automatic timestamp management
- Simple API

#### Weaknesses
- **Legacy system:** Being replaced by localStorage system
- **Schema mismatch:** DraftOrderItem ‚â† OrderItem
- **No expiration:** Old drafts never cleaned up
- **Single draft:** Only stores most recent

#### Coupling Score: 5/10 (Medium)
- Used in 3 places in OrderForm
- Parallel system with draftOrderStorage causing confusion

---

### 1.3 DraftOrderStorage (New)

**File:** `frontend/src/services/draftOrderStorage.ts`
**Pattern:** Pure functions (not a class)
**Purpose:** Final save draft orders to localStorage before submission

#### Interface
```typescript
// Get all drafts
function getDraftOrders(): DraftOrder[]

// Save new draft
function saveDraftOrder(
  draft: Omit<DraftOrder, "id" | "createdAt" | "updatedAt">
): DraftOrder

// Update existing draft
function updateDraftOrder(
  id: string,
  updates: Partial<Omit<DraftOrder, "id" | "createdAt">>
): DraftOrder | null

// Delete draft
function deleteDraftOrder(id: string): boolean

// Get single draft
function getDraftOrderById(id: string): DraftOrder | null

// Convert to Order format for display
function draftToOrder(draft: DraftOrder): Order
```

#### Storage Schema
```typescript
interface DraftOrder {
  id: string; // UUID: "draft-{timestamp}-{random}"
  customerName: string;
  customerId: string;
  items: Array<{
    articleCode: string;
    quantity: number;
    price: number;
    description?: string;
    productName?: string;
    discount?: number;
  }>;
  discountPercent?: number;
  targetTotalWithVAT?: number;
  notes?: string;
  createdAt: string; // ISO timestamp
  updatedAt: string; // ISO timestamp
}
```

**Storage Location:** `localStorage['archibald_draft_orders']`

#### Usage in OrderForm
```typescript
// Line 448: Load draft for editing (query param: ?draftId=...)
const draft = getDraftOrderById(draftId);

// Line 1077: Update existing draft
draft = updateDraftOrder(editingDraftId, draftData);

// Line 1084: Create new draft
draft = saveDraftOrder(draftData);
```

#### Strengths
- **Simple:** Pure functions, no class complexity
- **Multi-draft:** Stores array of drafts
- **Richer schema:** Supports discountPercent, targetTotalWithVAT, notes
- **UUID:** No ID conflicts

#### Weaknesses
- **No quota check:** localStorage can fill up (5-10MB limit)
- **No error handling:** JSON.parse errors uncaught
- **No expiration:** Old drafts never cleaned up
- **No validation:** Accepts any data shape

#### Coupling Score: 6/10 (Medium-High)
- OrderForm directly manipulates draft format
- Editing flow tightly coupled to localStorage schema

---

### 1.4 Dual Draft System Confusion

**Problem:** Two parallel draft systems with different purposes

#### System Comparison

| Feature | DraftService (IndexedDB) | DraftOrderStorage (localStorage) |
|---------|--------------------------|----------------------------------|
| **Purpose** | Auto-save during editing | Final save before submission |
| **Storage** | IndexedDB (ArchibaldOfflineDB) | localStorage |
| **Pattern** | Singleton class | Pure functions |
| **Draft Count** | Single (most recent) | Multiple (array) |
| **ID Type** | Auto-increment integer | UUID string |
| **Schema** | DraftOrderItem (article, variantId, packageContent) | Item (articleCode, price, discount) |
| **Timestamps** | createdAt, updatedAt | createdAt, updatedAt |
| **Expiration** | None | None |
| **Usage** | Lines 489, 532, 1090 | Lines 448, 1077, 1084 |

#### Flow Visualization
```
User creates order
    ‚Üì
Auto-save to IndexedDB (DraftService) every 1s
    ‚Üì (debounced)
DraftOrder saved
    ‚Üì
User clicks "Create Order"
    ‚Üì
submitOrder() called
    ‚Üì
Save to localStorage (DraftOrderStorage)
    ‚Üì
Clear IndexedDB draft
    ‚Üì
Order in localStorage pending queue
```

#### Recommendation
- **Consolidate to single system** in Phase 28.2-05
- Use localStorage for simplicity (no schema migrations)
- Add expiration logic (30 days)
- Add quota checks

---

## 2. Utility Dependencies

### 2.1 OrderParser Utilities

**File:** `frontend/src/utils/orderParser.ts`
**Purpose:** Voice transcript parsing and validation

#### Functions

##### parseVoiceOrder
```typescript
function parseVoiceOrder(transcript: string): ParsedOrder {
  // 1. Convert Italian numbers to digits
  // 2. Extract customer name
  // 3. Extract article codes
  // 4. Extract quantities
  // 5. Return structured order
}
```

**Logic:**
- Italian number mapping (0-99 + round numbers 100-5000)
- Keyword detection: "cliente", "articolo", "quantit√†"
- Multi-item parsing (comma-separated)
- "punto" ‚Üí "." separator conversion

**Usage:** Line 192

##### validateCustomerName
```typescript
async function validateCustomerName(
  name: string
): Promise<CustomerValidationResult> {
  // 1. Query IndexedDB for exact match
  // 2. Phonetic matching (Soundex-like)
  // 3. Fuzzy matching (Levenshtein distance)
  // 4. Return top 3 suggestions with confidence scores
}

interface CustomerValidationResult {
  matchType: "exact" | "phonetic" | "fuzzy" | "not_found";
  confidence: number; // 0.0 - 1.0
  customer: Customer | null; // Best match
  suggestions: Array<{
    id: string;
    name: string;
    confidence: number;
    vatNumber?: string;
  }>;
  error?: string;
}
```

**Confidence Thresholds:**
- **Exact match:** 1.0 (100%)
- **Phonetic match:** 0.8-0.9 (80-90%)
- **Fuzzy match:** 0.5-0.7 (50-70%)
- **Not found:** 0.0 (0%)

**Usage:** Line 221

##### validateArticleCode
```typescript
async function validateArticleCode(
  code: string
): Promise<ArticleValidationResult> {
  // 1. Normalize code (uppercase, remove spaces)
  // 2. Query IndexedDB for exact match
  // 3. Fuzzy matching on article field
  // 4. Return top 5 suggestions with confidence scores
}

interface ArticleValidationResult {
  matchType: "exact" | "normalized" | "fuzzy" | "not_found";
  confidence: number;
  product: Product | null;
  suggestions?: Array<{
    code: string;
    confidence: number;
    reason: string;
    packageInfo?: string;
  }>;
  error?: string;
}
```

**Usage:** Line 270

##### getVoiceSuggestions
```typescript
function getVoiceSuggestions(transcript: string): string[] {
  // Analyze transcript, return next-step hints
  // Examples:
  // - "Ora aggiungi il codice articolo"
  // - "Specifica la quantit√†"
  // - "Cliente riconosciuto, continua con l'ordine"
}
```

**Usage:** Line 319, 1157

##### detectVoiceCommand
```typescript
function detectVoiceCommand(
  transcript: string
): "close" | "retry" | "apply" | null {
  // Detect keywords:
  // - "applica", "conferma", "vai", "invia" ‚Üí "apply"
  // - "riprova", "ripeti", "ricomincia", "di nuovo" ‚Üí "retry"
  // - "basta", "finito", "chiudi", "annulla", "esci", "stop" ‚Üí "close"
}
```

**Usage:** Line 393

#### Strengths
- **Pure functions:** Easy to test
- **Well-structured:** Clear input/output contracts
- **Comprehensive:** Handles Italian language nuances
- **Async validation:** Non-blocking fuzzy matching

#### Weaknesses
- **No caching:** Validation queries repeated
- **Hard-coded logic:** Italian number mapping in code (not config)
- **No internationalization:** Italian-only
- **Complex parsing:** 200+ line parseVoiceOrder function

#### Coupling Score: 4/10 (Medium-Low)
- OrderForm calls 5 utility functions
- Could be replaced with alternative implementations
- Interface is clean and well-defined

---

### 2.2 Pricing Calculation Utility

**Location:** OrderForm.tsx Lines 923-1025 (99 lines)
**Purpose:** Calculate order pricing with VAT, shipping, and reverse discount

#### Function Signature
```typescript
const calculatePricing = (): PricingResult => {
  const VAT_RATE = 0.22; // 22%
  const SHIPPING_COST_BASE = 15.45; // ‚Ç¨15.45
  const SHIPPING_THRESHOLD = 200; // Free shipping if subtotal > ‚Ç¨200

  // Calculate subtotal (no VAT, no discount)
  const subtotalItems = draftItems.reduce(...)

  // Calculate shipping
  const shippingBase = subtotalItems > SHIPPING_THRESHOLD ? 0 : SHIPPING_COST_BASE;
  const shippingWithVAT = shippingBase * (1 + VAT_RATE);

  // If no target total, no discount
  if (!targetTotalWithVAT) {
    return {
      subtotalItems,
      shippingBase,
      shippingWithVAT,
      discountPercent: 0,
      subtotalAfterDiscount: subtotalItems,
      totalWithVAT: subtotalItems * (1 + VAT_RATE) + shippingWithVAT,
      error: null,
    };
  }

  // Parse target total
  const targetTotal = parseFloat(targetTotalWithVAT);

  // Reverse calculate discount
  // Formula: targetTotal = (subtotalItems * (1 - discount/100)) * (1 + VAT) + shippingWithVAT
  // Solving for discount:
  const subtotalAfterVATAndShipping = targetTotal - shippingWithVAT;
  const subtotalAfterDiscount = subtotalAfterVATAndShipping / (1 + VAT_RATE);
  const discountPercent = 100 * (1 - subtotalAfterDiscount / subtotalItems);

  // Validation: discount must be 0-100%
  if (discountPercent < 0) {
    return { ..., error: "Total too high, no discount needed" };
  }
  if (discountPercent > 100) {
    return { ..., error: "Total too low, impossible discount" };
  }

  return {
    subtotalItems,
    shippingBase,
    shippingWithVAT,
    discountPercent,
    subtotalAfterDiscount,
    totalWithVAT: targetTotal,
    error: null,
  };
};
```

#### Issues
- **Embedded in component:** Not reusable
- **Magic numbers:** VAT_RATE, SHIPPING_COST_BASE, SHIPPING_THRESHOLD hardcoded
- **No unit tests:** Complex math untested
- **Italian error messages:** Not localized

#### Extraction Opportunity
```typescript
// NEW: pricing-utils.ts
export interface PricingConfig {
  vatRate: number;
  shippingCostBase: number;
  shippingThreshold: number;
}

export function calculateOrderPricing(
  items: Array<{ price: number; quantity: number; discount?: number }>,
  config: PricingConfig,
  targetTotalWithVAT?: number
): PricingResult {
  // Same logic, but testable and reusable
}
```

---

## 3. Hook Dependencies

### 3.1 useVoiceInput

**File:** `frontend/src/hooks/useVoiceInput.ts`
**Purpose:** Web Speech API abstraction for voice input

#### Interface
```typescript
interface UseVoiceInputOptions {
  lang?: string;
  continuous?: boolean;
  interimResults?: boolean;
  onResult?: (transcript: string) => void;
  onError?: (error: string) => void;
}

interface UseVoiceInputReturn {
  isListening: boolean;
  transcript: string;
  isSupported: boolean;
  startListening: () => void;
  stopListening: () => void;
  resetTranscript: () => void;
  error: string | null;
}

function useVoiceInput(options: UseVoiceInputOptions): UseVoiceInputReturn
```

#### Usage in OrderForm
```typescript
// Lines 169-387: Hook initialization with 200-line onResult callback
const {
  isListening,
  transcript,
  isSupported,
  startListening,
  stopListening,
  resetTranscript,
  error: voiceError,
} = useVoiceInput({
  lang: "it-IT",
  continuous: true,
  interimResults: true,
  onResult: async (finalTranscript) => {
    // 200 lines of parsing, validation, auto-apply logic
  },
});
```

#### Implementation Details
- Wraps browser `SpeechRecognition` API
- Handles webkit prefix for Safari
- Error translation to Italian
- Auto-restart on "already started" error
- Ref-based callbacks to avoid effect re-runs

#### Strengths
- **Clean API:** Simple hook interface
- **Cross-browser:** Handles webkit prefix
- **Error handling:** User-friendly Italian error messages
- **Ref pattern:** Prevents effect dependency issues

#### Weaknesses
- **No retry logic:** Network errors not auto-recovered
- **No timeout:** Long silences not detected
- **Italian-only:** Error messages hardcoded
- **Tight coupling:** onResult callback embedded in OrderForm (200 lines)

#### Coupling Score: 8/10 (Very High)
- OrderForm embeds 200-line callback logic
- Voice state mixed with form state
- Difficult to test in isolation

---

### 3.2 useVoiceDebugLogger

**File:** `frontend/src/components/VoiceDebugPanel.tsx`
**Purpose:** Debug logging for voice input development

#### Interface
```typescript
interface LogEntry {
  timestamp: string;
  message: string;
  data?: any;
  level: "info" | "warning" | "success" | "error";
}

interface UseVoiceDebugLoggerReturn {
  logs: LogEntry[];
  log: (message: string, data?: any, level?: string) => void;
  clear: () => void;
  exportLogs: () => void;
}

function useVoiceDebugLogger(): UseVoiceDebugLoggerReturn
```

#### Usage in OrderForm
```typescript
// Lines 66-71: Hook initialization
const {
  logs,
  log: debugLog,
  clear: clearLogs,
  exportLogs,
} = useVoiceDebugLogger();

// Throughout component: 20+ debugLog calls
debugLog("üìù Raw Transcript Received", { transcript }, "info");
debugLog("üîç Transcript Parsed", { customerName, itemsCount }, "info");
debugLog("‚úÖ Customer Validation Result", { confidence }, "success");
```

#### Features
- In-memory log array (max 100 entries)
- Export to JSON file
- Timestamped entries
- Color-coded by level

#### Strengths
- **Non-intrusive:** Logs only rendered if isAdmin=true
- **Useful for debugging:** Traces voice input flow
- **Export feature:** Can share logs for troubleshooting

#### Weaknesses
- **Production overhead:** Logging runs even when panel hidden
- **Memory leak:** Logs accumulate indefinitely (max 100, but not enforced)
- **No persistence:** Logs lost on page reload

#### Coupling Score: 3/10 (Low)
- Only used when isAdmin=true
- Can be easily removed
- No impact on functionality

---

## 4. API Endpoint Dependencies

### 4.1 Smart Customer Sync

**Endpoint:** `POST /api/customers/smart-sync`
**Purpose:** Trigger fast, on-demand customer sync when entering OrderForm

**Request:**
```typescript
fetch("/api/customers/smart-sync", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
  },
});
```

**Response:** No body, fire-and-forget

**Usage:** Line 550

**Implementation:** Triggers Sync Orchestrator's `smartCustomerSync()` method
- Pauses other syncs
- Executes customer sync with priority=10
- 3-5 second completion target

---

### 4.2 Resume Syncs

**Endpoint:** `POST /api/customers/resume-syncs`
**Purpose:** Resume normal sync operations when exiting OrderForm

**Request:**
```typescript
fetch("/api/customers/resume-syncs", {
  method: "POST",
  headers: {
    Authorization: `Bearer ${token}`,
    "Content-Type": "application/json",
  },
});
```

**Response:** No body, fire-and-forget

**Usage:** Line 610 (cleanup function in useEffect)

**Implementation:** Calls Sync Orchestrator's `resumeSyncs()` method
- Decrements session count
- Resumes queued syncs when count reaches 0

---

### 4.3 Get Customers (Fallback)

**Endpoint:** `GET /api/customers`
**Purpose:** Fallback when IndexedDB is empty

**Request:**
```typescript
const response = await fetch("/api/customers");
const data = await response.json();
```

**Response:**
```typescript
{
  success: boolean;
  data: {
    customers: Customer[];
  } | Customer[]; // Two formats supported
}
```

**Usage:** Line 578

**Issue:** Returns ALL customers (~1500 records), no pagination

---

### 4.4 Get Products (Fallback)

**Endpoint:** `GET /api/products`
**Purpose:** Fallback when IndexedDB is empty

**Request:**
```typescript
const response = await fetch("/api/products");
const data = await response.json();
```

**Response:**
```typescript
{
  success: boolean;
  data: {
    products: Product[];
  } | Product[]; // Two formats supported
}
```

**Usage:** Line 672

**Issue:** Returns ALL products (~5000 records), no pagination

---

## 5. Component Dependencies

### 5.1 Voice Input Components

**Components Used:**
- `ConfidenceMeter` - Line 1461
- `TranscriptDisplay` - Line 1476
- `ValidationStatus` - Line 1486
- `SmartSuggestions` - Lines 1505, 1542, 1564, 1986
- `CustomerSuggestions` - Line 1958
- `VoicePopulatedBadge` - Lines 2071, 2149, 2248
- `VoiceDebugPanel` - Line 2697

**Total JSX:** ~600 lines of voice-related UI embedded in OrderForm

---

### 5.2 Other UI Components

- `StaleCacheWarning` - Line 2683

---

## 6. Type Dependencies

**From:** `frontend/src/types/order.ts`

```typescript
interface OrderItem {
  articleCode: string;
  productName?: string;
  description: string;
  quantity: number;
  price: number;
  discount: number;
}
```

**From:** `frontend/src/utils/orderParser.ts`

```typescript
interface ParsedOrderWithConfidence {
  customerName?: string;
  customerId?: string;
  customerNameConfidence?: number;
  customerIdConfidence?: number;
  items: Array<{
    articleCode: string;
    productName?: string;
    description?: string;
    quantity: number;
    price?: number;
    discount?: number;
    articleCodeConfidence?: number;
    quantityConfidence?: number;
  }>;
}

interface CustomerValidationResult {
  matchType: "exact" | "phonetic" | "fuzzy" | "not_found";
  confidence: number;
  customer: Customer | null;
  suggestions: Array<{
    id: string;
    name: string;
    confidence: number;
    vatNumber?: string;
  }>;
  error?: string;
}

interface ArticleValidationResult {
  matchType: "exact" | "normalized" | "fuzzy" | "not_found";
  confidence: number;
  product: Product | null;
  suggestions?: Array<{
    code: string;
    confidence: number;
    reason: string;
    packageInfo?: string;
  }>;
  error?: string;
}
```

---

## 7. Dependency Graph

```
OrderForm.tsx (2705 lines)
‚îÇ
‚îú‚îÄ Services
‚îÇ  ‚îú‚îÄ CacheService (searchCustomers, searchProducts, getCacheAge, isCacheStale)
‚îÇ  ‚îú‚îÄ DraftService (saveDraft, getDraft, clearDraft) [LEGACY]
‚îÇ  ‚îî‚îÄ DraftOrderStorage (saveDraftOrder, updateDraftOrder, getDraftOrderById) [NEW]
‚îÇ
‚îú‚îÄ Utilities
‚îÇ  ‚îú‚îÄ orderParser
‚îÇ  ‚îÇ  ‚îú‚îÄ parseVoiceOrder
‚îÇ  ‚îÇ  ‚îú‚îÄ validateCustomerName
‚îÇ  ‚îÇ  ‚îú‚îÄ validateArticleCode
‚îÇ  ‚îÇ  ‚îú‚îÄ getVoiceSuggestions
‚îÇ  ‚îÇ  ‚îî‚îÄ detectVoiceCommand
‚îÇ  ‚îî‚îÄ calculatePricing (embedded in component)
‚îÇ
‚îú‚îÄ Hooks
‚îÇ  ‚îú‚îÄ useVoiceInput (200-line onResult callback)
‚îÇ  ‚îî‚îÄ useVoiceDebugLogger (20+ log calls)
‚îÇ
‚îú‚îÄ API Endpoints
‚îÇ  ‚îú‚îÄ POST /api/customers/smart-sync
‚îÇ  ‚îú‚îÄ POST /api/customers/resume-syncs
‚îÇ  ‚îú‚îÄ GET /api/customers (fallback)
‚îÇ  ‚îî‚îÄ GET /api/products (fallback)
‚îÇ
‚îú‚îÄ Components
‚îÇ  ‚îú‚îÄ ConfidenceMeter
‚îÇ  ‚îú‚îÄ TranscriptDisplay
‚îÇ  ‚îú‚îÄ ValidationStatus
‚îÇ  ‚îú‚îÄ SmartSuggestions
‚îÇ  ‚îú‚îÄ CustomerSuggestions
‚îÇ  ‚îú‚îÄ VoicePopulatedBadge
‚îÇ  ‚îú‚îÄ VoiceDebugPanel
‚îÇ  ‚îî‚îÄ StaleCacheWarning
‚îÇ
‚îî‚îÄ Types
   ‚îú‚îÄ OrderItem
   ‚îú‚îÄ ParsedOrderWithConfidence
   ‚îú‚îÄ CustomerValidationResult
   ‚îî‚îÄ ArticleValidationResult
```

---

## 8. Coupling Analysis

### 8.1 Coupling Scores

| Dependency | Type | Coupling Score | Reason |
|------------|------|----------------|--------|
| CacheService | Service | 7/10 (High) | 5 direct calls, tight to IndexedDB schema |
| DraftService | Service | 5/10 (Medium) | 3 calls, legacy system |
| DraftOrderStorage | Service | 6/10 (Medium-High) | Direct schema manipulation |
| orderParser | Utility | 4/10 (Medium-Low) | Clean interface, 5 function calls |
| calculatePricing | Utility | 10/10 (Embedded) | 99 lines inside component |
| useVoiceInput | Hook | 8/10 (Very High) | 200-line callback embedded |
| useVoiceDebugLogger | Hook | 3/10 (Low) | 20+ calls but non-critical |
| API Endpoints | Network | 5/10 (Medium) | 4 endpoints, fallback logic |
| Voice Components | UI | 6/10 (Medium-High) | 600 lines of JSX embedded |

**Average Coupling:** 6.0/10 (High)

### 8.2 Testability Analysis

**Current Testability:** 2/10 (Very Poor)

**Issues:**
1. **No unit tests:** OrderForm.tsx has 0 test coverage
2. **Embedded logic:** 99-line calculatePricing can't be tested in isolation
3. **Hook dependencies:** useVoiceInput requires browser API mocking
4. **Service dependencies:** Requires IndexedDB mocking
5. **200-line callback:** Voice onResult logic untestable
6. **Complex state:** 40 interdependent state variables

**What Would Be Needed:**
- Mock CacheService
- Mock DraftService
- Mock DraftOrderStorage
- Mock useVoiceInput
- Mock SpeechRecognition API
- Mock IndexedDB
- Mock fetch API
- Mock localStorage

**Too many mocks = poor architecture**

---

## 9. Refactoring Recommendations

### 9.1 Extract Services

#### Pricing Service
```typescript
// NEW: services/pricing-service.ts
export class PricingService {
  constructor(private config: PricingConfig) {}

  calculateOrderPricing(
    items: OrderItem[],
    targetTotal?: number
  ): PricingResult {
    // Extract 99-line logic from OrderForm
  }
}
```

#### Voice Input Service
```typescript
// NEW: services/voice-order-service.ts
export class VoiceOrderService {
  constructor(
    private parser: OrderParser,
    private validator: OrderValidator
  ) {}

  async processTranscript(
    transcript: string
  ): Promise<ProcessedOrder> {
    // Extract 200-line onResult logic
  }
}
```

### 9.2 Consolidate Draft Systems

```typescript
// NEW: services/draft-manager.ts
export class DraftManager {
  // Unified interface for both systems
  async saveDraft(draft: Draft): Promise<void>
  async loadDraft(id: string): Promise<Draft | null>
  async listDrafts(): Promise<Draft[]>
  async deleteDraft(id: string): Promise<void>

  // Migration from IndexedDB ‚Üí localStorage
  async migrate(): Promise<void>
}
```

### 9.3 Dependency Injection

```typescript
// NEW: OrderForm with DI
interface OrderFormDependencies {
  cacheService: CacheService;
  draftManager: DraftManager;
  pricingService: PricingService;
  voiceOrderService: VoiceOrderService;
}

export function OrderForm(props: OrderFormProps & OrderFormDependencies) {
  // Much easier to test with injected dependencies
}
```

---

## 10. Key Findings Summary

### Service Quality

| Service | Quality | Issues |
|---------|---------|--------|
| CacheService | 7/10 | No pagination, empty IndexedDB |
| DraftService | 5/10 | Legacy, schema mismatch |
| DraftOrderStorage | 6/10 | No quota checks, no validation |
| orderParser | 7/10 | Italian-only, no caching |
| useVoiceInput | 8/10 | Tight coupling to OrderForm |

### Critical Issues
1. **Dual Draft Systems:** Confusion and complexity
2. **Embedded Logic:** calculatePricing (99 lines), onResult (200 lines)
3. **High Coupling:** Average 6.0/10 across all dependencies
4. **Poor Testability:** Requires 8+ mocks to test OrderForm
5. **No Abstraction:** Direct service calls throughout component

### Next Steps (Phase 28.2)
1. Extract calculatePricing to PricingService (Plan 04)
2. Extract voice logic to VoiceOrderService (Plan 03)
3. Consolidate draft systems to DraftManager (Plan 05)
4. Add dependency injection (Plan 06)
5. Add unit tests for extracted services (Plan 06)

---

**End of Dependencies Analysis**
