---
phase: 04-sync-scheduler-auto-sync
plan: 02
type: execute
---

<objective>
Refactor the sync scheduler to support per-type intervals and async agent registry, then wire it to bootstrap at server startup with intervals loaded from DB.

Purpose: The scheduler exists but is never started and uses the wrong data source for agent IDs. This plan makes it functional: auto-starts at boot with saved intervals, uses DB for agent list, supports per-type interval updates from admin API.
Output: Refactored sync-scheduler.ts, updated main.ts bootstrap, working auto-sync start/stop/intervals API routes.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-sync-scheduler-auto-sync/04-CONTEXT.md
@.planning/phases/04-sync-scheduler-auto-sync/04-RESEARCH.md
@.planning/phases/04-sync-scheduler-auto-sync/04-01-SUMMARY.md

# Key source files:
@archibald-web-app/backend/src/sync/sync-scheduler.ts
@archibald-web-app/backend/src/sync/sync-scheduler.spec.ts
@archibald-web-app/backend/src/main.ts
@archibald-web-app/backend/src/server.ts
@archibald-web-app/backend/src/routes/sync-status.ts
@archibald-web-app/backend/src/routes/sync-status.spec.ts
@archibald-web-app/backend/src/db/repositories/users.ts
@archibald-web-app/backend/src/db/repositories/sync-settings.ts

**Established patterns:**
- sync-scheduler uses factory function createSyncScheduler (not class)
- EnqueueFn = (type, userId, data) => Promise<string>
- SyncSchedulerLike interface in sync-status.ts defines the API contract the routes expect
- Worker concurrency 10, WORKER_CONCURRENCY env var (Phase 3 decision)
- Agent-specific syncs: customers, orders, ddt, invoices (per whitelisted user)
- Shared syncs: products, prices (service-account, run once)

**Constraining decisions:**
- RESEARCH.md: Keep setInterval pattern (NOT BullMQ Job Schedulers) — simpler for dynamic agent list
- RESEARCH.md: Per-type intervals (not two groups) — matches existing SyncMonitoringDashboard UI expectation
- CONTEXT.md: Intervals applied at next cycle (don't interrupt running sync)
- CONTEXT.md: Auto-start at boot with saved intervals
- BullMQ deduplication handles duplicate enqueues if timer fires while sync is still running

**From RESEARCH.md - Don't hand-roll:**
- Agent list: use `usersRepo.getWhitelistedUsers(pool)` (already exists)
- Deduplication: BullMQ handles it (already configured)
- Validation: Zod schema in sync-status.ts (already exists)

**From RESEARCH.md - Pitfall to avoid:**
- Race condition on interval update: clearInterval old timer BEFORE starting new one
- getWhitelistedUsers on every tick: consider caching or batching (one query per tick cycle, not per sync type)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor createSyncScheduler for per-type intervals and async agent registry</name>
  <files>
archibald-web-app/backend/src/sync/sync-scheduler.ts,
archibald-web-app/backend/src/sync/sync-scheduler.spec.ts
  </files>
  <action>
Refactor createSyncScheduler to replace the two-group model (agentSyncMs/sharedSyncMs) with per-type intervals:

**1. New types:**
```typescript
type SyncType = 'orders' | 'customers' | 'products' | 'prices' | 'ddt' | 'invoices';
type SyncTypeIntervals = Record<SyncType, number>; // milliseconds
```

**2. Change getActiveAgentIds to async:**
Change callback signature from `() => string[]` to `() => Promise<string[]>`. This allows the caller to pass `usersRepo.getWhitelistedUsers(pool).then(users => users.map(u => u.id))`.

**3. Per-type timers:**
Replace `timers: NodeJS.Timeout[]` with `timers: Map<SyncType, NodeJS.Timeout>`. Each sync type gets its own setInterval.

Agent-specific types (customers, orders, ddt, invoices): on each tick, fetch agent IDs (async), enqueue one job per agent.
Shared types (products, prices): on each tick, enqueue one job for 'service-account'.

Optimize: when multiple agent-specific timers fire within the same tick window, fetch agent IDs ONCE and cache for ~5 seconds to avoid redundant DB queries.

**4. New methods:**
- `updateInterval(syncType: SyncType, intervalMs: number): void` — stop old timer for that type, start new one. Do NOT restart other timers.
- `getDetailedIntervals(): Record<SyncType, number>` — return current intervals in minutes (divide ms by 60000).
- Keep existing: `start(intervals: SyncTypeIntervals)`, `stop()`, `isRunning()`, `getIntervals()` (for backward compat, return the old format OR deprecate in favor of getDetailedIntervals).

**5. start() changes:**
- Accept `SyncTypeIntervals` (per-type in ms)
- Create one timer per sync type
- Set `running = true`

**6. Update tests in sync-scheduler.spec.ts:**
- Update to use new per-type intervals format
- Test updateInterval: verify only the target timer is restarted
- Test getDetailedIntervals: verify returns correct per-type values
- Test async getActiveAgentIds: mock returns async result
- Test that agent-specific syncs enqueue for each agent, shared syncs for service-account
- Use `vi.useFakeTimers()` for timer testing (already used in existing tests)

Keep backward compatibility for `getIntervals()` if still used in sync-status.ts routes.
  </action>
  <verify>npm test --prefix archibald-web-app/backend -- --run sync-scheduler</verify>
  <done>
Scheduler supports per-type intervals, async agent registry, updateInterval, getDetailedIntervals.
All sync-scheduler tests pass.
TypeScript compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bootstrap scheduler at startup and fix API routes</name>
  <files>
archibald-web-app/backend/src/main.ts,
archibald-web-app/backend/src/server.ts,
archibald-web-app/backend/src/routes/sync-status.ts,
archibald-web-app/backend/src/routes/sync-status.spec.ts
  </files>
  <action>
**1. Fix main.ts bootstrap (line ~150):**

Replace the broken scheduler creation:
```typescript
// OLD (broken):
const syncScheduler = createSyncScheduler(
  queue.enqueue.bind(queue),
  () => Array.from(agentLock.getAllActive().keys()),
);
// scheduler.start() never called
```

With:
```typescript
// NEW: async agent IDs from DB, auto-start with saved intervals
const syncScheduler = createSyncScheduler(
  queue.enqueue.bind(queue),
  async () => {
    const users = await usersRepo.getWhitelistedUsers(pool);
    return users.map(u => u.id);
  },
);

// Load intervals from DB and auto-start
const savedIntervals = await syncSettingsRepo.getAllIntervals(pool);
// Convert minutes to ms for scheduler
const intervalsMs = Object.fromEntries(
  Object.entries(savedIntervals).map(([k, v]) => [k, v * 60_000])
) as SyncTypeIntervals;
syncScheduler.start(intervalsMs);
logger.info('Sync scheduler started', { intervals: savedIntervals });
```

Import sync-settings repository from Plan 04-01.

**2. Fix sync-status.ts routes:**

The `SyncSchedulerLike` interface already declares optional `updateInterval` and `getDetailedIntervals`. After the scheduler refactor (Task 1), these methods now exist. Ensure:

- `POST /auto-sync/start` (line 81): call `syncScheduler.start()` with intervals loaded from DB (not with undefined). Accept optional body `{ intervals }` or load from DB by default.
- `POST /auto-sync/stop` (line 91): works already, no change needed.
- `GET /intervals` (line 150): `getDetailedIntervals` now exists, will return per-type values.
- `POST /intervals/:type` (line 170): `updateInterval` now exists, will work. ALSO persist the new interval to DB via sync-settings repository. Import syncSettingsRepo and pool from deps.

Add `syncSettingsRepo` and `pool` to `SyncStatusRouterDeps` so the route can persist interval changes to DB.

**3. Fix server.ts wiring (line ~240):**
Update the scheduler adapter passed to createSyncStatusRouter to include the new methods. Ensure `updateInterval` and `getDetailedIntervals` are passed through.

Also update `resumeSyncs` (line 147) to load intervals from DB instead of using `syncScheduler.getIntervals()` (which returns 0 after stop).

**4. Update sync-status.spec.ts:**
- Mock `updateInterval` and `getDetailedIntervals` as regular functions (not optional)
- Add test: POST /intervals/:type persists to DB
- Update start test to verify intervals are loaded
  </action>
  <verify>
npm run build --prefix archibald-web-app/backend && npm test --prefix archibald-web-app/backend -- --run sync-status sync-scheduler
  </verify>
  <done>
Scheduler auto-starts at boot with saved intervals from DB.
getActiveAgentIds reads whitelisted users from DB (not agentLock).
POST /intervals/:type persists to DB AND updates scheduler.
GET /intervals returns per-type values.
POST /auto-sync/start loads intervals from DB.
All route and scheduler tests pass.
TypeScript compiles.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build --prefix archibald-web-app/backend` succeeds
- [ ] `npm test --prefix archibald-web-app/backend` passes ALL tests (not just sync-related)
- [ ] Scheduler uses getWhitelistedUsers (not agentLock.getAllActive)
- [ ] Scheduler auto-starts with intervals from system.sync_settings
- [ ] POST /intervals/:type updates both scheduler AND database
- [ ] GET /intervals returns per-type interval values
</verification>

<success_criteria>

- Sync scheduler starts automatically at server boot
- Agent IDs sourced from DB (whitelisted users), not from active jobs
- Per-type intervals supported and persisted to DB
- API routes functional (no more 501 responses)
- All tests pass, TypeScript compiles
- Ready for Plan 04-03 (customer sync protection)
</success_criteria>

<output>
After completion, create `.planning/phases/04-sync-scheduler-auto-sync/04-02-SUMMARY.md`
</output>
