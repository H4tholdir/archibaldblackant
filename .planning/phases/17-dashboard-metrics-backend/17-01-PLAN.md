---
phase: 17-dashboard-metrics-backend
plan: 01
type: execute
---

<objective>
Create backend API endpoints for dashboard metrics: current month budget and order counts.

Purpose: Replace mock data in dashboard with real metrics calculated from orders database, enabling agents to see accurate progress toward their monthly targets.
Output: Two REST endpoints (GET /api/metrics/budget, GET /api/metrics/orders) returning calculated metrics for authenticated users.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-target-wizard-setup/16-01-SUMMARY.md
@.planning/phases/16-target-wizard-setup/16-04-SUMMARY.md

**Key files:**
@archibald-web-app/backend/src/order-db.ts
@archibald-web-app/backend/src/user-db.ts
@archibald-web-app/backend/src/index.ts
@archibald-web-app/frontend/src/pages/Dashboard.tsx

**Tech stack available:**
- Node.js with Express
- better-sqlite3 for SQLite queries
- JWT authentication middleware (jwtAuth)
- TypeScript strict mode

**Established patterns:**
- Phase 16-01: GET/PUT /api/users/me/target endpoints with JWT auth
- Phase 16-04: Dashboard fetches data on mount, currentBudget=0 placeholder
- OrderDatabase: StoredOrder with totalAmount, creationDate, userId fields
- JWT middleware provides req.user.userId for user-scoped queries

**Constraining decisions:**
- Budget calculation: Sum totalAmount from orders table for current month
- Order counts: Group by temporal periods (today, this week, this month)
- Current month: Filter by creationDate >= first day of month (local timezone)
- User isolation: Filter all queries by userId from JWT token
- Error handling: 401 if JWT invalid, 500 on database errors with logging
- Number formatting: Return raw numbers (frontend handles currency formatting)

**Current mock data (Phase 16-04):**
- Dashboard.tsx: currentBudget={0}, OrdersSummaryWidget: todayCount={3}, weekCount={12}, monthCount={45}
- These are hardcoded placeholders waiting for real API integration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/metrics/budget endpoint</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
    Add GET /api/metrics/budget endpoint with JWT authentication:

    **Logic:**
    1. Extract userId from req.user (jwtAuth middleware)
    2. Get user's target from UserDatabase.getUserTarget(userId)
    3. Calculate current month date range:
       - startOfMonth: First day of current month at 00:00:00 (ISO string)
       - endOfMonth: Last day of current month at 23:59:59 (ISO string)
    4. Query OrderDatabase for current month budget:
       - SELECT SUM(CAST(totalAmount AS REAL)) FROM orders WHERE userId = ? AND creationDate >= ? AND creationDate <= ?
       - Handle NULL totalAmount (some orders may not have amount yet)
       - Default to 0 if no orders found
    5. Calculate progress percentage: (currentBudget / monthlyTarget) * 100
    6. Return JSON: { currentBudget: number, targetBudget: number, currency: string, progress: number, month: string }

    **Implementation details:**
    - Use db.prepare() with parameterized queries (prevent SQL injection)
    - CAST totalAmount to REAL for accurate sum (stored as TEXT in DB)
    - Filter NULL/empty totalAmount values: WHERE totalAmount IS NOT NULL AND totalAmount != ''
    - Month calculation: new Date().toISOString().slice(0,7) for "2026-01" format
    - Progress: Math.min(progress, 100) to cap at 100%, handle division by zero (target=0)
    - Error handling: try/catch with logger.error, return 500 on DB errors

    **Why not use ORM:** OrderDatabase class doesn't have this query method yet, direct SQL is faster for aggregations.

    **Why CAST to REAL:** totalAmount stored as TEXT for precision, need numeric type for SUM().
  </action>
  <verify>
    curl -H "Authorization: Bearer {valid_jwt}" http://localhost:3000/api/metrics/budget returns 200 with JSON
    Response includes: currentBudget (number), targetBudget (number), currency (string), progress (number), month (string)
    Invalid/missing JWT returns 401
  </verify>
  <done>
    GET /api/metrics/budget endpoint created with JWT auth.
    Budget calculated from current month orders (SUM totalAmount).
    Progress percentage calculated correctly.
    User target fetched from UserDatabase.
    Returns structured JSON with all required fields.
    Handles edge cases (no orders, no target, NULL amounts).
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/metrics/orders endpoint</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
    Add GET /api/metrics/orders endpoint with JWT authentication:

    **Logic:**
    1. Extract userId from req.user (jwtAuth middleware)
    2. Calculate temporal boundaries (local timezone):
       - Today: Start of today (00:00:00) to now
       - This week: Start of Monday to now (ISO week definition)
       - This month: First day of month to now
    3. Query OrderDatabase for counts in each period:
       - todayCount: SELECT COUNT(*) FROM orders WHERE userId = ? AND creationDate >= ?
       - weekCount: SELECT COUNT(*) FROM orders WHERE userId = ? AND creationDate >= ?
       - monthCount: SELECT COUNT(*) FROM orders WHERE userId = ? AND creationDate >= ?
    4. Return JSON: { todayCount: number, weekCount: number, monthCount: number, timestamp: string }

    **Implementation details:**
    - Use ISO 8601 dates for all comparisons (creationDate stored as ISO strings)
    - Today start: new Date().setHours(0,0,0,0) then toISOString()
    - Week start: Get current day of week, subtract days to get Monday (0=Sunday, 1=Monday)
    - Month start: new Date(year, month, 1, 0, 0, 0).toISOString()
    - Three separate COUNT queries (could optimize to single query with CASE, but clarity over micro-optimization)
    - Timestamp: Include query execution time for frontend cache validation

    **Why separate queries:** Clearer logic, easier debugging, negligible performance difference for small datasets.

    **Why ISO week:** Monday-Sunday week matches European business conventions (Italy).
  </action>
  <verify>
    curl -H "Authorization: Bearer {valid_jwt}" http://localhost:3000/api/metrics/orders returns 200 with JSON
    Response includes: todayCount (number), weekCount (number), monthCount (number), timestamp (string)
    Counts match expected values based on test data
    Invalid/missing JWT returns 401
  </verify>
  <done>
    GET /api/metrics/orders endpoint created with JWT auth.
    Order counts calculated for today, this week, this month.
    Temporal boundaries correctly handle timezone and week start (Monday).
    User-scoped queries filter by userId.
    Returns structured JSON with counts and timestamp.
    TypeScript compilation passes.
  </done>
</task>

<task type="auto">
  <name>Task 3: Update Dashboard to fetch metrics from API</name>
  <files>archibald-web-app/frontend/src/pages/Dashboard.tsx</files>
  <action>
    Replace mock data with real API calls in Dashboard component:

    **Budget metrics integration:**
    1. Add state: const [budgetData, setBudgetData] = useState<{ currentBudget: number; progress: number } | null>(null)
    2. Fetch in same useEffect as target (after target fetch succeeds):
       - GET http://localhost:3000/api/metrics/budget with JWT header
       - Parse response, setBudgetData({ currentBudget, progress })
    3. Update BudgetWidget props:
       - OLD: currentBudget={0}
       - NEW: currentBudget={budgetData?.currentBudget ?? 0}
    4. Update TargetVisualizationWidget props:
       - OLD: currentProgress={0}
       - NEW: currentProgress={budgetData?.progress ?? 0}

    **Order metrics integration:**
    1. Add state: const [orderMetrics, setOrderMetrics] = useState<{ todayCount: number; weekCount: number; monthCount: number } | null>(null)
    2. Fetch in same useEffect (parallel with budget):
       - GET http://localhost:3000/api/metrics/orders with JWT header
       - Parse response, setOrderMetrics(data)
    3. Update OrdersSummaryWidget props:
       - OLD: todayCount={3} weekCount={12} monthCount={45}
       - NEW: todayCount={orderMetrics?.todayCount ?? 0} weekCount={orderMetrics?.weekCount ?? 0} monthCount={orderMetrics?.monthCount ?? 0}

    **Loading state:**
    - Keep existing loading state, extend to wait for all three fetches (target, budget, orders)
    - Use Promise.all() for parallel fetches: const [targetRes, budgetRes, ordersRes] = await Promise.all([...])
    - Only render widgets when all data loaded

    **Error handling:**
    - Log fetch errors to console: console.error('[Dashboard] Failed to load metrics:', error)
    - Graceful degradation: Show 0 values if fetch fails (don't block entire dashboard)
    - Existing error state handles missing target, extend for missing metrics

    **Why parallel fetches:** Minimize wait time, all three endpoints independent.

    **Why optional chaining (?.):** Defensive programming, handles null state during loading.
  </action>
  <verify>
    npm run type-check passes

    Manual check:
    1. Dashboard loads without errors
    2. Loading state displays during fetches
    3. BudgetWidget shows real currentBudget (not 0)
    4. OrdersSummaryWidget shows real counts (not mock 3/12/45)
    5. TargetVisualizationWidget shows real progress percentage
    6. Check browser console: No errors, all fetches succeed
    7. Check network tab: GET /api/metrics/budget returns 200, GET /api/metrics/orders returns 200
    8. If no orders exist, widgets display 0 gracefully
  </verify>
  <done>
    Dashboard fetches budget metrics from GET /api/metrics/budget.
    Dashboard fetches order metrics from GET /api/metrics/orders.
    BudgetWidget receives real currentBudget prop.
    OrdersSummaryWidget receives real count props.
    TargetVisualizationWidget receives real progress prop.
    Parallel fetches with Promise.all() for performance.
    Loading state waits for all data.
    Error handling with graceful degradation.
    TypeScript compilation passes.
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run type-check` passes in backend and frontend directories
- [ ] GET /api/metrics/budget returns correct current month budget sum
- [ ] GET /api/metrics/orders returns correct temporal counts
- [ ] Dashboard displays real data (not mock values)
- [ ] Progress percentage calculated accurately
- [ ] User isolation enforced (users only see their own data)
- [ ] No errors in browser console or backend logs
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Two new API endpoints functional with JWT auth
- Dashboard widgets display real metrics from database
- Budget calculation accurate for current month
- Order counts accurate for today/week/month
- No errors or warnings introduced
- User experience improved with real data visibility
  </success_criteria>

<output>
After completion, create `.planning/phases/17-dashboard-metrics-backend/17-01-SUMMARY.md`:

# Phase 17 Plan 01: Dashboard Metrics Backend API Summary

**[Substantive one-liner - what shipped, not "phase complete"]**

## Performance

- **Duration:** X min
- **Started:** YYYY-MM-DDTHH:MM:SSZ
- **Completed:** YYYY-MM-DDTHH:MM:SSZ
- **Tasks:** 3
- **Files modified:** 2

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Task Commits

Each task was committed atomically:

1. **Task 1: Create GET /api/metrics/budget endpoint** - `{commit_hash}` (feat)
2. **Task 2: Create GET /api/metrics/orders endpoint** - `{commit_hash}` (feat)
3. **Task 3: Update Dashboard to fetch metrics from API** - `{commit_hash}` (feat)

## Files Created/Modified

- `archibald-web-app/backend/src/index.ts` - Description
- `archibald-web-app/frontend/src/pages/Dashboard.tsx` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 17 complete. Ready for Phase 18 (Customers Sync Analysis & Optimization).
</output>
