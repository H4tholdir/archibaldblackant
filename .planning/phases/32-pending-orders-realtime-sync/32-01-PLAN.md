---
phase: 32-pending-orders-realtime-sync
plan: 01
type: execute
---

<objective>
Migrare pending orders da HTTP polling (15s) a WebSocket real-time, eliminare completamente UnifiedSyncService polling, raggiungere latency <100ms multi-device.

Purpose: Completare migrazione real-time eliminando ultimo polling HTTP, ridurre traffico 100% per sync (eliminato anche pending polling), semplificare architettura rimuovendo UnifiedSyncService periodic timer.

Output: Pending orders sincronizzati via WebSocket con latency <100ms, UnifiedSyncService polling eliminato completamente, bot coordination via WebSocket events.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# WebSocket Infrastructure (Phase 29-31)
@.planning/phases/29-websocket-server-infrastructure/29-01-SUMMARY.md
@.planning/phases/30-websocket-client-reconnect/30-01-SUMMARY.md
@.planning/phases/31-draft-orders-realtime-sync/31-01-SUMMARY.md

# Key files
@archibald-web-app/frontend/src/hooks/useWebSocket.ts
@archibald-web-app/frontend/src/services/websocket-queue.ts
@archibald-web-app/frontend/src/db/schema.ts
@archibald-web-app/frontend/src/services/unified-sync-service.ts
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/routes/sync-routes.ts
@archibald-web-app/backend/src/draft-realtime.service.ts

**Tech stack available (Phase 29-31):**
- WebSocket server at ws://localhost:3000/ws/realtime with JWT auth
- Frontend useWebSocket() hook con auto-reconnect, exponential backoff (1s→30s)
- Offline queue con localStorage persistence (max 100 items, 24h cleanup)
- Event subscription pattern: subscribe(eventType, callback) returns unsubscribe
- Connection pool: Map<userId, Set<WebSocket>> for per-user multi-device broadcast
- DraftRealtimeService pattern: singleton with event emit methods + frontend subscription handlers

**Established patterns (Phase 31):**
- Server: Singleton service (PendingRealtimeService) con getInstance() + emit methods
- Server: Broadcast methods per user: broadcastToUser(userId, event)
- Client: Singleton service (PendingRealtimeService) con event handlers + IndexedDB updates
- Client: React hook (usePendingSync) for UI real-time updates
- Event-driven subscriptions con cleanup automatico (useEffect pattern)
- Offline queue automatic replay on reconnect
- Schema: UUID-based pending orders con deviceId, needsSync, serverUpdatedAt, deleted (tombstone)

**Constraining decisions:**
- Phase 31-01: Last-Write-Wins conflict resolution con serverUpdatedAt timestamps
- Phase 31-01: Echo prevention via deviceId filtering (prevents local-remote echo loops)
- Phase 31-01: Tombstone pattern preserved until Phase 33 (deleted flag)
- Phase 31-01: REST endpoints preserved for HTTP fallback
- Phase 31-01: Full object in events (vs delta patches) for simpler client logic
- Phase 30-01: Event subscription callback pattern (React-friendly, unsubscribe function return)
- Phase 30-01: Browser native WebSocket API (no external library)
- Phase 30-01: Offline queue with localStorage persistence for resilience
- Phase 29-01: Connection pool Map<userId, Set<WebSocket>> for efficient multi-device broadcast
- Phase 29-01: JWT auth via query param or header for flexibility

**Current implementation:**
- UnifiedSyncService: HTTP polling ogni 15s per pending orders (drafts già rimossi in Phase 31)
- Pending orders schema: PendingOrder interface con UUID, deviceId, needsSync, serverUpdatedAt, deleted, status
- Status types: "pending" | "syncing" | "error" | "completed-warehouse"
- Tombstone pattern: deleted flag preservato fino Phase 33 (direct delete)
- IndexedDB: db.pendingOrders table con Dexie
- Backend: REST endpoints /api/sync/pending-orders (GET/POST/DELETE)

**Migration goal:**
- Eliminate HTTP polling for pending orders (15s timer removal completo)
- Real-time events: PENDING_CREATED, PENDING_UPDATED, PENDING_DELETED, PENDING_SUBMITTED
- Preserve tombstone pattern (deleted flag) per Phase 33 removal
- Bot coordination: WebSocket events for status updates (pending → syncing → completed/error)
- Latency target: <100ms per multi-device sync
- Eliminate UnifiedSyncService periodic sync completely (stopPeriodicSync on init)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend Pending Events & WebSocket Broadcast</name>
  <files>archibald-web-app/backend/src/pending-realtime.service.ts, archibald-web-app/backend/src/routes/sync-routes.ts</files>
  <action>
    Create PendingRealtimeService singleton class (follow Phase 31 DraftRealtimeService pattern):

    **Service responsibilities:**
    - Manage pending order WebSocket broadcasts to all user devices
    - Emit events: PENDING_CREATED, PENDING_UPDATED, PENDING_DELETED, PENDING_SUBMITTED
    - Integration con existing REST endpoints (/api/sync/pending-orders)
    - Bot coordination: broadcast status updates when bot processes order

    **Implementation details:**
    - Import connection manager da Phase 29 (broadcastToUser method)
    - Event payload format: { pendingOrderId, pendingOrder, timestamp, deviceId, status? }
    - PENDING_CREATED: full pending order object (inviato da device creatore)
    - PENDING_UPDATED: full pending order updated (delta merge client-side, status changes)
    - PENDING_DELETED: { pendingOrderId, deleted: true } per tombstone
    - PENDING_SUBMITTED: { pendingOrderId, status: "syncing" | "completed" | "error", errorMessage? }

    **REST endpoint integration:**
    Modify existing /api/sync/pending-orders endpoints to emit WebSocket events:
    - POST /api/sync/pending-orders → emit PENDING_CREATED after DB insert (for new)
    - POST /api/sync/pending-orders → emit PENDING_UPDATED after DB update (for existing)
    - DELETE /api/sync/pending-orders/:id → emit PENDING_DELETED after tombstone mark
    - Bot processOrder() → emit PENDING_SUBMITTED with status updates

    **JWT userId extraction:**
    Use authenticateJWT middleware to extract userId from request
    Broadcast only to user's connected devices (not global broadcast)

    **Bot coordination integration:**
    Add emitPendingSubmitted(userId, pendingOrderId, status, errorMessage?) method
    Called from queue manager when bot starts/completes/fails order processing
    Status: "syncing" when starts, "completed" when success, "error" when fails

    **Error handling:**
    - Log broadcast errors but don't fail REST request
    - Graceful handling if no WebSocket connections for user
    - TypeScript strict types for all event payloads

    **AVOID:**
    - Do NOT remove REST endpoints (needed for HTTP fallback)
    - Do NOT modify bot execution logic (only add WebSocket notifications)
    - Do NOT remove tombstone pattern (Phase 33 scope)
  </action>
  <verify>
    npm run build in backend succeeds

    Verify PendingRealtimeService exports:
    - getInstance() method
    - emitPendingCreated(userId, pendingOrder)
    - emitPendingUpdated(userId, pendingOrder)
    - emitPendingDeleted(userId, pendingOrderId, deviceId)
    - emitPendingSubmitted(userId, pendingOrderId, status, errorMessage?)

    Check /api/sync/pending-orders REST endpoints still compile
    Check TypeScript types for all event payloads
  </verify>
  <done>
    - PendingRealtimeService created with singleton pattern
    - All 4 event types defined (CREATED/UPDATED/DELETED/SUBMITTED)
    - REST endpoints integrated to emit events
    - Bot coordination method added (emitPendingSubmitted)
    - JWT userId extraction working
    - TypeScript compilation passes
    - No breaking changes to REST API or bot logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Frontend Pending WebSocket Subscription & Real-Time Updates</name>
  <files>archibald-web-app/frontend/src/services/pending-realtime.service.ts, archibald-web-app/frontend/src/hooks/usePendingSync.ts</files>
  <action>
    Create frontend pending real-time service and React hook (follow Phase 31 pattern):

    **1. PendingRealtimeService (frontend service):**

    Class responsibilities:
    - Subscribe to PENDING_* events from WebSocket
    - Apply updates to IndexedDB (db.pendingOrders)
    - Handle conflicts using Last-Write-Wins (serverUpdatedAt comparison)
    - Emit UI update events for React components
    - Handle bot status updates (PENDING_SUBMITTED events)

    Conflict resolution strategy (LWW):
    - Compare incoming serverUpdatedAt with local pending order updatedAt
    - If incoming serverUpdatedAt > local → accept server version
    - If incoming serverUpdatedAt ≤ local → ignore (local is newer)
    - Tombstone (deleted: true) always wins regardless of timestamp
    - Status updates from PENDING_SUBMITTED always win (authoritative)

    Event handlers:
    - PENDING_CREATED: Insert pending order into IndexedDB if not exists
    - PENDING_UPDATED: Upsert pending order if serverUpdatedAt > local.updatedAt
    - PENDING_DELETED: Mark pendingOrder.deleted = true (tombstone pattern)
    - PENDING_SUBMITTED: Update status field (syncing/completed/error) + errorMessage

    IndexedDB operations:
    - Use db.pendingOrders.put() for upsert (preserves UUID key)
    - Filter own deviceId to prevent echo (local changes already applied)
    - PENDING_SUBMITTED: always update status regardless of deviceId (bot is server-side)
    - Log all operations with [PendingRealtime] prefix for debugging

    **2. usePendingSync() custom React hook:**

    Hook responsibilities:
    - Initialize WebSocket subscription on mount
    - Provide real-time pending orders list updates to components
    - Handle connection state (connecting/connected/disconnected)
    - Cleanup subscriptions on unmount
    - Expose bot status updates for UI feedback

    Hook API:
    ```typescript
    const { pendingOrders, isConnected, isSyncing, refetch } = usePendingSync();
    ```

    Implementation:
    - Use useWebSocket() hook from Phase 30
    - Subscribe to all PENDING_* events on mount
    - useState for pendingOrders array (auto-updates on events)
    - useEffect cleanup to unsubscribe on unmount
    - Load initial pending orders from IndexedDB on mount
    - Filter tombstones (deleted: true) from UI
    - Sort by updatedAt DESC (newest first)

    **Integration with existing components:**
    - Replace UnifiedSyncService pending polling in components
    - Preserve REST API calls for mutations (POST/DELETE)
    - Use hook in OrderQueue, OrderHistory for real-time status updates
    - Status badges auto-update when bot processes orders

    **AVOID:**
    - Do NOT remove UnifiedSyncService yet (Task 3 removes it)
    - Do NOT implement optimistic UI updates (REST → WebSocket flow sufficient)
    - Do NOT bypass IndexedDB (always persist locally first)
  </action>
  <verify>
    npm run build in frontend succeeds

    Check exports:
    - PendingRealtimeService.getInstance()
    - usePendingSync() hook with correct return type

    Verify IndexedDB integration:
    - db.pendingOrders.put() used for upsert
    - Conflict resolution with serverUpdatedAt comparison
    - Status updates from PENDING_SUBMITTED always applied

    Check WebSocket subscription:
    - subscribe() called for all 4 event types
    - unsubscribe() cleanup on unmount
  </verify>
  <done>
    - PendingRealtimeService created with event handlers
    - Conflict resolution LWW implemented with serverUpdatedAt
    - Bot status updates handled via PENDING_SUBMITTED events
    - IndexedDB operations correct (put/upsert)
    - usePendingSync() hook created with pendingOrders/isConnected state
    - WebSocket subscription lifecycle managed correctly
    - TypeScript compilation passes
    - No breaking changes to existing REST flows or bot
  </done>
</task>

<task type="auto">
  <name>Task 3: Remove Pending Polling & Eliminate UnifiedSyncService Periodic Sync</name>
  <files>archibald-web-app/frontend/src/services/unified-sync-service.ts, archibald-web-app/frontend/src/main.tsx</files>
  <action>
    Disable pending orders polling and eliminate UnifiedSyncService periodic sync completely:

    **Modifications to UnifiedSyncService:**

    1. Update syncAll() method:
       - Remove pullPendingOrders() call
       - Remove pushPendingOrders() call
       - Keep syncWarehouse() call (warehouse still uses HTTP polling - not in scope)
       - Comment: "// Pending orders sync handled by WebSocket real-time (Phase 32)"

    2. Update pullAll() method:
       - Remove pullPendingOrders() call
       - Keep pullWarehouse() call

    3. Update initSync() method:
       - Comment out this.startPeriodicSync() call
       - Keep initial pullAll() for warehouse (if online)
       - Keep event listeners (online, visibilitychange) for warehouse sync
       - Add comment: "// Periodic sync disabled - all real-time via WebSocket (Phase 32)"

    4. Deprecate pending orders methods:
       - Mark pullPendingOrders() with @ts-expect-error + comment (kept for reference)
       - Mark pushPendingOrders() with @ts-expect-error + comment (kept for reference)
       - Add comment explaining Phase 32 migration

    5. Comment explanation:
       Add comments explaining complete migration:
       "// Draft sync: WebSocket real-time (Phase 31)"
       "// Pending orders sync: WebSocket real-time (Phase 32)"
       "// Warehouse sync: HTTP polling (preserved - not in v3.0 scope)"
       "// Periodic sync disabled: startPeriodicSync() no longer called"

    **Preserve for future (out of v3.0 scope):**
    - Keep syncWarehouse() and pullWarehouse() methods intact (HTTP polling)
    - Keep warehouse-related REST endpoints
    - Keep event listeners for online/visibility (may trigger warehouse sync)
    - Note: Warehouse WebSocket migration NOT in v3.0 milestone scope

    **Update main.tsx initialization:**
    - Verify UnifiedSyncService.getInstance().initSync() still called
    - Confirm warehouse sync still works (HTTP fallback active)
    - Ensure no errors with periodic sync disabled

    **Verification steps:**
    - Ensure no pending orders polling in network tab (only WebSocket traffic)
    - Verify warehouse sync still works via HTTP polling
    - Check console logs confirm pending WebSocket active
    - Verify periodic timer not running (clearInterval called or never started)

    **AVOID:**
    - Do NOT remove UnifiedSyncService class (warehouse still uses it)
    - Do NOT remove warehouse sync methods (HTTP polling preserved)
    - Do NOT remove event listeners completely (warehouse needs them)
    - Do NOT modify warehouse sync logic
  </action>
  <verify>
    npm run build succeeds

    Grep verification:
    - grep -n "pullPendingOrders" unified-sync-service.ts should show only comments/deprecation
    - grep -n "pushPendingOrders" unified-sync-service.ts should show only comments/deprecation
    - grep -n "startPeriodicSync" unified-sync-service.ts should show method exists but not called
    - grep -n "syncWarehouse" unified-sync-service.ts should return >0 results (preserved)

    Check periodic sync disabled:
    - startPeriodicSync() method exists but commented out in initSync()
    - syncInterval never starts
    - 15s polling timer eliminated

    Verify comments added about Phase 32 migration
    Verify warehouse sync methods intact
  </verify>
  <done>
    - pullPendingOrders() and pushPendingOrders() calls removed from syncAll()
    - pullAll() updated to skip pending orders
    - startPeriodicSync() disabled in initSync() (commented out or not called)
    - Comments explaining complete WebSocket migration added
    - Pending orders methods deprecated with @ts-expect-error + comments
    - Warehouse sync (HTTP polling) preserved intact
    - Event listeners preserved for warehouse sync
    - TypeScript compilation passes
    - No breaking changes to warehouse sync
    - Periodic sync timer completely eliminated (15s polling gone)
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] npm run build succeeds in both backend and frontend
- [ ] Backend PendingRealtimeService exports all 4 emit methods
- [ ] Frontend PendingRealtimeService handles all 4 event types + bot status
- [ ] usePendingSync() hook returns pendingOrders array and connection state
- [ ] WebSocket events broadcast to all user devices
- [ ] IndexedDB updates applied with LWW conflict resolution
- [ ] Bot status updates (syncing/completed/error) work via PENDING_SUBMITTED
- [ ] Pending orders polling removed from UnifiedSyncService
- [ ] Periodic sync timer completely disabled (15s polling eliminated)
- [ ] Warehouse sync still active (HTTP polling preserved)
- [ ] No TypeScript errors or warnings
- [ ] WebSocket connection shows in browser DevTools
</verification>

<success_criteria>

- All 3 tasks completed
- Backend emits PENDING_CREATED/UPDATED/DELETED/SUBMITTED events via WebSocket
- Frontend subscribes to pending events and updates IndexedDB in real-time
- Bot coordination: status updates broadcast via PENDING_SUBMITTED events
- Conflict resolution with Last-Write-Wins using serverUpdatedAt
- Pending orders polling eliminated from UnifiedSyncService
- Periodic sync timer completely disabled (no more 15s HTTP polling)
- Warehouse HTTP polling preserved (out of v3.0 scope)
- Tombstone pattern preserved (deleted flag, Phase 33 removes it)
- REST API endpoints preserved for HTTP fallback
- TypeScript strict mode passes without errors
- No breaking changes to existing pending order or bot flows
- Real-time latency <100ms verified in manual testing
</success_criteria>

<output>
After completion, create `.planning/phases/32-pending-orders-realtime-sync/32-01-SUMMARY.md`:

# Phase 32 Plan 01: Pending Orders Real-Time Sync Summary

**Pending orders migrati a WebSocket real-time con latency <100ms, eliminato completamente polling HTTP di UnifiedSyncService, 100% riduzione traffico periodic sync**

## Accomplishments

- Backend PendingRealtimeService con 4 eventi (CREATED/UPDATED/DELETED/SUBMITTED)
- Frontend real-time subscription con LWW conflict resolution
- usePendingSync() React hook per UI updates automatiche
- Bot coordination via PENDING_SUBMITTED events (status updates real-time)
- Polling HTTP eliminato completamente (100% reduction vs 15s timer)
- UnifiedSyncService periodic sync disabled (startPeriodicSync removed)
- Warehouse polling preservato (HTTP fallback, not in v3.0 scope)
- Tombstone pattern mantenuto (Phase 33 removal)

## Files Created/Modified

### Backend
- `backend/src/pending-realtime.service.ts` - WebSocket broadcast service (CREATED)
- `backend/src/routes/sync-routes.ts` - REST endpoint integration con events (MODIFIED)

### Frontend
- `frontend/src/services/pending-realtime.service.ts` - Event handlers + IndexedDB sync (CREATED)
- `frontend/src/hooks/usePendingSync.ts` - React hook per real-time updates (CREATED)
- `frontend/src/services/unified-sync-service.ts` - Rimosso pending polling, disabled periodic sync (MODIFIED)
- `frontend/src/main.tsx` - Verification di inizializzazione (VERIFIED)

## Decisions Made

- LWW conflict resolution con serverUpdatedAt timestamp comparison (same as Phase 31)
- Bot status updates always win (PENDING_SUBMITTED is authoritative)
- Tombstone pattern preserved (deleted flag) per backward compatibility
- REST endpoints preserved per HTTP fallback se WebSocket unavailable
- Event payload format: { pendingOrderId, pendingOrder, timestamp, deviceId, status? }
- IndexedDB upsert con db.pendingOrders.put() preserva UUID keys
- Warehouse sync preserved (HTTP polling) - not in v3.0 milestone scope

## Issues Encountered

[Documentare eventuali problemi e risoluzioni]

## Next Phase Readiness

Ready for Phase 33: Direct Delete & Tombstone Removal

**What's ready:**
- WebSocket infrastructure proven con draft + pending real-time sync
- HTTP polling completely eliminated (100% real-time for drafts + pending)
- Conflict resolution pattern (LWW) validato e funzionante per due entity types
- React hook pattern stabilito per real-time updates (drafts + pending)
- Bot coordination via WebSocket events working
- Offline queue replay automatico già testato (Phase 30)

**What Phase 33 needs:**
- Remove tombstone pattern (deleted flag) for both drafts and pending orders
- Implement direct DELETE in IndexedDB (db.draftOrders.delete(), db.pendingOrders.delete())
- Simplify code: eliminate tombstone filtering in UI (~500 lines reduction estimated)
- Update conflict resolution: no more "tombstone always wins" logic
- Backend: verify cascade deletion working without tombstones

</output>
