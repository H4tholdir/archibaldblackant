---
phase: 25-sync-monitoring-dashboard
plan: 02
type: execute
---

<objective>
Create backend API endpoints for sync monitoring and interval configuration.

Purpose: Expose sync history, status metrics, and interval configuration to frontend dashboard.
Output: 4 admin-only endpoints for monitoring status, history, and dynamic interval updates.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-sync-monitoring-dashboard/25-CONTEXT.md
@.planning/phases/25-sync-monitoring-dashboard/25-01-SUMMARY.md

**Key files:**
@archibald-web-app/backend/src/index.ts
@archibald-web-app/backend/src/sync-orchestrator.ts

**Tech stack available:**
- Backend: Express.js, TypeScript, JWT authentication
- Middleware: authenticateToken, requireAdmin (Phase 24)
- SyncOrchestrator: getHistory() method (from Plan 25-01)
- Auto-sync infrastructure: startAutoSync(), stopAutoSync() (Phase 24)

**Established patterns:**
- Admin-only API endpoints with JWT + requireAdmin middleware (Phase 24-01)
- JSON responses with `{ success: true, ... }` format
- Error handling with try-catch and 500 status codes
- Validation: intervals must be â‰¥ 5 minutes (from CONTEXT.md)

**Constraining decisions:**
- Phase 24-01: Admin-only API endpoints prevent unauthorized access
- Phase 22: SyncOrchestrator singleton with mutex ensures safe orchestrator modifications
- CONTEXT.md: Intervals configurable from 5 minutes to 1440 minutes (24 hours)

**From CONTEXT.md - API Endpoints Needed:**
- GET /api/sync/monitoring/status - Returns status + history for all 6 types
- POST /api/sync/intervals/:type - Update interval for sync type (dynamic restart)
- GET /api/sync/intervals - Get current intervals for all types
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GET /api/sync/monitoring/status endpoint</name>
  <files>archibald-web-app/backend/src/index.ts</files>
  <action>
    Add endpoint after existing sync endpoints (around line 4800, after /api/sync/auto-sync routes):

    ```typescript
    // ========== SYNC MONITORING ENDPOINTS (Phase 25) ==========

    /**
     * GET /api/sync/monitoring/status
     * Returns comprehensive monitoring data for all 6 sync types:
     * - Current status (from orchestrator.getStatus())
     * - Sync history (last N executions per type)
     * - Next scheduled execution times
     * - Current intervals
     */
    app.get(
      "/api/sync/monitoring/status",
      authenticateToken,
      requireAdmin,
      (req, res) => {
        try {
          const limit = parseInt(req.query.limit as string) || 20;

          // Get orchestrator status
          const orchestratorStatus = syncOrchestrator.getStatus();

          // Build response with history for each type
          const types: Record<string, any> = {};
          const syncTypes: SyncType[] = ["orders", "customers", "products", "prices", "ddt", "invoices"];

          for (const type of syncTypes) {
            const history = syncOrchestrator.getHistory(type, limit);
            const status = orchestratorStatus.statuses[type];

            types[type] = {
              // Current status
              isRunning: status.isRunning,
              lastRunTime: status.lastRunTime,
              queuePosition: status.queuePosition,

              // History
              history: history.map(entry => ({
                timestamp: entry.timestamp.toISOString(),
                duration: entry.duration,
                success: entry.success,
                error: entry.error,
              })),

              // Health indicator (based on last run)
              health: history.length > 0 && history[0].success ? "healthy" :
                      history.length > 0 && !history[0].success ? "unhealthy" :
                      "idle",
            };
          }

          res.json({
            success: true,
            currentSync: orchestratorStatus.currentSync,
            types,
          });
        } catch (error: any) {
          logger.error("[API] Error getting monitoring status:", error);
          res.status(500).json({
            success: false,
            error: "Failed to get monitoring status",
          });
        }
      }
    );
    ```

    Make sure to import SyncType at top of file if not already imported:
    ```typescript
    import type { SyncType } from "./sync-orchestrator";
    ```
  </action>
  <verify>curl localhost:3000/api/sync/monitoring/status with JWT returns status + history for all 6 types</verify>
  <done>GET /api/sync/monitoring/status endpoint returns comprehensive monitoring data</done>
</task>

<task type="auto">
  <name>Task 2: Create interval configuration endpoints</name>
  <files>archibald-web-app/backend/src/index.ts, archibald-web-app/backend/src/sync-orchestrator.ts</files>
  <action>
    **Part A: Add updateInterval() method to SyncOrchestrator** (archibald-web-app/backend/src/sync-orchestrator.ts)

    Add after stopAutoSync() method (around line 400):

    ```typescript
    /**
     * Update sync interval for a specific type.
     * Dynamically restarts auto-sync with new intervals.
     */
    updateInterval(type: SyncType, intervalMinutes: number): void {
      if (intervalMinutes < 5 || intervalMinutes > 1440) {
        throw new Error("Interval must be between 5 and 1440 minutes");
      }

      logger.info(`[SyncOrchestrator] Updating ${type} interval to ${intervalMinutes} minutes`);

      // Stop current auto-sync
      this.stopAutoSync();

      // Update interval in sync configs (stored in startAutoSync)
      // Since intervals are hardcoded in startAutoSync(), we need to make them configurable
      // For now, store in instance variable
      if (!this.customIntervals) {
        this.customIntervals = {};
      }
      this.customIntervals[type] = intervalMinutes;

      // Restart auto-sync with new intervals
      this.startAutoSync();

      logger.info(`[SyncOrchestrator] Auto-sync restarted with new ${type} interval`);
    }

    /**
     * Get current intervals for all sync types.
     */
    getIntervals(): Record<SyncType, number> {
      // Default intervals (in minutes)
      const defaults: Record<SyncType, number> = {
        orders: 10,
        customers: 30,
        prices: 30,
        invoices: 30,
        ddt: 45,
        products: 90,
      };

      // Merge with custom intervals if any
      return { ...defaults, ...this.customIntervals };
    }
    ```

    Add private field after line 77:
    ```typescript
    private customIntervals: Partial<Record<SyncType, number>> = {};
    ```

    **Modify startAutoSync()** to use customIntervals:
    Find startAutoSync() method (around line 350) and update syncConfigs to check customIntervals:

    ```typescript
    startAutoSync(): void {
      if (this.autoSyncTimers.length > 0 || this.autoSyncIntervals.length > 0) {
        logger.warn("[SyncOrchestrator] Auto-sync already running");
        return;
      }

      // Get intervals (use custom if set, otherwise defaults)
      const intervals = this.getIntervals();

      const syncConfigs = [
        { type: "orders" as SyncType, interval: intervals.orders * 60 * 1000, startDelay: 0 },
        { type: "customers" as SyncType, interval: intervals.customers * 60 * 1000, startDelay: 5 * 60 * 1000 },
        { type: "prices" as SyncType, interval: intervals.prices * 60 * 1000, startDelay: 10 * 60 * 1000 },
        { type: "invoices" as SyncType, interval: intervals.invoices * 60 * 1000, startDelay: 15 * 60 * 1000 },
        { type: "ddt" as SyncType, interval: intervals.ddt * 60 * 1000, startDelay: 20 * 60 * 1000 },
        { type: "products" as SyncType, interval: intervals.products * 60 * 1000, startDelay: 30 * 60 * 1000 },
      ];

      // Rest of method stays the same...
    }
    ```

    **Part B: Add API endpoints** (archibald-web-app/backend/src/index.ts)

    Add after GET /api/sync/monitoring/status:

    ```typescript
    /**
     * GET /api/sync/intervals
     * Returns current sync intervals for all 6 types (in minutes)
     */
    app.get(
      "/api/sync/intervals",
      authenticateToken,
      requireAdmin,
      (req, res) => {
        try {
          const intervals = syncOrchestrator.getIntervals();
          res.json({ success: true, intervals });
        } catch (error: any) {
          logger.error("[API] Error getting intervals:", error);
          res.status(500).json({ success: false, error: "Failed to get intervals" });
        }
      }
    );

    /**
     * POST /api/sync/intervals/:type
     * Update sync interval for a specific type
     * Body: { intervalMinutes: number } (5-1440)
     */
    app.post(
      "/api/sync/intervals/:type",
      authenticateToken,
      requireAdmin,
      (req, res) => {
        try {
          const { type } = req.params;
          const { intervalMinutes } = req.body;

          // Validate type
          const validTypes: SyncType[] = ["orders", "customers", "products", "prices", "ddt", "invoices"];
          if (!validTypes.includes(type as SyncType)) {
            return res.status(400).json({ success: false, error: "Invalid sync type" });
          }

          // Validate interval
          if (typeof intervalMinutes !== "number" || intervalMinutes < 5 || intervalMinutes > 1440) {
            return res.status(400).json({
              success: false,
              error: "Interval must be a number between 5 and 1440 minutes",
            });
          }

          // Update interval
          syncOrchestrator.updateInterval(type as SyncType, intervalMinutes);

          logger.info(`[API] Interval updated for ${type}`, {
            userId: req.user.userId,
            intervalMinutes,
          });

          res.json({
            success: true,
            message: `Interval updated to ${intervalMinutes} minutes`,
            type,
            intervalMinutes,
          });
        } catch (error: any) {
          logger.error("[API] Error updating interval:", error);
          res.status(500).json({ success: false, error: error.message || "Failed to update interval" });
        }
      }
    );
    ```
  </action>
  <verify>TypeScript compiles, GET /api/sync/intervals returns current intervals, POST /api/sync/intervals/orders with intervalMinutes updates interval and restarts auto-sync</verify>
  <done>Interval configuration endpoints functional with dynamic orchestrator restart</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] TypeScript compilation succeeds
- [ ] GET /api/sync/monitoring/status returns status + history
- [ ] GET /api/sync/intervals returns current intervals
- [ ] POST /api/sync/intervals/:type updates interval and restarts auto-sync
- [ ] Validation prevents intervals < 5 or > 1440 minutes
</verification>

<success_criteria>
- GET /api/sync/monitoring/status endpoint functional
- GET /api/sync/intervals endpoint functional
- POST /api/sync/intervals/:type endpoint functional with validation
- SyncOrchestrator.updateInterval() dynamically restarts auto-sync
- All endpoints protected by JWT + requireAdmin middleware
- TypeScript compiles without errors
</success_criteria>

<output>
Create `.planning/phases/25-sync-monitoring-dashboard/25-02-SUMMARY.md`
</output>
